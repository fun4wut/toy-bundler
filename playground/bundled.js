
  const __require = typeof require !== 'undefined' ? require : () => new Proxy({},{
    get: () => ({}) // 非node环境下使用require, mock出一个可以无限套的oject, 避免程序挂掉
  });
  (function(modules) {
    const moduleCache = {}; // 避免循环引用, 参考node https://github.com/nodejs/node/blob/v4.0.0/lib/module.js#L298-L316
    const resolveModule = (id) => {
      const { factory, map } = modules[id];
      /**
       * 1. 检查缓存,如果缓存存在且已经加载,直接返回缓存,不做下面的处理
         2. 如果缓存不存在,新建一个 Module 实例
         3. 将这个 Module 实例放到缓存中
         4. 通过这个 Module 实例来加载文件
         5. 返回这个 Module 实例的 exports
         ### 先放缓存,再加载文件 可以避免循环引用的死锁 ###
       */
      if (moduleCache[id]) {
        return moduleCache[id].exports;
      }
  
      const localModule = {
        exports: {},
        loaded: false,
      };
      moduleCache[id] = localModule;
  
      const localRequire = (requireDeclarationName) => {
        const depId = map[requireDeclarationName];
        return depId >= 0
          ? resolveModule(depId)
          : __require(requireDeclarationName);
      };
  
      factory(localModule, localModule.exports, localRequire);
      localModule.loaded = true;
      return localModule.exports;
    };
    const res = resolveModule(0);
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = res;
    } else {
      (globalThis || self || global).myBundle = res;
    }
  })(
      {
        
      // /Users/admin/Codes/prefetch_gen/src/index.ts
      0: {
        factory: (module, exports, require) => {
          "use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _enquirer = require("enquirer");

var _clipboardy = _interopRequireDefault(require("clipboardy"));

var _parser = require("./parser");

var _pick = _interopRequireDefault(require("lodash/pick"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _process = _interopRequireDefault(require("process"));

var _generator = require("./generator");

var _open = _interopRequireDefault(require("open"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function checkHasCurl() {
  return _checkHasCurl.apply(this, arguments);
}

function _checkHasCurl() {
  _checkHasCurl = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
    var clipContent, useClipCurl;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return _clipboardy["default"].read();

          case 2:
            clipContent = _context2.sent;

            if (!clipContent.includes('curl')) {
              _context2.next = 9;
              break;
            }

            _context2.next = 6;
            return (0, _enquirer.prompt)({
              type: 'confirm',
              name: 'useClipCurl',
              message: '检测到粘贴板有curl指令，是否使用'
            }).then(function (res) {
              return res.useClipCurl;
            });

          case 6:
            useClipCurl = _context2.sent;

            if (!useClipCurl) {
              _context2.next = 9;
              break;
            }

            return _context2.abrupt("return", clipContent);

          case 9:
            _context2.next = 11;
            return (0, _enquirer.prompt)({
              type: 'confirm',
              name: '_',
              message: '请将curl指令复制粘贴板中，然后点击确定'
            });

          case 11:
            return _context2.abrupt("return", checkHasCurl());

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _checkHasCurl.apply(this, arguments);
}

(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
  var _yield$prompt, channelName, cdnUrl, curlStr, curlData, _yield$prompt2, usefulParams, _iterator, _step, p, initialVal, _yield$prompt3, queryKey, finalData, targetFile;

  return _regenerator["default"].wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _enquirer.prompt)([{
            type: 'input',
            name: 'channelName',
            message: '输入channel名称'
          }, {
            type: 'input',
            name: 'cdnUrl',
            message: '输入线上CDN的URL'
          }]);

        case 2:
          _yield$prompt = _context.sent;
          channelName = _yield$prompt.channelName;
          cdnUrl = _yield$prompt.cdnUrl;
          _context.next = 7;
          return checkHasCurl();

        case 7:
          curlStr = _context.sent;
          curlData = (0, _parser.parseCurl)(curlStr);

          if (curlData.warning.length) {
            console.error(curlData.warning);
          }

          if (!(Object.keys(curlData.params).length > 0)) {
            _context.next = 37;
            break;
          }

          _context.next = 13;
          return (0, _enquirer.prompt)({
            type: 'multiselect',
            message: '选择正确的请求参数',
            name: 'usefulParams',
            choices: Object.keys(curlData.params)
          });

        case 13:
          _yield$prompt2 = _context.sent;
          usefulParams = _yield$prompt2.usefulParams;
          curlData.params = (0, _pick["default"])(curlData.params, usefulParams);
          _iterator = _createForOfIteratorHelper(usefulParams);
          _context.prev = 17;

          _iterator.s();

        case 19:
          if ((_step = _iterator.n()).done) {
            _context.next = 29;
            break;
          }

          p = _step.value;
          initialVal = curlData.params[p];
          _context.next = 24;
          return (0, _enquirer.prompt)({
            type: 'input',
            message: "".concat(p, "\u662F\u5426\u4E3A\u9759\u6001\u503C\uFF1F\u5982\u679C\u662F\u4ECEquery\u83B7\u53D6\uFF0C\u8BF7\u586B\u5199\u5BF9\u5E94query\u7684key"),
            name: 'queryKey',
            initial: initialVal
          });

        case 24:
          _yield$prompt3 = _context.sent;
          queryKey = _yield$prompt3.queryKey;

          if (queryKey !== initialVal) {
            curlData.params[p] = "__MAGIC__".concat(queryKey);
          }

        case 27:
          _context.next = 19;
          break;

        case 29:
          _context.next = 34;
          break;

        case 31:
          _context.prev = 31;
          _context.t0 = _context["catch"](17);

          _iterator.e(_context.t0);

        case 34:
          _context.prev = 34;

          _iterator.f();

          return _context.finish(34);

        case 37:
          finalData = (0, _generator.generatePrefetch)({
            cdnUrl: cdnUrl,
            channelName: channelName,
            curlData: curlData
          });
          targetFile = _path["default"].join(_process["default"].cwd(), "prefetch.".concat(channelName, ".json"));

          _fs["default"].writeFileSync(targetFile, JSON.stringify(finalData, null, 2));

          console.log('配置已被写入到', targetFile);
          console.log('请在dolphin中确认你的channel是否有被添加');
          setTimeout(function () {
            (0, _open["default"])('https://cloud.bytedance.net/dolphin/cn/bizline/45/group/11255/rules');
          }, 1000);

        case 43:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, null, [[17, 31, 34, 37]]);
}))();
        },
        map: {"@babel/runtime/helpers/interopRequireDefault":1,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"enquirer":4,"clipboardy":5,"./parser":6,"lodash/pick":7,"fs":-19260817,"path":-19260817,"process":-19260817,"./generator":8,"open":9}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/interopRequireDefault.js
      1: {
        factory: (module, exports, require) => {
          function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/regenerator/index.js
      2: {
        factory: (module, exports, require) => {
          module.exports = require("regenerator-runtime");
        },
        map: {"regenerator-runtime":10}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/asyncToGenerator.js
      3: {
        factory: (module, exports, require) => {
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/index.js
      4: {
        factory: (module, exports, require) => {
          'use strict';

var _construct = require("@babel/runtime/helpers/construct");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _typeof = require("@babel/runtime/helpers/typeof");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var assert = require('assert');

var Events = require('events');

var utils = require('./lib/utils');
/**
 * Create an instance of `Enquirer`.
 *
 * ```js
 * const Enquirer = require('enquirer');
 * const enquirer = new Enquirer();
 * ```
 * @name Enquirer
 * @param {Object} `options` (optional) Options to use with all prompts.
 * @param {Object} `answers` (optional) Answers object to initialize with.
 * @api public
 */


var Enquirer = /*#__PURE__*/function (_Events) {
  _inherits(Enquirer, _Events);

  var _super = _createSuper(Enquirer);

  function Enquirer(options, answers) {
    var _this;

    _classCallCheck(this, Enquirer);

    _this = _super.call(this);
    _this.options = utils.merge({}, options);
    _this.answers = _objectSpread({}, answers);
    return _this;
  }
  /**
   * Register a custom prompt type.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * enquirer.register('customType', require('./custom-prompt'));
   * ```
   * @name register()
   * @param {String} `type`
   * @param {Function|Prompt} `fn` `Prompt` class, or a function that returns a `Prompt` class.
   * @return {Object} Returns the Enquirer instance
   * @api public
   */


  _createClass(Enquirer, [{
    key: "register",
    value: function register(type, fn) {
      if (utils.isObject(type)) {
        for (var _i = 0, _Object$keys = Object.keys(type); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          this.register(key, type[key]);
        }

        return this;
      }

      assert.equal(_typeof(fn), 'function', 'expected a function');
      var name = type.toLowerCase();

      if (fn.prototype instanceof this.Prompt) {
        this.prompts[name] = fn;
      } else {
        this.prompts[name] = fn(this.Prompt, this);
      }

      return this;
    }
    /**
     * Prompt function that takes a "question" object or array of question objects,
     * and returns an object with responses from the user.
     *
     * ```js
     * const Enquirer = require('enquirer');
     * const enquirer = new Enquirer();
     *
     * const response = await enquirer.prompt({
     *   type: 'input',
     *   name: 'username',
     *   message: 'What is your username?'
     * });
     * console.log(response);
     * ```
     * @name prompt()
     * @param {Array|Object} `questions` Options objects for one or more prompts to run.
     * @return {Promise} Promise that returns an "answers" object with the user's responses.
     * @api public
     */

  }, {
    key: "prompt",
    value: function () {
      var _prompt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var questions,
            _iterator,
            _step,
            question,
            _args = arguments;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                questions = _args.length > 0 && _args[0] !== undefined ? _args[0] : [];
                _iterator = _createForOfIteratorHelper([].concat(questions));
                _context.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context.next = 20;
                  break;
                }

                question = _step.value;
                _context.prev = 6;

                if (!(typeof question === 'function')) {
                  _context.next = 11;
                  break;
                }

                _context.next = 10;
                return question.call(this);

              case 10:
                question = _context.sent;

              case 11:
                _context.next = 13;
                return this.ask(utils.merge({}, this.options, question));

              case 13:
                _context.next = 18;
                break;

              case 15:
                _context.prev = 15;
                _context.t0 = _context["catch"](6);
                return _context.abrupt("return", Promise.reject(_context.t0));

              case 18:
                _context.next = 4;
                break;

              case 20:
                _context.next = 25;
                break;

              case 22:
                _context.prev = 22;
                _context.t1 = _context["catch"](2);

                _iterator.e(_context.t1);

              case 25:
                _context.prev = 25;

                _iterator.f();

                return _context.finish(25);

              case 28:
                return _context.abrupt("return", this.answers);

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 22, 25, 28], [6, 15]]);
      }));

      function prompt() {
        return _prompt.apply(this, arguments);
      }

      return prompt;
    }()
  }, {
    key: "ask",
    value: function () {
      var _ask = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(question) {
        var _this2 = this;

        var opts, _question, type, name, set, get, prompt, value, emit;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(typeof question === 'function')) {
                  _context2.next = 4;
                  break;
                }

                _context2.next = 3;
                return question.call(this);

              case 3:
                question = _context2.sent;

              case 4:
                opts = utils.merge({}, this.options, question);
                _question = question, type = _question.type, name = _question.name;
                set = utils.set, get = utils.get;

                if (!(typeof type === 'function')) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 10;
                return type.call(this, question, this.answers);

              case 10:
                type = _context2.sent;

              case 11:
                if (type) {
                  _context2.next = 13;
                  break;
                }

                return _context2.abrupt("return", this.answers[name]);

              case 13:
                assert(this.prompts[type], "Prompt \"".concat(type, "\" is not registered"));
                prompt = new this.prompts[type](opts);
                value = get(this.answers, name);
                prompt.state.answers = this.answers;
                prompt.enquirer = this;

                if (name) {
                  prompt.on('submit', function (value) {
                    _this2.emit('answer', name, value, prompt);

                    set(_this2.answers, name, value);
                  });
                } // bubble events


                emit = prompt.emit.bind(prompt);

                prompt.emit = function () {
                  var _this2$emit;

                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  (_this2$emit = _this2.emit).call.apply(_this2$emit, [_this2].concat(args));

                  return emit.apply(void 0, args);
                };

                this.emit('prompt', prompt, this);

                if (!(opts.autofill && value != null)) {
                  _context2.next = 29;
                  break;
                }

                prompt.value = prompt.input = value; // if "autofill=show" render the prompt, otherwise stay "silent"

                if (!(opts.autofill === 'show')) {
                  _context2.next = 27;
                  break;
                }

                _context2.next = 27;
                return prompt.submit();

              case 27:
                _context2.next = 32;
                break;

              case 29:
                _context2.next = 31;
                return prompt.run();

              case 31:
                value = prompt.value = _context2.sent;

              case 32:
                return _context2.abrupt("return", value);

              case 33:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function ask(_x) {
        return _ask.apply(this, arguments);
      }

      return ask;
    }()
    /**
     * Use an enquirer plugin.
     *
     * ```js
     * const Enquirer = require('enquirer');
     * const enquirer = new Enquirer();
     * const plugin = enquirer => {
     *   // do stuff to enquire instance
     * };
     * enquirer.use(plugin);
     * ```
     * @name use()
     * @param {Function} `plugin` Plugin function that takes an instance of Enquirer.
     * @return {Object} Returns the Enquirer instance.
     * @api public
     */

  }, {
    key: "use",
    value: function use(plugin) {
      plugin.call(this, this);
      return this;
    }
  }, {
    key: "Prompt",
    get: function get() {
      return this._Prompt || this.constructor.Prompt;
    },
    set: function set(value) {
      this._Prompt = value;
    }
  }, {
    key: "prompts",
    get: function get() {
      return this.constructor.prompts;
    }
  }], [{
    key: "Prompt",
    get: function get() {
      return this._Prompt || require('./lib/prompt');
    },
    set: function set(value) {
      this._Prompt = value;
    }
  }, {
    key: "prompts",
    get: function get() {
      return require('./lib/prompts');
    }
  }, {
    key: "types",
    get: function get() {
      return require('./lib/types');
    }
    /**
     * Prompt function that takes a "question" object or array of question objects,
     * and returns an object with responses from the user.
     *
     * ```js
     * const { prompt } = require('enquirer');
     * const response = await prompt({
     *   type: 'input',
     *   name: 'username',
     *   message: 'What is your username?'
     * });
     * console.log(response);
     * ```
     * @name Enquirer#prompt
     * @param {Array|Object} `questions` Options objects for one or more prompts to run.
     * @return {Promise} Promise that returns an "answers" object with the user's responses.
     * @api public
     */

  }, {
    key: "prompt",
    get: function get() {
      var _this3 = this;

      var fn = function fn(questions) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }

        var enquirer = _construct(_this3, rest);

        var emit = enquirer.emit.bind(enquirer);

        enquirer.emit = function () {
          fn.emit.apply(fn, arguments);
          return emit.apply(void 0, arguments);
        };

        return enquirer.prompt(questions);
      };

      utils.mixinEmitter(fn, new Events());
      return fn;
    }
  }]);

  return Enquirer;
}(Events);

utils.mixinEmitter(Enquirer, new Events());
var prompts = Enquirer.prompts;

var _loop = function _loop() {
  var name = _Object$keys2[_i2];
  var key = name.toLowerCase();

  var run = function run(options) {
    return new prompts[name](options).run();
  };

  Enquirer.prompt[key] = run;
  Enquirer[key] = run;

  if (!Enquirer[name]) {
    Reflect.defineProperty(Enquirer, name, {
      get: function get() {
        return prompts[name];
      }
    });
  }
};

for (var _i2 = 0, _Object$keys2 = Object.keys(prompts); _i2 < _Object$keys2.length; _i2++) {
  _loop();
}

var exp = function exp(name) {
  utils.defineExport(Enquirer, name, function () {
    return Enquirer.types[name];
  });
};

exp('ArrayPrompt');
exp('AuthPrompt');
exp('BooleanPrompt');
exp('NumberPrompt');
exp('StringPrompt');
module.exports = Enquirer;
        },
        map: {"@babel/runtime/helpers/construct":11,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"assert":-19260817,"events":-19260817,"./lib/utils":19,"./lib/prompt":20,"./lib/prompts":21,"./lib/types":22}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/index.js
      5: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _typeof = require("@babel/runtime/helpers/typeof");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var isWSL = require('is-wsl');

var termux = require('./lib/termux.js');

var linux = require('./lib/linux.js');

var macos = require('./lib/macos.js');

var windows = require('./lib/windows.js');

var platformLib = function () {
  switch (process.platform) {
    case 'darwin':
      return macos;

    case 'win32':
      return windows;

    case 'android':
      if (process.env.PREFIX !== '/data/data/com.termux/files/usr') {
        throw new Error('You need to install Termux for this module to work on Android: https://termux.com');
      }

      return termux;

    default:
      // `process.platform === 'linux'` for WSL.
      if (isWSL) {
        return windows;
      }

      return linux;
  }
}();

exports.write = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(text) {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof text !== 'string')) {
              _context.next = 2;
              break;
            }

            throw new TypeError("Expected a string, got ".concat(_typeof(text)));

          case 2:
            _context.next = 4;
            return platformLib.copy({
              input: text
            });

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.read = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
  return _regeneratorRuntime.wrap(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", platformLib.paste({
            stripEof: false
          }));

        case 1:
        case "end":
          return _context2.stop();
      }
    }
  }, _callee2);
}));

exports.writeSync = function (text) {
  if (typeof text !== 'string') {
    throw new TypeError("Expected a string, got ".concat(_typeof(text)));
  }

  platformLib.copySync({
    input: text
  });
};

exports.readSync = function () {
  return platformLib.pasteSync({
    stripEof: false
  }).stdout;
};
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/asyncToGenerator":3,"is-wsl":23,"./lib/termux.js":24,"./lib/linux.js":25,"./lib/macos.js":26,"./lib/windows.js":27}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/src/parser/index.ts
      6: {
        factory: (module, exports, require) => {
          "use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCurl = parseCurl;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _curlconverter = _interopRequireDefault(require("curlconverter"));

var _omit = _interopRequireDefault(require("lodash/omit"));

var _forEach = _interopRequireDefault(require("lodash/forEach"));

var _qs = _interopRequireDefault(require("qs"));

// @ts-ignore [no types]
var commonParams = ['is_guest_mode', 'manifest_version_code', '_rticket', 'app_type', 'iid', 'channel', 'is_android_pad', 'device_type', 'language', 'cpu_support64', 'host_abi', 'resolution', 'update_version_code', 'cdid', 'minor_status', 'appTheme', 'os_api', 'dpi', 'ac', 'package', 'device_id', 'os', 'os_version', 'version_code', 'effect_channel', 'app_name', 'version_name', 'device_brand', 'need_personal_recommend', 'ssmix', 'device_platform', 'aid', 'app_version', 'build_number', 'is_vcd', 'js_sdk_version', 'mcc_mnc', 'screen_width', 'slide_guide_has_shown', 'tma_jssdk_version', 'webcast_app_id', 'openlive_personal_recommend', 'pass-region', 'pass-route', 'webcast_sdk_version', 'webcast_gps_access', 'effect_sdk_version', 'webcast_language', 'webcast_locale', 'webcast_appid', 'ab_sdk_version', 'compliance_status', 'Authorization', 'OpenId', 'open_rpc_common_parameter_optimized', 'live_request_from_jsb', 'current_network_quality_info'];
var formalContentTypeKey = 'Content-Type';

function parseCurl(str) {
  var _curl$method;

  var curl = {};

  try {
    curl = JSON.parse(_curlconverter["default"].toJsonString(str));
  } catch (_unused) {
    console.error('curl 解析出错！');
    process.exit(1);
  }

  var res = {
    url: curl.url || '',
    method: 'GET',
    data: {},
    headers: {},
    params: {},
    warning: []
  };
  var method = (_curl$method = curl.method) === null || _curl$method === void 0 ? void 0 : _curl$method.toUpperCase();

  if (method === 'GET' || method === 'POST') {
    res.method = method;
  }

  if (curl.queries) {
    // 去除通参
    res.params = (0, _omit["default"])(curl.queries, commonParams);
    (0, _forEach["default"])(res.params, function (v) {
      if (v === 'true' || v === 'false') {
        res.warning.push('请求参数含有true 和 false，请使用0、1作替代');
      }
    });
  }

  var useJson = false;

  for (var _i = 0, _Object$keys = Object.keys(((_curl = curl) === null || _curl === void 0 ? void 0 : _curl.headers) || {}); _i < _Object$keys.length; _i++) {
    var _curl;

    var key = _Object$keys[_i];

    // 处理json格式
    if (key.toLowerCase() === formalContentTypeKey.toLowerCase()) {
      var _curl2, _curl2$headers;

      var val = (_curl2 = curl) === null || _curl2 === void 0 ? void 0 : (_curl2$headers = _curl2.headers) === null || _curl2$headers === void 0 ? void 0 : _curl2$headers[key];

      if (val !== null && val !== void 0 && val.includes('application/json')) {
        useJson = true;
        res.headers = (0, _defineProperty2["default"])({}, key, val);
      }

      break;
    }
  }

  for (var _i2 = 0, _Object$keys2 = Object.keys(((_curl3 = curl) === null || _curl3 === void 0 ? void 0 : _curl3.data) || {}); _i2 < _Object$keys2.length; _i2++) {
    var _curl3;

    var _key = _Object$keys2[_i2];

    try {
      res.data = useJson ? JSON.parse(_key) : _qs["default"].parse(_key);
    } catch (error) {// do nothing
    }
  }

  return res;
}
        },
        map: {"@babel/runtime/helpers/interopRequireDefault":1,"@babel/runtime/helpers/defineProperty":13,"curlconverter":28,"lodash/omit":29,"lodash/forEach":30,"qs":31}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/pick.js
      7: {
        factory: (module, exports, require) => {
          var basePick = require('./_basePick'),
    flatRest = require('./_flatRest');
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */


var pick = flatRest(function (object, paths) {
  return object == null ? {} : basePick(object, paths);
});
module.exports = pick;
        },
        map: {"./_basePick":32,"./_flatRest":33}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/src/generator/index.ts
      8: {
        factory: (module, exports, require) => {
          "use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generatePrefetch = generatePrefetch;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("./utils");

var _omit = _interopRequireDefault(require("lodash/omit"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var baseConfig = {
  occasions: {},
  version: '0.0.2'
};

function generatePrefetch(_ref) {
  var cdnUrl = _ref.cdnUrl,
      channelName = _ref.channelName,
      curlData = _ref.curlData;
  var apiName = (0, _utils.genApiName)(curlData.url);
  return _objectSpread(_objectSpread({}, baseConfig), {}, {
    project: channelName,
    rules: (0, _defineProperty2["default"])({}, (0, _utils.getUrlPath)(cdnUrl), {
      prefetch_apis: [apiName]
    }),
    prefetch_apis: (0, _defineProperty2["default"])({}, apiName, _objectSpread(_objectSpread({
      expire: 10
    }, (0, _omit["default"])(curlData, 'warning')), {}, {
      params: (0, _utils.convertRecord)(curlData.params),
      data: (0, _utils.convertRecord)(curlData.data)
    }))
  });
}
        },
        map: {"@babel/runtime/helpers/interopRequireDefault":1,"@babel/runtime/helpers/defineProperty":13,"./utils":34,"lodash/omit":29}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/open/index.js
      9: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _inherits = require("@babel/runtime/helpers/inherits");

var _setPrototypeOf = require("@babel/runtime/helpers/setPrototypeOf");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { return groups[name] = result[g[name]], groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); return result && (result.groups = buildGroups(result, this)), result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if ("string" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } if ("function" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return "object" != _typeof(args[args.length - 1]) && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }

var path = require('path');

var childProcess = require('child_process');

var _require = require('fs'),
    fs = _require.promises,
    fsConstants = _require.constants;

var isWsl = require('is-wsl');

var isDocker = require('is-docker');

var defineLazyProperty = require('define-lazy-prop'); // Path to included `xdg-open`.


var localXdgOpenPath = path.join(__dirname, 'xdg-open');
var _process = process,
    platform = _process.platform,
    arch = _process.arch;
/**
Get the mount point for fixed drives in WSL.

@inner
@returns {string} The mount point.
*/

var getWslDrivesMountPoint = function () {
  // Default value for "root" param
  // according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config
  var defaultMountPoint = '/mnt/';
  var mountPoint;
  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var configFilePath, isConfigFileExists, configContent, configMountPoint;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!mountPoint) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", mountPoint);

          case 2:
            configFilePath = '/etc/wsl.conf';
            isConfigFileExists = false;
            _context.prev = 4;
            _context.next = 7;
            return fs.access(configFilePath, fsConstants.F_OK);

          case 7:
            isConfigFileExists = true;
            _context.next = 12;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](4);

          case 12:
            if (isConfigFileExists) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", defaultMountPoint);

          case 14:
            _context.next = 16;
            return fs.readFile(configFilePath, {
              encoding: 'utf8'
            });

          case 16:
            configContent = _context.sent;
            configMountPoint = /*#__PURE__*/_wrapRegExp(/(?<!#.*)root\s*=\s*(.*)/g, {
              mountPoint: 1
            }).exec(configContent);

            if (configMountPoint) {
              _context.next = 20;
              break;
            }

            return _context.abrupt("return", defaultMountPoint);

          case 20:
            mountPoint = configMountPoint.groups.mountPoint.trim();
            mountPoint = mountPoint.endsWith('/') ? mountPoint : "".concat(mountPoint, "/");
            return _context.abrupt("return", mountPoint);

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 10]]);
  }));
}();

var pTryEach = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(array, mapper) {
    var latestError, _iterator, _step, item;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iterator = _createForOfIteratorHelper(array);
            _context2.prev = 1;

            _iterator.s();

          case 3:
            if ((_step = _iterator.n()).done) {
              _context2.next = 16;
              break;
            }

            item = _step.value;
            _context2.prev = 5;
            _context2.next = 8;
            return mapper(item);

          case 8:
            return _context2.abrupt("return", _context2.sent);

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](5);
            latestError = _context2.t0;

          case 14:
            _context2.next = 3;
            break;

          case 16:
            _context2.next = 21;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t1 = _context2["catch"](1);

            _iterator.e(_context2.t1);

          case 21:
            _context2.prev = 21;

            _iterator.f();

            return _context2.finish(21);

          case 24:
            throw latestError;

          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 18, 21, 24], [5, 11]]);
  }));

  return function pTryEach(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();

var baseOpen = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {
    var _ref4, app, _ref4$arguments, appArguments, command, cliArguments, childProcessOptions, mountPoint, encodedArguments, isBundled, exeLocalXdgOpen, useSystemXdgOpen, subprocess;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            options = _objectSpread({
              wait: false,
              background: false,
              newInstance: false,
              allowNonzeroExitCode: false
            }, options);

            if (!Array.isArray(options.app)) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt("return", pTryEach(options.app, function (singleApp) {
              return baseOpen(_objectSpread(_objectSpread({}, options), {}, {
                app: singleApp
              }));
            }));

          case 3:
            _ref4 = options.app || {}, app = _ref4.name, _ref4$arguments = _ref4.arguments, appArguments = _ref4$arguments === void 0 ? [] : _ref4$arguments;
            appArguments = _toConsumableArray(appArguments);

            if (!Array.isArray(app)) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", pTryEach(app, function (appName) {
              return baseOpen(_objectSpread(_objectSpread({}, options), {}, {
                app: {
                  name: appName,
                  arguments: appArguments
                }
              }));
            }));

          case 7:
            cliArguments = [];
            childProcessOptions = {};

            if (!(platform === 'darwin')) {
              _context3.next = 17;
              break;
            }

            command = 'open';

            if (options.wait) {
              cliArguments.push('--wait-apps');
            }

            if (options.background) {
              cliArguments.push('--background');
            }

            if (options.newInstance) {
              cliArguments.push('--new');
            }

            if (app) {
              cliArguments.push('-a', app);
            }

            _context3.next = 49;
            break;

          case 17:
            if (!(platform === 'win32' || isWsl && !isDocker())) {
              _context3.next = 31;
              break;
            }

            _context3.next = 20;
            return getWslDrivesMountPoint();

          case 20:
            mountPoint = _context3.sent;
            command = isWsl ? "".concat(mountPoint, "c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe") : "".concat(process.env.SYSTEMROOT, "\\System32\\WindowsPowerShell\\v1.0\\powershell");
            cliArguments.push('-NoProfile', '-NonInteractive', '–ExecutionPolicy', 'Bypass', '-EncodedCommand');

            if (!isWsl) {
              childProcessOptions.windowsVerbatimArguments = true;
            }

            encodedArguments = ['Start'];

            if (options.wait) {
              encodedArguments.push('-Wait');
            }

            if (app) {
              // Double quote with double quotes to ensure the inner quotes are passed through.
              // Inner quotes are delimited for PowerShell interpretation with backticks.
              encodedArguments.push("\"`\"".concat(app, "`\"\""), '-ArgumentList');

              if (options.target) {
                appArguments.unshift(options.target);
              }
            } else if (options.target) {
              encodedArguments.push("\"".concat(options.target, "\""));
            }

            if (appArguments.length > 0) {
              appArguments = appArguments.map(function (arg) {
                return "\"`\"".concat(arg, "`\"\"");
              });
              encodedArguments.push(appArguments.join(','));
            } // Using Base64-encoded command, accepted by PowerShell, to allow special characters.


            options.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
            _context3.next = 49;
            break;

          case 31:
            if (!app) {
              _context3.next = 35;
              break;
            }

            command = app;
            _context3.next = 47;
            break;

          case 35:
            // When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
            isBundled = !__dirname || __dirname === '/'; // Check if local `xdg-open` exists and is executable.

            exeLocalXdgOpen = false;
            _context3.prev = 37;
            _context3.next = 40;
            return fs.access(localXdgOpenPath, fsConstants.X_OK);

          case 40:
            exeLocalXdgOpen = true;
            _context3.next = 45;
            break;

          case 43:
            _context3.prev = 43;
            _context3.t0 = _context3["catch"](37);

          case 45:
            useSystemXdgOpen = process.versions.electron || platform === 'android' || isBundled || !exeLocalXdgOpen;
            command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;

          case 47:
            if (appArguments.length > 0) {
              cliArguments.push.apply(cliArguments, _toConsumableArray(appArguments));
            }

            if (!options.wait) {
              // `xdg-open` will block the process unless stdio is ignored
              // and it's detached from the parent even if it's unref'd.
              childProcessOptions.stdio = 'ignore';
              childProcessOptions.detached = true;
            }

          case 49:
            if (options.target) {
              cliArguments.push(options.target);
            }

            if (platform === 'darwin' && appArguments.length > 0) {
              cliArguments.push.apply(cliArguments, ['--args'].concat(_toConsumableArray(appArguments)));
            }

            subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);

            if (!options.wait) {
              _context3.next = 54;
              break;
            }

            return _context3.abrupt("return", new Promise(function (resolve, reject) {
              subprocess.once('error', reject);
              subprocess.once('close', function (exitCode) {
                if (options.allowNonzeroExitCode && exitCode > 0) {
                  reject(new Error("Exited with code ".concat(exitCode)));
                  return;
                }

                resolve(subprocess);
              });
            }));

          case 54:
            subprocess.unref();
            return _context3.abrupt("return", subprocess);

          case 56:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[37, 43]]);
  }));

  return function baseOpen(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

var open = function open(target, options) {
  if (typeof target !== 'string') {
    throw new TypeError('Expected a `target`');
  }

  return baseOpen(_objectSpread(_objectSpread({}, options), {}, {
    target: target
  }));
};

var openApp = function openApp(name, options) {
  if (typeof name !== 'string') {
    throw new TypeError('Expected a `name`');
  }

  var _ref5 = options || {},
      _ref5$arguments = _ref5.arguments,
      appArguments = _ref5$arguments === void 0 ? [] : _ref5$arguments;

  if (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {
    throw new TypeError('Expected `appArguments` as Array type');
  }

  return baseOpen(_objectSpread(_objectSpread({}, options), {}, {
    app: {
      name: name,
      arguments: appArguments
    }
  }));
};

function detectArchBinary(binary) {
  if (typeof binary === 'string' || Array.isArray(binary)) {
    return binary;
  }

  var archBinary = binary[arch];

  if (!archBinary) {
    throw new Error("".concat(arch, " is not supported"));
  }

  return archBinary;
}

function detectPlatformBinary(_ref6, _ref7) {
  var platformBinary = _ref6[platform];
  var wsl = _ref7.wsl;

  if (wsl && isWsl) {
    return detectArchBinary(wsl);
  }

  if (!platformBinary) {
    throw new Error("".concat(platform, " is not supported"));
  }

  return detectArchBinary(platformBinary);
}

var apps = {};
defineLazyProperty(apps, 'chrome', function () {
  return detectPlatformBinary({
    darwin: 'google chrome',
    win32: 'chrome',
    linux: ['google-chrome', 'google-chrome-stable', 'chromium']
  }, {
    wsl: {
      ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
      x64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe']
    }
  });
});
defineLazyProperty(apps, 'firefox', function () {
  return detectPlatformBinary({
    darwin: 'firefox',
    win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe',
    linux: 'firefox'
  }, {
    wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'
  });
});
defineLazyProperty(apps, 'edge', function () {
  return detectPlatformBinary({
    darwin: 'microsoft edge',
    win32: 'msedge',
    linux: ['microsoft-edge', 'microsoft-edge-dev']
  }, {
    wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'
  });
});
open.apps = apps;
open.openApp = openApp;
module.exports = open;
        },
        map: {"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/setPrototypeOf":36,"@babel/runtime/helpers/asyncToGenerator":3,"path":-19260817,"child_process":-19260817,"fs":-19260817,"is-wsl":37,"is-docker":38,"define-lazy-prop":39}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/regenerator-runtime/runtime.js
      10: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  define(Gp, iteratorSymbol, function () {
    return this;
  });
  define(Gp, "toString", function () {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
(typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/construct.js
      11: {
        factory: (module, exports, require) => {
          var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeReflectConstruct = require("./isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./setPrototypeOf.js":36,"./isNativeReflectConstruct.js":40}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/typeof.js
      12: {
        factory: (module, exports, require) => {
          function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}

module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/defineProperty.js
      13: {
        factory: (module, exports, require) => {
          function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/classCallCheck.js
      14: {
        factory: (module, exports, require) => {
          function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/createClass.js
      15: {
        factory: (module, exports, require) => {
          function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/inherits.js
      16: {
        factory: (module, exports, require) => {
          var setPrototypeOf = require("./setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./setPrototypeOf.js":36}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
      17: {
        factory: (module, exports, require) => {
          var _typeof = require("./typeof.js")["default"];

var assertThisInitialized = require("./assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./typeof.js":12,"./assertThisInitialized.js":41}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/getPrototypeOf.js
      18: {
        factory: (module, exports, require) => {
          function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/utils.js
      19: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _typeof = require("@babel/runtime/helpers/typeof");

var toString = Object.prototype.toString;

var colors = require('ansi-colors');

var called = false;
var fns = [];
var complements = {
  'yellow': 'blue',
  'cyan': 'red',
  'green': 'magenta',
  'black': 'white',
  'blue': 'yellow',
  'red': 'cyan',
  'magenta': 'green',
  'white': 'black'
};

exports.longest = function (arr, prop) {
  return arr.reduce(function (a, v) {
    return Math.max(a, prop ? v[prop].length : v.length);
  }, 0);
};

exports.hasColor = function (str) {
  return !!str && colors.hasColor(str);
};

var isObject = exports.isObject = function (val) {
  return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
};

exports.nativeType = function (val) {
  return toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, '');
};

exports.isAsyncFn = function (val) {
  return exports.nativeType(val) === 'asyncfunction';
};

exports.isPrimitive = function (val) {
  return val != null && _typeof(val) !== 'object' && typeof val !== 'function';
};

exports.resolve = function (context, value) {
  if (typeof value === 'function') {
    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }

    return value.call.apply(value, [context].concat(rest));
  }

  return value;
};

exports.scrollDown = function () {
  var choices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return [].concat(_toConsumableArray(choices.slice(1)), [choices[0]]);
};

exports.scrollUp = function () {
  var choices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return [choices.pop()].concat(_toConsumableArray(choices));
};

exports.reorder = function () {
  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var res = arr.slice();
  res.sort(function (a, b) {
    if (a.index > b.index) return 1;
    if (a.index < b.index) return -1;
    return 0;
  });
  return res;
};

exports.swap = function (arr, index, pos) {
  var len = arr.length;
  var idx = pos === len ? 0 : pos < 0 ? len - 1 : pos;
  var choice = arr[index];
  arr[index] = arr[idx];
  arr[idx] = choice;
};

exports.width = function (stream) {
  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;
  var columns = stream && stream.columns ? stream.columns : fallback;

  if (stream && typeof stream.getWindowSize === 'function') {
    columns = stream.getWindowSize()[0];
  }

  if (process.platform === 'win32') {
    return columns - 1;
  }

  return columns;
};

exports.height = function (stream) {
  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
  var rows = stream && stream.rows ? stream.rows : fallback;

  if (stream && typeof stream.getWindowSize === 'function') {
    rows = stream.getWindowSize()[1];
  }

  return rows;
};

exports.wordWrap = function (str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!str) return str;

  if (typeof options === 'number') {
    options = {
      width: options
    };
  }

  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? '' : _options$indent,
      _options$newline = _options.newline,
      newline = _options$newline === void 0 ? '\n' + indent : _options$newline,
      _options$width = _options.width,
      width = _options$width === void 0 ? 80 : _options$width;
  var spaces = (newline + indent).match(/[^\S\n]/g) || [];
  width -= spaces.length;
  var source = ".{1,".concat(width, "}([\\s\\u200B]+|$)|[^\\s\\u200B]+?([\\s\\u200B]+|$)");
  var output = str.trim();
  var regex = new RegExp(source, 'g');
  var lines = output.match(regex) || [];
  lines = lines.map(function (line) {
    return line.replace(/\n$/, '');
  });
  if (options.padEnd) lines = lines.map(function (line) {
    return line.padEnd(width, ' ');
  });
  if (options.padStart) lines = lines.map(function (line) {
    return line.padStart(width, ' ');
  });
  return indent + lines.join(newline);
};

exports.unmute = function (color) {
  var name = color.stack.find(function (n) {
    return colors.keys.color.includes(n);
  });

  if (name) {
    return colors[name];
  }

  var bg = color.stack.find(function (n) {
    return n.slice(2) === 'bg';
  });

  if (bg) {
    return colors[name.slice(2)];
  }

  return function (str) {
    return str;
  };
};

exports.pascal = function (str) {
  return str ? str[0].toUpperCase() + str.slice(1) : '';
};

exports.inverse = function (color) {
  if (!color || !color.stack) return color;
  var name = color.stack.find(function (n) {
    return colors.keys.color.includes(n);
  });

  if (name) {
    var col = colors['bg' + exports.pascal(name)];
    return col ? col.black : color;
  }

  var bg = color.stack.find(function (n) {
    return n.slice(0, 2) === 'bg';
  });

  if (bg) {
    return colors[bg.slice(2).toLowerCase()] || color;
  }

  return colors.none;
};

exports.complement = function (color) {
  if (!color || !color.stack) return color;
  var name = color.stack.find(function (n) {
    return colors.keys.color.includes(n);
  });
  var bg = color.stack.find(function (n) {
    return n.slice(0, 2) === 'bg';
  });

  if (name && !bg) {
    return colors[complements[name] || name];
  }

  if (bg) {
    var lower = bg.slice(2).toLowerCase();
    var comp = complements[lower];
    if (!comp) return color;
    return colors['bg' + exports.pascal(comp)] || color;
  }

  return colors.none;
};

exports.meridiem = function (date) {
  var hours = date.getHours();
  var minutes = date.getMinutes();
  var ampm = hours >= 12 ? 'pm' : 'am';
  hours = hours % 12;
  var hrs = hours === 0 ? 12 : hours;
  var min = minutes < 10 ? '0' + minutes : minutes;
  return hrs + ':' + min + ' ' + ampm;
};
/**
 * Set a value on the given object.
 * @param {Object} obj
 * @param {String} prop
 * @param {any} value
 */


exports.set = function () {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var val = arguments.length > 2 ? arguments[2] : undefined;
  return prop.split('.').reduce(function (acc, k, i, arr) {
    var value = arr.length - 1 > i ? acc[k] || {} : val;
    if (!exports.isObject(value) && i < arr.length - 1) value = {};
    return acc[k] = value;
  }, obj);
};
/**
 * Get a value from the given object.
 * @param {Object} obj
 * @param {String} prop
 */


exports.get = function () {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var fallback = arguments.length > 2 ? arguments[2] : undefined;
  var value = obj[prop] == null ? prop.split('.').reduce(function (acc, k) {
    return acc && acc[k];
  }, obj) : obj[prop];
  return value == null ? fallback : value;
};

exports.mixin = function (target, b) {
  if (!isObject(target)) return b;
  if (!isObject(b)) return target;

  for (var _i = 0, _Object$keys = Object.keys(b); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var desc = Object.getOwnPropertyDescriptor(b, key);

    if (desc.hasOwnProperty('value')) {
      if (target.hasOwnProperty(key) && isObject(desc.value)) {
        var existing = Object.getOwnPropertyDescriptor(target, key);

        if (isObject(existing.value)) {
          target[key] = exports.merge({}, target[key], b[key]);
        } else {
          Reflect.defineProperty(target, key, desc);
        }
      } else {
        Reflect.defineProperty(target, key, desc);
      }
    } else {
      Reflect.defineProperty(target, key, desc);
    }
  }

  return target;
};

exports.merge = function () {
  var target = {};

  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  for (var _i2 = 0, _args = args; _i2 < _args.length; _i2++) {
    var ele = _args[_i2];
    exports.mixin(target, ele);
  }

  return target;
};

exports.mixinEmitter = function (obj, emitter) {
  var proto = emitter.constructor.prototype;

  for (var _i3 = 0, _Object$keys2 = Object.keys(proto); _i3 < _Object$keys2.length; _i3++) {
    var key = _Object$keys2[_i3];
    var val = proto[key];

    if (typeof val === 'function') {
      exports.define(obj, key, val.bind(emitter));
    } else {
      exports.define(obj, key, val);
    }
  }
};

exports.onExit = function (callback) {
  var onExit = function onExit(quit, code) {
    if (called) return;
    called = true;
    fns.forEach(function (fn) {
      return fn();
    });

    if (quit === true) {
      process.exit(128 + code);
    }
  };

  if (fns.length === 0) {
    process.once('SIGTERM', onExit.bind(null, true, 15));
    process.once('SIGINT', onExit.bind(null, true, 2));
    process.once('exit', onExit);
  }

  fns.push(callback);
};

exports.define = function (obj, key, value) {
  Reflect.defineProperty(obj, key, {
    value: value
  });
};

exports.defineExport = function (obj, key, fn) {
  var custom;
  Reflect.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    set: function set(val) {
      custom = val;
    },
    get: function get() {
      return custom ? custom() : fn();
    }
  });
};
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/typeof":12,"ansi-colors":42}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompt.js
      20: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _assertThisInitialized = require("@babel/runtime/helpers/assertThisInitialized");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Events = require('events');

var colors = require('ansi-colors');

var _keypress = require('./keypress');

var timer = require('./timer');

var State = require('./state');

var theme = require('./theme');

var utils = require('./utils');

var ansi = require('./ansi');
/**
 * Base class for creating a new Prompt.
 * @param {Object} `options` Question object.
 */


var Prompt = /*#__PURE__*/function (_Events) {
  _inherits(Prompt, _Events);

  var _super = _createSuper(Prompt);

  function Prompt() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Prompt);

    _this = _super.call(this);
    _this.name = options.name;
    _this.type = options.type;
    _this.options = options;
    theme(_assertThisInitialized(_this));
    timer(_assertThisInitialized(_this));
    _this.state = new State(_assertThisInitialized(_this));
    _this.initial = [options.initial, options["default"]].find(function (v) {
      return v != null;
    });
    _this.stdout = options.stdout || process.stdout;
    _this.stdin = options.stdin || process.stdin;
    _this.scale = options.scale || 1;
    _this.term = _this.options.term || process.env.TERM_PROGRAM;
    _this.margin = margin(_this.options.margin);

    _this.setMaxListeners(0);

    setOptions(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Prompt, [{
    key: "keypress",
    value: function () {
      var _keypress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input) {
        var event,
            key,
            fn,
            _args = arguments;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                event = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                this.keypressed = true;
                key = _keypress.action(input, _keypress(input, event), this.options.actions);
                this.state.keypress = key;
                this.emit('keypress', input, key);
                this.emit('state', this.state.clone());
                fn = this.options[key.action] || this[key.action] || this.dispatch;

                if (!(typeof fn === 'function')) {
                  _context.next = 11;
                  break;
                }

                _context.next = 10;
                return fn.call(this, input, key);

              case 10:
                return _context.abrupt("return", _context.sent);

              case 11:
                this.alert();

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function keypress(_x) {
        return _keypress2.apply(this, arguments);
      }

      return keypress;
    }()
  }, {
    key: "alert",
    value: function alert() {
      delete this.state.alert;

      if (this.options.show === false) {
        this.emit('alert');
      } else {
        this.stdout.write(ansi.code.beep);
      }
    }
  }, {
    key: "cursorHide",
    value: function cursorHide() {
      var _this2 = this;

      this.stdout.write(ansi.cursor.hide());
      utils.onExit(function () {
        return _this2.cursorShow();
      });
    }
  }, {
    key: "cursorShow",
    value: function cursorShow() {
      this.stdout.write(ansi.cursor.show());
    }
  }, {
    key: "write",
    value: function write(str) {
      if (!str) return;

      if (this.stdout && this.state.show !== false) {
        this.stdout.write(str);
      }

      this.state.buffer += str;
    }
  }, {
    key: "clear",
    value: function clear() {
      var lines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var buffer = this.state.buffer;
      this.state.buffer = '';
      if (!buffer && !lines || this.options.show === false) return;
      this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));
    }
  }, {
    key: "restore",
    value: function restore() {
      if (this.state.closed || this.options.show === false) return;

      var _this$sections = this.sections(),
          prompt = _this$sections.prompt,
          after = _this$sections.after,
          rest = _this$sections.rest;

      var cursor = this.cursor,
          _this$initial = this.initial,
          initial = _this$initial === void 0 ? '' : _this$initial,
          _this$input = this.input,
          input = _this$input === void 0 ? '' : _this$input,
          _this$value = this.value,
          value = _this$value === void 0 ? '' : _this$value;
      var size = this.state.size = rest.length;
      var state = {
        after: after,
        cursor: cursor,
        initial: initial,
        input: input,
        prompt: prompt,
        size: size,
        value: value
      };
      var codes = ansi.cursor.restore(state);

      if (codes) {
        this.stdout.write(codes);
      }
    }
  }, {
    key: "sections",
    value: function sections() {
      var _this$state = this.state,
          buffer = _this$state.buffer,
          input = _this$state.input,
          prompt = _this$state.prompt;
      prompt = colors.unstyle(prompt);
      var buf = colors.unstyle(buffer);
      var idx = buf.indexOf(prompt);
      var header = buf.slice(0, idx);
      var rest = buf.slice(idx);
      var lines = rest.split('\n');
      var first = lines[0];
      var last = lines[lines.length - 1];
      var promptLine = prompt + (input ? ' ' + input : '');
      var len = promptLine.length;
      var after = len < first.length ? first.slice(len + 1) : '';
      return {
        header: header,
        prompt: first,
        after: after,
        rest: lines.slice(1),
        last: last
      };
    }
  }, {
    key: "submit",
    value: function () {
      var _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var result, error;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.state.submitted = true;
                this.state.validating = true; // this will only be called when the prompt is directly submitted
                // without initializing, i.e. when the prompt is skipped, etc. Otherwize,
                // "options.onSubmit" is will be handled by the "initialize()" method.

                if (!this.options.onSubmit) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 5;
                return this.options.onSubmit.call(this, this.name, this.value, this);

              case 5:
                _context2.t0 = this.state.error;

                if (_context2.t0) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 9;
                return this.validate(this.value, this.state);

              case 9:
                _context2.t0 = _context2.sent;

              case 10:
                result = _context2.t0;

                if (!(result !== true)) {
                  _context2.next = 23;
                  break;
                }

                error = '\n' + this.symbols.pointer + ' ';

                if (typeof result === 'string') {
                  error += result.trim();
                } else {
                  error += 'Invalid input';
                }

                this.state.error = '\n' + this.styles.danger(error);
                this.state.submitted = false;
                _context2.next = 18;
                return this.render();

              case 18:
                _context2.next = 20;
                return this.alert();

              case 20:
                this.state.validating = false;
                this.state.error = void 0;
                return _context2.abrupt("return");

              case 23:
                this.state.validating = false;
                _context2.next = 26;
                return this.render();

              case 26:
                _context2.next = 28;
                return this.close();

              case 28:
                _context2.next = 30;
                return this.result(this.value);

              case 30:
                this.value = _context2.sent;
                this.emit('submit', this.value);

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function submit() {
        return _submit.apply(this, arguments);
      }

      return submit;
    }()
  }, {
    key: "cancel",
    value: function () {
      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(err) {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.state.cancelled = this.state.submitted = true;
                _context3.next = 3;
                return this.render();

              case 3:
                _context3.next = 5;
                return this.close();

              case 5:
                if (!(typeof this.options.onCancel === 'function')) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 8;
                return this.options.onCancel.call(this, this.name, this.value, this);

              case 8:
                _context3.t0 = this;
                _context3.next = 11;
                return this.error(err);

              case 11:
                _context3.t1 = _context3.sent;

                _context3.t0.emit.call(_context3.t0, 'cancel', _context3.t1);

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function cancel(_x2) {
        return _cancel.apply(this, arguments);
      }

      return cancel;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var sections, lines;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.state.closed = true;

                try {
                  sections = this.sections();
                  lines = Math.ceil(sections.prompt.length / this.width);

                  if (sections.rest) {
                    this.write(ansi.cursor.down(sections.rest.length));
                  }

                  this.write('\n'.repeat(lines));
                } catch (err) {
                  /* do nothing */
                }

                this.emit('close');

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "start",
    value: function start() {
      if (!this.stop && this.options.show !== false) {
        this.stop = _keypress.listen(this, this.keypress.bind(this));
        this.once('close', this.stop);
      }
    }
  }, {
    key: "skip",
    value: function () {
      var _skip = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.skipped = this.options.skip === true;

                if (!(typeof this.options.skip === 'function')) {
                  _context5.next = 5;
                  break;
                }

                _context5.next = 4;
                return this.options.skip.call(this, this.name, this.value);

              case 4:
                this.skipped = _context5.sent;

              case 5:
                return _context5.abrupt("return", this.skipped);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function skip() {
        return _skip.apply(this, arguments);
      }

      return skip;
    }()
  }, {
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
        var _this3 = this;

        var format, options, result, onSubmit, submit;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                format = this.format, options = this.options, result = this.result;

                this.format = function () {
                  return format.call(_this3, _this3.value);
                };

                this.result = function () {
                  return result.call(_this3, _this3.value);
                };

                if (!(typeof options.initial === 'function')) {
                  _context7.next = 7;
                  break;
                }

                _context7.next = 6;
                return options.initial.call(this, this);

              case 6:
                this.initial = _context7.sent;

              case 7:
                if (!(typeof options.onRun === 'function')) {
                  _context7.next = 10;
                  break;
                }

                _context7.next = 10;
                return options.onRun.call(this, this);

              case 10:
                // if "options.onSubmit" is defined, we wrap the "submit" method to guarantee
                // that "onSubmit" will always called first thing inside the submit
                // method, regardless of how it's handled in inheriting prompts.
                if (typeof options.onSubmit === 'function') {
                  onSubmit = options.onSubmit.bind(this);
                  submit = this.submit.bind(this);
                  delete this.options.onSubmit;
                  this.submit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return onSubmit(_this3.name, _this3.value, _this3);

                          case 2:
                            return _context6.abrupt("return", submit());

                          case 3:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));
                }

                _context7.next = 13;
                return this.start();

              case 13:
                _context7.next = 15;
                return this.render();

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function initialize() {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
  }, {
    key: "render",
    value: function render() {
      throw new Error('expected prompt to have a custom render method');
    }
  }, {
    key: "run",
    value: function run() {
      var _this4 = this;

      return new Promise( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(resolve, reject) {
          return _regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _this4.once('submit', resolve);

                  _this4.once('cancel', reject);

                  _context8.next = 4;
                  return _this4.skip();

                case 4:
                  if (!_context8.sent) {
                    _context8.next = 7;
                    break;
                  }

                  _this4.render = function () {};

                  return _context8.abrupt("return", _this4.submit());

                case 7:
                  _context8.next = 9;
                  return _this4.initialize();

                case 9:
                  _this4.emit('run');

                case 10:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }));

        return function (_x3, _x4) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "element",
    value: function () {
      var _element = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(name, choice, i) {
        var options, state, symbols, timers, timer, value, val, res;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                options = this.options, state = this.state, symbols = this.symbols, timers = this.timers;
                timer = timers && timers[name];
                state.timer = timer;
                value = options[name] || state[name] || symbols[name];

                if (!(choice && choice[name] != null)) {
                  _context9.next = 8;
                  break;
                }

                _context9.t0 = choice[name];
                _context9.next = 11;
                break;

              case 8:
                _context9.next = 10;
                return value;

              case 10:
                _context9.t0 = _context9.sent;

              case 11:
                val = _context9.t0;

                if (!(val === '')) {
                  _context9.next = 14;
                  break;
                }

                return _context9.abrupt("return", val);

              case 14:
                _context9.next = 16;
                return this.resolve(val, state, choice, i);

              case 16:
                res = _context9.sent;

                if (!(!res && choice && choice[name])) {
                  _context9.next = 19;
                  break;
                }

                return _context9.abrupt("return", this.resolve(value, state, choice, i));

              case 19:
                return _context9.abrupt("return", res);

              case 20:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function element(_x5, _x6, _x7) {
        return _element.apply(this, arguments);
      }

      return element;
    }()
  }, {
    key: "prefix",
    value: function () {
      var _prefix = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
        var element, timer, state, style;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.element('prefix');

              case 2:
                _context10.t0 = _context10.sent;

                if (_context10.t0) {
                  _context10.next = 5;
                  break;
                }

                _context10.t0 = this.symbols;

              case 5:
                element = _context10.t0;
                timer = this.timers && this.timers.prefix;
                state = this.state;
                state.timer = timer;
                if (utils.isObject(element)) element = element[state.status] || element.pending;

                if (utils.hasColor(element)) {
                  _context10.next = 13;
                  break;
                }

                style = this.styles[state.status] || this.styles.pending;
                return _context10.abrupt("return", style(element));

              case 13:
                return _context10.abrupt("return", element);

              case 14:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function prefix() {
        return _prefix.apply(this, arguments);
      }

      return prefix;
    }()
  }, {
    key: "message",
    value: function () {
      var _message = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        var message;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.element('message');

              case 2:
                message = _context11.sent;

                if (utils.hasColor(message)) {
                  _context11.next = 5;
                  break;
                }

                return _context11.abrupt("return", this.styles.strong(message));

              case 5:
                return _context11.abrupt("return", message);

              case 6:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function message() {
        return _message.apply(this, arguments);
      }

      return message;
    }()
  }, {
    key: "separator",
    value: function () {
      var _separator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {
        var element, timer, state, value, ele;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.element('separator');

              case 2:
                _context12.t0 = _context12.sent;

                if (_context12.t0) {
                  _context12.next = 5;
                  break;
                }

                _context12.t0 = this.symbols;

              case 5:
                element = _context12.t0;
                timer = this.timers && this.timers.separator;
                state = this.state;
                state.timer = timer;
                value = element[state.status] || element.pending || state.separator;
                _context12.next = 12;
                return this.resolve(value, state);

              case 12:
                ele = _context12.sent;
                if (utils.isObject(ele)) ele = ele[state.status] || ele.pending;

                if (utils.hasColor(ele)) {
                  _context12.next = 16;
                  break;
                }

                return _context12.abrupt("return", this.styles.muted(ele));

              case 16:
                return _context12.abrupt("return", ele);

              case 17:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function separator() {
        return _separator.apply(this, arguments);
      }

      return separator;
    }()
  }, {
    key: "pointer",
    value: function () {
      var _pointer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(choice, i) {
        var val, styles, focused, style, ele, styled;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.element('pointer', choice, i);

              case 2:
                val = _context13.sent;

                if (!(typeof val === 'string' && utils.hasColor(val))) {
                  _context13.next = 5;
                  break;
                }

                return _context13.abrupt("return", val);

              case 5:
                if (!val) {
                  _context13.next = 14;
                  break;
                }

                styles = this.styles;
                focused = this.index === i;
                style = focused ? styles.primary : function (val) {
                  return val;
                };
                _context13.next = 11;
                return this.resolve(val[focused ? 'on' : 'off'] || val, this.state);

              case 11:
                ele = _context13.sent;
                styled = !utils.hasColor(ele) ? style(ele) : ele;
                return _context13.abrupt("return", focused ? styled : ' '.repeat(ele.length));

              case 14:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function pointer(_x8, _x9) {
        return _pointer.apply(this, arguments);
      }

      return pointer;
    }()
  }, {
    key: "indicator",
    value: function () {
      var _indicator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(choice, i) {
        var val, styles, enabled, style, ele;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.element('indicator', choice, i);

              case 2:
                val = _context14.sent;

                if (!(typeof val === 'string' && utils.hasColor(val))) {
                  _context14.next = 5;
                  break;
                }

                return _context14.abrupt("return", val);

              case 5:
                if (!val) {
                  _context14.next = 11;
                  break;
                }

                styles = this.styles;
                enabled = choice.enabled === true;
                style = enabled ? styles.success : styles.dark;
                ele = val[enabled ? 'on' : 'off'] || val;
                return _context14.abrupt("return", !utils.hasColor(ele) ? style(ele) : ele);

              case 11:
                return _context14.abrupt("return", '');

              case 12:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function indicator(_x10, _x11) {
        return _indicator.apply(this, arguments);
      }

      return indicator;
    }()
  }, {
    key: "body",
    value: function body() {
      return null;
    }
  }, {
    key: "footer",
    value: function footer() {
      if (this.state.status === 'pending') {
        return this.element('footer');
      }
    }
  }, {
    key: "header",
    value: function header() {
      if (this.state.status === 'pending') {
        return this.element('header');
      }
    }
  }, {
    key: "hint",
    value: function () {
      var _hint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {
        var _hint2;

        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!(this.state.status === 'pending' && !this.isValue(this.state.input))) {
                  _context15.next = 7;
                  break;
                }

                _context15.next = 3;
                return this.element('hint');

              case 3:
                _hint2 = _context15.sent;

                if (utils.hasColor(_hint2)) {
                  _context15.next = 6;
                  break;
                }

                return _context15.abrupt("return", this.styles.muted(_hint2));

              case 6:
                return _context15.abrupt("return", _hint2);

              case 7:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function hint() {
        return _hint.apply(this, arguments);
      }

      return hint;
    }()
  }, {
    key: "error",
    value: function error(err) {
      return !this.state.submitted ? err || this.state.error : '';
    }
  }, {
    key: "format",
    value: function format(value) {
      return value;
    }
  }, {
    key: "result",
    value: function result(value) {
      return value;
    }
  }, {
    key: "validate",
    value: function validate(value) {
      if (this.options.required === true) {
        return this.isValue(value);
      }

      return true;
    }
  }, {
    key: "isValue",
    value: function isValue(value) {
      return value != null && value !== '';
    }
  }, {
    key: "resolve",
    value: function resolve(value) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return utils.resolve.apply(utils, [this, value].concat(args));
    }
  }, {
    key: "base",
    get: function get() {
      return Prompt.prototype;
    }
  }, {
    key: "style",
    get: function get() {
      return this.styles[this.state.status];
    }
  }, {
    key: "height",
    get: function get() {
      return this.options.rows || utils.height(this.stdout, 25);
    }
  }, {
    key: "width",
    get: function get() {
      return this.options.columns || utils.width(this.stdout, 80);
    }
  }, {
    key: "size",
    get: function get() {
      return {
        width: this.width,
        height: this.height
      };
    }
  }, {
    key: "cursor",
    get: function get() {
      return this.state.cursor;
    },
    set: function set(value) {
      this.state.cursor = value;
    }
  }, {
    key: "input",
    get: function get() {
      return this.state.input;
    },
    set: function set(value) {
      this.state.input = value;
    }
  }, {
    key: "value",
    get: function get() {
      var _this$state2 = this.state,
          input = _this$state2.input,
          value = _this$state2.value;
      var result = [value, input].find(this.isValue.bind(this));
      return this.isValue(result) ? result : this.initial;
    },
    set: function set(value) {
      this.state.value = value;
    }
  }], [{
    key: "prompt",
    get: function get() {
      var _this5 = this;

      return function (options) {
        return new _this5(options).run();
      };
    }
  }]);

  return Prompt;
}(Events);

function setOptions(prompt) {
  var isValidKey = function isValidKey(key) {
    return prompt[key] === void 0 || typeof prompt[key] === 'function';
  };

  var ignore = ['actions', 'choices', 'initial', 'margin', 'roles', 'styles', 'symbols', 'theme', 'timers', 'value'];
  var ignoreFn = ['body', 'footer', 'error', 'header', 'hint', 'indicator', 'message', 'prefix', 'separator', 'skip'];

  for (var _i = 0, _Object$keys = Object.keys(prompt.options); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (ignore.includes(key)) continue;
    if (/^on[A-Z]/.test(key)) continue;
    var option = prompt.options[key];

    if (typeof option === 'function' && isValidKey(key)) {
      if (!ignoreFn.includes(key)) {
        prompt[key] = option.bind(prompt);
      }
    } else if (typeof prompt[key] !== 'function') {
      prompt[key] = option;
    }
  }
}

function margin(value) {
  if (typeof value === 'number') {
    value = [value, value, value, value];
  }

  var arr = [].concat(value || []);

  var pad = function pad(i) {
    return i % 2 === 0 ? '\n' : ' ';
  };

  var res = [];

  for (var i = 0; i < 4; i++) {
    var _char = pad(i);

    if (arr[i]) {
      res.push(_char.repeat(arr[i]));
    } else {
      res.push('');
    }
  }

  return res;
}

module.exports = Prompt;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/assertThisInitialized":41,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"events":-19260817,"ansi-colors":42,"./keypress":43,"./timer":44,"./state":45,"./theme":46,"./utils":19,"./ansi":47}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/index.js
      21: {
        factory: (module, exports, require) => {
          'use strict';

var utils = require('../utils');

var define = function define(key, fn) {
  utils.defineExport(exports, key, fn);
  utils.defineExport(exports, key.toLowerCase(), fn);
};

define('AutoComplete', function () {
  return require('./autocomplete');
});
define('BasicAuth', function () {
  return require('./basicauth');
});
define('Confirm', function () {
  return require('./confirm');
});
define('Editable', function () {
  return require('./editable');
});
define('Form', function () {
  return require('./form');
});
define('Input', function () {
  return require('./input');
});
define('Invisible', function () {
  return require('./invisible');
});
define('List', function () {
  return require('./list');
});
define('MultiSelect', function () {
  return require('./multiselect');
});
define('Numeral', function () {
  return require('./numeral');
});
define('Password', function () {
  return require('./password');
});
define('Scale', function () {
  return require('./scale');
});
define('Select', function () {
  return require('./select');
});
define('Snippet', function () {
  return require('./snippet');
});
define('Sort', function () {
  return require('./sort');
});
define('Survey', function () {
  return require('./survey');
});
define('Text', function () {
  return require('./text');
});
define('Toggle', function () {
  return require('./toggle');
});
define('Quiz', function () {
  return require('./quiz');
});
        },
        map: {"../utils":19,"./autocomplete":48,"./basicauth":49,"./confirm":50,"./editable":51,"./form":52,"./input":53,"./invisible":54,"./list":55,"./multiselect":56,"./numeral":57,"./password":58,"./scale":59,"./select":60,"./snippet":61,"./sort":62,"./survey":63,"./text":64,"./toggle":65,"./quiz":66}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/types/index.js
      22: {
        factory: (module, exports, require) => {
          module.exports = {
  ArrayPrompt: require('./array'),
  AuthPrompt: require('./auth'),
  BooleanPrompt: require('./boolean'),
  NumberPrompt: require('./number'),
  StringPrompt: require('./string')
};
        },
        map: {"./array":67,"./auth":68,"./boolean":69,"./number":70,"./string":71}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/is-wsl/index.js
      23: {
        factory: (module, exports, require) => {
          'use strict';

var os = require('os');

var fs = require('fs');

var isDocker = require('is-docker');

var isWsl = function isWsl() {
  if (process.platform !== 'linux') {
    return false;
  }

  if (os.release().toLowerCase().includes('microsoft')) {
    if (isDocker()) {
      return false;
    }

    return true;
  }

  try {
    return fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ? !isDocker() : false;
  } catch (_) {
    return false;
  }
};

if (process.env.__IS_WSL_TEST__) {
  module.exports = isWsl;
} else {
  module.exports = isWsl();
}
        },
        map: {"os":-19260817,"fs":-19260817,"is-docker":38}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/lib/termux.js
      24: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var execa = require('execa');

var handler = function handler(error) {
  if (error.code === 'ENOENT') {
    throw new Error('Couldn\'t find the termux-api scripts. You can install them with: apt install termux-api');
  }

  throw error;
};

module.exports = {
  copy: function () {
    var _copy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return execa('termux-clipboard-set', options);

            case 3:
              _context.next = 8;
              break;

            case 5:
              _context.prev = 5;
              _context.t0 = _context["catch"](0);
              handler(_context.t0);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 5]]);
    }));

    function copy(_x) {
      return _copy.apply(this, arguments);
    }

    return copy;
  }(),
  paste: function () {
    var _paste = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return execa.stdout('termux-clipboard-get', options);

            case 3:
              return _context2.abrupt("return", _context2.sent);

            case 6:
              _context2.prev = 6;
              _context2.t0 = _context2["catch"](0);
              handler(_context2.t0);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[0, 6]]);
    }));

    function paste(_x2) {
      return _paste.apply(this, arguments);
    }

    return paste;
  }(),
  copySync: function copySync(options) {
    try {
      execa.sync('termux-clipboard-set', options);
    } catch (error) {
      handler(error);
    }
  },
  pasteSync: function pasteSync(options) {
    try {
      return execa.sync('termux-clipboard-get', options);
    } catch (error) {
      handler(error);
    }
  }
};
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"execa":72}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/lib/linux.js
      25: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var path = require('path');

var execa = require('execa');

var xsel = 'xsel';
var xselFallback = path.join(__dirname, '../fallbacks/linux/xsel');
var copyArguments = ['--clipboard', '--input'];
var pasteArguments = ['--clipboard', '--output'];

var makeError = function makeError(xselError, fallbackError) {
  var error;

  if (xselError.code === 'ENOENT') {
    error = new Error('Couldn\'t find the `xsel` binary and fallback didn\'t work. On Debian/Ubuntu you can install xsel with: sudo apt install xsel');
  } else {
    error = new Error('Both xsel and fallback failed');
    error.xselError = xselError;
  }

  error.fallbackError = fallbackError;
  return error;
};

var xselWithFallback = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(argumentList, options) {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return execa.stdout(xsel, argumentList, options);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](0);
            _context.prev = 8;
            _context.next = 11;
            return execa.stdout(xselFallback, argumentList, options);

          case 11:
            return _context.abrupt("return", _context.sent);

          case 14:
            _context.prev = 14;
            _context.t1 = _context["catch"](8);
            throw makeError(_context.t0, _context.t1);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 6], [8, 14]]);
  }));

  return function xselWithFallback(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var xselWithFallbackSync = function xselWithFallbackSync(argumentList, options) {
  try {
    return execa.sync(xsel, argumentList, options);
  } catch (xselError) {
    try {
      return execa.sync(xselFallback, argumentList, options);
    } catch (fallbackError) {
      throw makeError(xselError, fallbackError);
    }
  }
};

module.exports = {
  copy: function () {
    var _copy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return xselWithFallback(copyArguments, options);

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function copy(_x3) {
      return _copy.apply(this, arguments);
    }

    return copy;
  }(),
  copySync: function copySync(options) {
    xselWithFallbackSync(copyArguments, options);
  },
  paste: function paste(options) {
    return xselWithFallback(pasteArguments, options);
  },
  pasteSync: function pasteSync(options) {
    return xselWithFallbackSync(pasteArguments, options);
  }
};
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"path":-19260817,"execa":72}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/lib/macos.js
      26: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var execa = require('execa');

var env = _objectSpread(_objectSpread({}, process.env), {}, {
  LC_CTYPE: 'UTF-8'
});

module.exports = {
  copy: function () {
    var _copy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", execa('pbcopy', _objectSpread(_objectSpread({}, options), {}, {
                env: env
              })));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function copy(_x) {
      return _copy.apply(this, arguments);
    }

    return copy;
  }(),
  paste: function () {
    var _paste = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", execa.stdout('pbpaste', _objectSpread(_objectSpread({}, options), {}, {
                env: env
              })));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function paste(_x2) {
      return _paste.apply(this, arguments);
    }

    return paste;
  }(),
  copySync: function copySync(options) {
    return execa.sync('pbcopy', _objectSpread(_objectSpread({}, options), {}, {
      env: env
    }));
  },
  pasteSync: function pasteSync(options) {
    return execa.sync('pbpaste', _objectSpread(_objectSpread({}, options), {}, {
      env: env
    }));
  }
};
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/defineProperty":13,"execa":72}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/lib/windows.js
      27: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var path = require('path');

var execa = require('execa');

var arch = require('arch'); // Binaries from: https://github.com/sindresorhus/win-clipboard


var windowBinaryPath = arch() === 'x64' ? path.join(__dirname, '../fallbacks/windows/clipboard_x86_64.exe') : path.join(__dirname, '../fallbacks/windows/clipboard_i686.exe');
module.exports = {
  copy: function () {
    var _copy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", execa(windowBinaryPath, ['--copy'], options));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function copy(_x) {
      return _copy.apply(this, arguments);
    }

    return copy;
  }(),
  paste: function () {
    var _paste = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", execa.stdout(windowBinaryPath, ['--paste'], options));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function paste(_x2) {
      return _paste.apply(this, arguments);
    }

    return paste;
  }(),
  copySync: function copySync(options) {
    return execa.sync(windowBinaryPath, ['--copy'], options);
  },
  pasteSync: function pasteSync(options) {
    return execa.sync(windowBinaryPath, ['--paste'], options);
  }
};
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"path":-19260817,"execa":72,"arch":73}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/index.js
      28: {
        factory: (module, exports, require) => {
          'use strict';

var toAnsible = require('./generators/ansible.js');

var toDart = require('./generators/dart.js');

var toElixir = require('./generators/elixir.js');

var toBrowser = require('./generators/javascript/browser.js');

var toGo = require('./generators/go.js');

var toJsonString = require('./generators/json.js');

var toNodeFetch = require('./generators/javascript/node-fetch.js');

var toNodeRequest = require('./generators/javascript/node-request.js');

var toPhp = require('./generators/php.js');

var toPython = require('./generators/python.js');

var toR = require('./generators/r.js');

var toRust = require('./generators/rust');

var toStrest = require('./generators/strest.js');

var toMATLAB = require('./generators/matlab/matlab.js');

var toJava = require('./generators/java.js');

module.exports = {
  toAnsible: toAnsible,
  toBrowser: toBrowser,
  toDart: toDart,
  toGo: toGo,
  toJsonString: toJsonString,
  toNodeFetch: toNodeFetch,
  toNodeRequest: toNodeRequest,
  toPhp: toPhp,
  toPython: toPython,
  toElixir: toElixir,
  toR: toR,
  toRust: toRust,
  toStrest: toStrest,
  toMATLAB: toMATLAB,
  toJava: toJava
};
        },
        map: {"./generators/ansible.js":74,"./generators/dart.js":75,"./generators/elixir.js":76,"./generators/javascript/browser.js":77,"./generators/go.js":78,"./generators/json.js":79,"./generators/javascript/node-fetch.js":80,"./generators/javascript/node-request.js":81,"./generators/php.js":82,"./generators/python.js":83,"./generators/r.js":84,"./generators/rust":85,"./generators/strest.js":86,"./generators/matlab/matlab.js":87,"./generators/java.js":88}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/omit.js
      29: {
        factory: (module, exports, require) => {
          var arrayMap = require('./_arrayMap'),
    baseClone = require('./_baseClone'),
    baseUnset = require('./_baseUnset'),
    castPath = require('./_castPath'),
    copyObject = require('./_copyObject'),
    customOmitClone = require('./_customOmitClone'),
    flatRest = require('./_flatRest'),
    getAllKeysIn = require('./_getAllKeysIn');
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */

var omit = flatRest(function (object, paths) {
  var result = {};

  if (object == null) {
    return result;
  }

  var isDeep = false;
  paths = arrayMap(paths, function (path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);

  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }

  var length = paths.length;

  while (length--) {
    baseUnset(result, paths[length]);
  }

  return result;
});
module.exports = omit;
        },
        map: {"./_arrayMap":89,"./_baseClone":90,"./_baseUnset":91,"./_castPath":92,"./_copyObject":93,"./_customOmitClone":94,"./_flatRest":33,"./_getAllKeysIn":95}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/forEach.js
      30: {
        factory: (module, exports, require) => {
          var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    castFunction = require('./_castFunction'),
    isArray = require('./isArray');
/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */


function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;
        },
        map: {"./_arrayEach":96,"./_baseEach":97,"./_castFunction":98,"./isArray":99}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/qs/lib/index.js
      31: {
        factory: (module, exports, require) => {
          'use strict';

var stringify = require('./stringify');

var parse = require('./parse');

var formats = require('./formats');

module.exports = {
  formats: formats,
  parse: parse,
  stringify: stringify
};
        },
        map: {"./stringify":100,"./parse":101,"./formats":102}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_basePick.js
      32: {
        factory: (module, exports, require) => {
          var basePickBy = require('./_basePickBy'),
    hasIn = require('./hasIn');
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */


function basePick(object, paths) {
  return basePickBy(object, paths, function (value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;
        },
        map: {"./_basePickBy":103,"./hasIn":104}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_flatRest.js
      33: {
        factory: (module, exports, require) => {
          var flatten = require('./flatten'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */


function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;
        },
        map: {"./flatten":105,"./_overRest":106,"./_setToString":107}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/src/generator/utils.ts
      34: {
        factory: (module, exports, require) => {
          "use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertRecord = convertRecord;
exports.genApiName = genApiName;
exports.getUrlPath = getUrlPath;

var _url = require("url");

var _mapValues = _interopRequireDefault(require("lodash/mapValues"));

function genApiName(apiPath) {
  return new _url.URL(apiPath).pathname.replace(/\//g, '_');
}

function getUrlPath(path) {
  return new _url.URL(path).pathname;
}

var isMagicStr = function isMagicStr(s) {
  return s.startsWith('__MAGIC__');
};

var getInnerStr = function getInnerStr(s) {
  var _$exec;

  return ((_$exec = /^__MAGIC__(.*)/.exec(s)) === null || _$exec === void 0 ? void 0 : _$exec[1]) || s;
};

function convertRecord(record) {
  return (0, _mapValues["default"])(record, function (v) {
    if (typeof v === 'string') {
      var isFromQuery = isMagicStr(v); // 单层结构

      return {
        type: isFromQuery ? 'query' : 'static',
        value: getInnerStr(v)
      };
    } else {
      // 嵌套结构
      return {
        type: 'nested',
        value: convertRecord(v)
      };
    }
  });
}
        },
        map: {"@babel/runtime/helpers/interopRequireDefault":1,"url":-19260817,"lodash/mapValues":108}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/toConsumableArray.js
      35: {
        factory: (module, exports, require) => {
          var arrayWithoutHoles = require("./arrayWithoutHoles.js");

var iterableToArray = require("./iterableToArray.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableSpread = require("./nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./arrayWithoutHoles.js":109,"./iterableToArray.js":110,"./unsupportedIterableToArray.js":111,"./nonIterableSpread.js":112}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/setPrototypeOf.js
      36: {
        factory: (module, exports, require) => {
          function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/open/node_modules/is-wsl/index.js
      37: {
        factory: (module, exports, require) => {
          'use strict';

var os = require('os');

var fs = require('fs');

var isDocker = require('is-docker');

var isWsl = function isWsl() {
  if (process.platform !== 'linux') {
    return false;
  }

  if (os.release().toLowerCase().includes('microsoft')) {
    if (isDocker()) {
      return false;
    }

    return true;
  }

  try {
    return fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') ? !isDocker() : false;
  } catch (_) {
    return false;
  }
};

if (process.env.__IS_WSL_TEST__) {
  module.exports = isWsl;
} else {
  module.exports = isWsl();
}
        },
        map: {"os":-19260817,"fs":-19260817,"is-docker":38}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-docker/index.js
      38: {
        factory: (module, exports, require) => {
          'use strict';

var fs = require('fs');

var isDocker;

function hasDockerEnv() {
  try {
    fs.statSync('/.dockerenv');
    return true;
  } catch (_) {
    return false;
  }
}

function hasDockerCGroup() {
  try {
    return fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
  } catch (_) {
    return false;
  }
}

module.exports = function () {
  if (isDocker === undefined) {
    isDocker = hasDockerEnv() || hasDockerCGroup();
  }

  return isDocker;
};
        },
        map: {"fs":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/define-lazy-prop/index.js
      39: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (object, propertyName, fn) {
  var define = function define(value) {
    return Object.defineProperty(object, propertyName, {
      value: value,
      enumerable: true,
      writable: true
    });
  };

  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get: function get() {
      var result = fn();
      define(result);
      return result;
    },
    set: function set(value) {
      define(value);
    }
  });
  return object;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
      40: {
        factory: (module, exports, require) => {
          function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/assertThisInitialized.js
      41: {
        factory: (module, exports, require) => {
          function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/node_modules/ansi-colors/index.js
      42: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _typeof = require("@babel/runtime/helpers/typeof");

var isObject = function isObject(val) {
  return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
};

var identity = function identity(val) {
  return val;
};
/* eslint-disable no-control-regex */
// this is a modified version of https://github.com/chalk/ansi-regex (MIT License)


var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;

var create = function create() {
  var colors = {
    enabled: true,
    visible: true,
    styles: {},
    keys: {}
  };

  if ('FORCE_COLOR' in process.env) {
    colors.enabled = process.env.FORCE_COLOR !== '0';
  }

  var ansi = function ansi(style) {
    var open = style.open = "\x1B[".concat(style.codes[0], "m");
    var close = style.close = "\x1B[".concat(style.codes[1], "m");
    var regex = style.regex = new RegExp("\\u001b\\[".concat(style.codes[1], "m"), 'g');

    style.wrap = function (input, newline) {
      if (input.includes(close)) input = input.replace(regex, close + open);
      var output = open + input + close; // see https://github.com/chalk/chalk/pull/92, thanks to the
      // chalk contributors for this fix. However, we've confirmed that
      // this issue is also present in Windows terminals

      return newline ? output.replace(/\r*\n/g, "".concat(close, "$&").concat(open)) : output;
    };

    return style;
  };

  var wrap = function wrap(style, input, newline) {
    return typeof style === 'function' ? style(input) : style.wrap(input, newline);
  };

  var style = function style(input, stack) {
    if (input === '' || input == null) return '';
    if (colors.enabled === false) return input;
    if (colors.visible === false) return '';
    var str = '' + input;
    var nl = str.includes('\n');
    var n = stack.length;

    if (n > 0 && stack.includes('unstyle')) {
      stack = _toConsumableArray(new Set(['unstyle'].concat(_toConsumableArray(stack)))).reverse();
    }

    while (n-- > 0) {
      str = wrap(colors.styles[stack[n]], str, nl);
    }

    return str;
  };

  var define = function define(name, codes, type) {
    colors.styles[name] = ansi({
      name: name,
      codes: codes
    });
    var keys = colors.keys[type] || (colors.keys[type] = []);
    keys.push(name);
    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set: function set(value) {
        colors.alias(name, value);
      },
      get: function get() {
        var color = function color(input) {
          return style(input, color.stack);
        };

        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(name) : [name];
        return color;
      }
    });
  };

  define('reset', [0, 0], 'modifier');
  define('bold', [1, 22], 'modifier');
  define('dim', [2, 22], 'modifier');
  define('italic', [3, 23], 'modifier');
  define('underline', [4, 24], 'modifier');
  define('inverse', [7, 27], 'modifier');
  define('hidden', [8, 28], 'modifier');
  define('strikethrough', [9, 29], 'modifier');
  define('black', [30, 39], 'color');
  define('red', [31, 39], 'color');
  define('green', [32, 39], 'color');
  define('yellow', [33, 39], 'color');
  define('blue', [34, 39], 'color');
  define('magenta', [35, 39], 'color');
  define('cyan', [36, 39], 'color');
  define('white', [37, 39], 'color');
  define('gray', [90, 39], 'color');
  define('grey', [90, 39], 'color');
  define('bgBlack', [40, 49], 'bg');
  define('bgRed', [41, 49], 'bg');
  define('bgGreen', [42, 49], 'bg');
  define('bgYellow', [43, 49], 'bg');
  define('bgBlue', [44, 49], 'bg');
  define('bgMagenta', [45, 49], 'bg');
  define('bgCyan', [46, 49], 'bg');
  define('bgWhite', [47, 49], 'bg');
  define('blackBright', [90, 39], 'bright');
  define('redBright', [91, 39], 'bright');
  define('greenBright', [92, 39], 'bright');
  define('yellowBright', [93, 39], 'bright');
  define('blueBright', [94, 39], 'bright');
  define('magentaBright', [95, 39], 'bright');
  define('cyanBright', [96, 39], 'bright');
  define('whiteBright', [97, 39], 'bright');
  define('bgBlackBright', [100, 49], 'bgBright');
  define('bgRedBright', [101, 49], 'bgBright');
  define('bgGreenBright', [102, 49], 'bgBright');
  define('bgYellowBright', [103, 49], 'bgBright');
  define('bgBlueBright', [104, 49], 'bgBright');
  define('bgMagentaBright', [105, 49], 'bgBright');
  define('bgCyanBright', [106, 49], 'bgBright');
  define('bgWhiteBright', [107, 49], 'bgBright');
  colors.ansiRegex = ANSI_REGEX;

  colors.hasColor = colors.hasAnsi = function (str) {
    colors.ansiRegex.lastIndex = 0;
    return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);
  };

  colors.alias = function (name, color) {
    var fn = typeof color === 'string' ? colors[color] : color;

    if (typeof fn !== 'function') {
      throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
    }

    if (!fn.stack) {
      Reflect.defineProperty(fn, 'name', {
        value: name
      });
      colors.styles[name] = fn;
      fn.stack = [name];
    }

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set: function set(value) {
        colors.alias(name, value);
      },
      get: function get() {
        var color = function color(input) {
          return style(input, color.stack);
        };

        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
        return color;
      }
    });
  };

  colors.theme = function (custom) {
    if (!isObject(custom)) throw new TypeError('Expected theme to be an object');

    for (var _i = 0, _Object$keys = Object.keys(custom); _i < _Object$keys.length; _i++) {
      var name = _Object$keys[_i];
      colors.alias(name, custom[name]);
    }

    return colors;
  };

  colors.alias('unstyle', function (str) {
    if (typeof str === 'string' && str !== '') {
      colors.ansiRegex.lastIndex = 0;
      return str.replace(colors.ansiRegex, '');
    }

    return '';
  });
  colors.alias('noop', function (str) {
    return str;
  });
  colors.none = colors.clear = colors.noop;
  colors.stripColor = colors.unstyle;
  colors.symbols = require('./symbols');
  colors.define = define;
  return colors;
};

module.exports = create();
module.exports.create = create;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/typeof":12,"./symbols":113}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/keypress.js
      43: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var readline = require('readline');

var combos = require('./combos');
/* eslint-disable no-control-regex */


var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
var fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
var keyName = {
  /* xterm/gnome ESC O letter */
  'OP': 'f1',
  'OQ': 'f2',
  'OR': 'f3',
  'OS': 'f4',

  /* xterm/rxvt ESC [ number ~ */
  '[11~': 'f1',
  '[12~': 'f2',
  '[13~': 'f3',
  '[14~': 'f4',

  /* from Cygwin and used in libuv */
  '[[A': 'f1',
  '[[B': 'f2',
  '[[C': 'f3',
  '[[D': 'f4',
  '[[E': 'f5',

  /* common */
  '[15~': 'f5',
  '[17~': 'f6',
  '[18~': 'f7',
  '[19~': 'f8',
  '[20~': 'f9',
  '[21~': 'f10',
  '[23~': 'f11',
  '[24~': 'f12',

  /* xterm ESC [ letter */
  '[A': 'up',
  '[B': 'down',
  '[C': 'right',
  '[D': 'left',
  '[E': 'clear',
  '[F': 'end',
  '[H': 'home',

  /* xterm/gnome ESC O letter */
  'OA': 'up',
  'OB': 'down',
  'OC': 'right',
  'OD': 'left',
  'OE': 'clear',
  'OF': 'end',
  'OH': 'home',

  /* xterm/rxvt ESC [ number ~ */
  '[1~': 'home',
  '[2~': 'insert',
  '[3~': 'delete',
  '[4~': 'end',
  '[5~': 'pageup',
  '[6~': 'pagedown',

  /* putty */
  '[[5~': 'pageup',
  '[[6~': 'pagedown',

  /* rxvt */
  '[7~': 'home',
  '[8~': 'end',

  /* rxvt keys with modifiers */
  '[a': 'up',
  '[b': 'down',
  '[c': 'right',
  '[d': 'left',
  '[e': 'clear',
  '[2$': 'insert',
  '[3$': 'delete',
  '[5$': 'pageup',
  '[6$': 'pagedown',
  '[7$': 'home',
  '[8$': 'end',
  'Oa': 'up',
  'Ob': 'down',
  'Oc': 'right',
  'Od': 'left',
  'Oe': 'clear',
  '[2^': 'insert',
  '[3^': 'delete',
  '[5^': 'pageup',
  '[6^': 'pagedown',
  '[7^': 'home',
  '[8^': 'end',

  /* misc. */
  '[Z': 'tab'
};

function isShiftKey(code) {
  return ['[a', '[b', '[c', '[d', '[e', '[2$', '[3$', '[5$', '[6$', '[7$', '[8$', '[Z'].includes(code);
}

function isCtrlKey(code) {
  return ['Oa', 'Ob', 'Oc', 'Od', 'Oe', '[2^', '[3^', '[5^', '[6^', '[7^', '[8^'].includes(code);
}

var keypress = function keypress() {
  var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parts;

  var key = _objectSpread({
    name: event.name,
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    sequence: s,
    raw: s
  }, event);

  if (Buffer.isBuffer(s)) {
    if (s[0] > 127 && s[1] === void 0) {
      s[0] -= 128;
      s = '\x1b' + String(s);
    } else {
      s = String(s);
    }
  } else if (s !== void 0 && typeof s !== 'string') {
    s = String(s);
  } else if (!s) {
    s = key.sequence || '';
  }

  key.sequence = key.sequence || s || key.name;

  if (s === '\r') {
    // carriage return
    key.raw = void 0;
    key.name = 'return';
  } else if (s === '\n') {
    // enter, should have been called linefeed
    key.name = 'enter';
  } else if (s === '\t') {
    // tab
    key.name = 'tab';
  } else if (s === '\b' || s === '\x7f' || s === '\x1b\x7f' || s === '\x1b\b') {
    // backspace or ctrl+h
    key.name = 'backspace';
    key.meta = s.charAt(0) === '\x1b';
  } else if (s === '\x1b' || s === '\x1b\x1b') {
    // escape key
    key.name = 'escape';
    key.meta = s.length === 2;
  } else if (s === ' ' || s === '\x1b ') {
    key.name = 'space';
    key.meta = s.length === 2;
  } else if (s <= '\x1a') {
    // ctrl+letter
    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
    key.ctrl = true;
  } else if (s.length === 1 && s >= '0' && s <= '9') {
    // number
    key.name = 'number';
  } else if (s.length === 1 && s >= 'a' && s <= 'z') {
    // lowercase letter
    key.name = s;
  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
    // shift+letter
    key.name = s.toLowerCase();
    key.shift = true;
  } else if (parts = metaKeyCodeRe.exec(s)) {
    // meta+character key
    key.meta = true;
    key.shift = /^[A-Z]$/.test(parts[1]);
  } else if (parts = fnKeyRe.exec(s)) {
    var segs = _toConsumableArray(s);

    if (segs[0] === "\x1B" && segs[1] === "\x1B") {
      key.option = true;
    } // ansi escape sequence
    // reassemble the key code leaving out leading \x1b's,
    // the modifier key bitflag and any meaningless "1;" sequence


    var code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join('');
    var modifier = (parts[3] || parts[5] || 1) - 1; // Parse the key modifier

    key.ctrl = !!(modifier & 4);
    key.meta = !!(modifier & 10);
    key.shift = !!(modifier & 1);
    key.code = code;
    key.name = keyName[code];
    key.shift = isShiftKey(code) || key.shift;
    key.ctrl = isCtrlKey(code) || key.ctrl;
  }

  return key;
};

keypress.listen = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var onKeypress = arguments.length > 1 ? arguments[1] : undefined;
  var stdin = options.stdin;

  if (!stdin || stdin !== process.stdin && !stdin.isTTY) {
    throw new Error('Invalid stream passed');
  }

  var rl = readline.createInterface({
    terminal: true,
    input: stdin
  });
  readline.emitKeypressEvents(stdin, rl);

  var on = function on(buf, key) {
    return onKeypress(buf, keypress(buf, key), rl);
  };

  var isRaw = stdin.isRaw;
  if (stdin.isTTY) stdin.setRawMode(true);
  stdin.on('keypress', on);
  rl.resume();

  var off = function off() {
    if (stdin.isTTY) stdin.setRawMode(isRaw);
    stdin.removeListener('keypress', on);
    rl.pause();
    rl.close();
  };

  return off;
};

keypress.action = function (buf, key, customActions) {
  var obj = _objectSpread(_objectSpread({}, combos), customActions);

  if (key.ctrl) {
    key.action = obj.ctrl[key.name];
    return key;
  }

  if (key.option && obj.option) {
    key.action = obj.option[key.name];
    return key;
  }

  if (key.shift) {
    key.action = obj.shift[key.name];
    return key;
  }

  key.action = obj.keys[key.name];
  return key;
};

module.exports = keypress;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/defineProperty":13,"readline":-19260817,"./combos":114}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/timer.js
      44: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (prompt) {
  prompt.timers = prompt.timers || {};
  var timers = prompt.options.timers;
  if (!timers) return;

  for (var _i = 0, _Object$keys = Object.keys(timers); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var opts = timers[key];

    if (typeof opts === 'number') {
      opts = {
        interval: opts
      };
    }

    create(prompt, key, opts);
  }
};

function create(prompt, name) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var timer = prompt.timers[name] = {
    name: name,
    start: Date.now(),
    ms: 0,
    tick: 0
  };
  var ms = options.interval || 120;
  timer.frames = options.frames || [];
  timer.loading = true;
  var interval = setInterval(function () {
    timer.ms = Date.now() - timer.start;
    timer.tick++;
    prompt.render();
  }, ms);

  timer.stop = function () {
    timer.loading = false;
    clearInterval(interval);
  };

  Reflect.defineProperty(timer, 'interval', {
    value: interval
  });
  prompt.once('close', function () {
    return timer.stop();
  });
  return timer.stop;
}
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/state.js
      45: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var _require = require('./utils'),
    define = _require.define,
    width = _require.width;

var State = /*#__PURE__*/function () {
  function State(prompt) {
    _classCallCheck(this, State);

    var options = prompt.options;
    define(this, '_prompt', prompt);
    this.type = prompt.type;
    this.name = prompt.name;
    this.message = '';
    this.header = '';
    this.footer = '';
    this.error = '';
    this.hint = '';
    this.input = '';
    this.cursor = 0;
    this.index = 0;
    this.lines = 0;
    this.tick = 0;
    this.prompt = '';
    this.buffer = '';
    this.width = width(options.stdout || process.stdout);
    Object.assign(this, options);
    this.name = this.name || this.message;
    this.message = this.message || this.name;
    this.symbols = prompt.symbols;
    this.styles = prompt.styles;
    this.required = new Set();
    this.cancelled = false;
    this.submitted = false;
  }

  _createClass(State, [{
    key: "clone",
    value: function clone() {
      var state = _objectSpread({}, this);

      state.status = this.status;
      state.buffer = Buffer.from(state.buffer);
      delete state.clone;
      return state;
    }
  }, {
    key: "color",
    get: function get() {
      var styles = this.prompt.styles;
      if (this.cancelled) return styles.cancelled;
      if (this.submitted) return styles.submitted;
      var color = this._color || styles[this.status];
      return typeof color === 'function' ? color : styles.pending;
    },
    set: function set(val) {
      this._color = val;
    }
  }, {
    key: "loading",
    get: function get() {
      if (typeof this._loading === 'boolean') return this._loading;
      if (this.loadingChoices) return 'choices';
      return false;
    },
    set: function set(value) {
      this._loading = value;
    }
  }, {
    key: "status",
    get: function get() {
      if (this.cancelled) return 'cancelled';
      if (this.submitted) return 'submitted';
      return 'pending';
    }
  }]);

  return State;
}();

module.exports = State;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"./utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/theme.js
      46: {
        factory: (module, exports, require) => {
          'use strict';

var styles = require('./styles');

var symbols = require('./symbols');

var utils = require('./utils');

module.exports = function (prompt) {
  prompt.options = utils.merge({}, prompt.options.theme, prompt.options);
  prompt.symbols = symbols.merge(prompt.options);
  prompt.styles = styles.merge(prompt.options);
};
        },
        map: {"./styles":115,"./symbols":116,"./utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/ansi.js
      47: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var isTerm = process.env.TERM_PROGRAM === 'Apple_Terminal';

var colors = require('ansi-colors');

var utils = require('./utils');

var ansi = module.exports = exports;
var ESC = "\x1B[";
var BEL = "\x07";
var hidden = false;
var code = ansi.code = {
  bell: BEL,
  beep: BEL,
  beginning: "".concat(ESC, "G"),
  down: "".concat(ESC, "J"),
  esc: ESC,
  getPosition: "".concat(ESC, "6n"),
  hide: "".concat(ESC, "?25l"),
  line: "".concat(ESC, "2K"),
  lineEnd: "".concat(ESC, "K"),
  lineStart: "".concat(ESC, "1K"),
  restorePosition: ESC + (isTerm ? '8' : 'u'),
  savePosition: ESC + (isTerm ? '7' : 's'),
  screen: "".concat(ESC, "2J"),
  show: "".concat(ESC, "?25h"),
  up: "".concat(ESC, "1J")
};
var cursor = ansi.cursor = {
  get hidden() {
    return hidden;
  },

  hide: function hide() {
    hidden = true;
    return code.hide;
  },
  show: function show() {
    hidden = false;
    return code.show;
  },
  forward: function forward() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC).concat(count, "C");
  },
  backward: function backward() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC).concat(count, "D");
  },
  nextLine: function nextLine() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC, "E").repeat(count);
  },
  prevLine: function prevLine() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return "".concat(ESC, "F").repeat(count);
  },
  up: function up() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "A") : '';
  },
  down: function down() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "B") : '';
  },
  right: function right() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "C") : '';
  },
  left: function left() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return count ? "".concat(ESC).concat(count, "D") : '';
  },
  to: function to(x, y) {
    return y ? "".concat(ESC).concat(y + 1, ";").concat(x + 1, "H") : "".concat(ESC).concat(x + 1, "G");
  },
  move: function move() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var res = '';
    res += x < 0 ? cursor.left(-x) : x > 0 ? cursor.right(x) : '';
    res += y < 0 ? cursor.up(-y) : y > 0 ? cursor.down(y) : '';
    return res;
  },
  restore: function restore() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var after = state.after,
        cursor = state.cursor,
        initial = state.initial,
        input = state.input,
        prompt = state.prompt,
        size = state.size,
        value = state.value;
    initial = utils.isPrimitive(initial) ? String(initial) : '';
    input = utils.isPrimitive(input) ? String(input) : '';
    value = utils.isPrimitive(value) ? String(value) : '';

    if (size) {
      var codes = ansi.cursor.up(size) + ansi.cursor.to(prompt.length);
      var diff = input.length - cursor;

      if (diff > 0) {
        codes += ansi.cursor.left(diff);
      }

      return codes;
    }

    if (value || after) {
      var pos = !input && !!initial ? -initial.length : -input.length + cursor;
      if (after) pos -= after.length;

      if (input === '' && initial && !prompt.includes(initial)) {
        pos += initial.length;
      }

      return ansi.cursor.move(pos);
    }
  }
};
var erase = ansi.erase = {
  screen: code.screen,
  up: code.up,
  down: code.down,
  line: code.line,
  lineEnd: code.lineEnd,
  lineStart: code.lineStart,
  lines: function lines(n) {
    var str = '';

    for (var i = 0; i < n; i++) {
      str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : '');
    }

    if (n) str += ansi.code.beginning;
    return str;
  }
};

ansi.clear = function () {
  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.stdout.columns;
  if (!columns) return erase.line + cursor.to(0);

  var width = function width(str) {
    return _toConsumableArray(colors.unstyle(str)).length;
  };

  var lines = input.split(/\r?\n/);
  var rows = 0;

  var _iterator = _createForOfIteratorHelper(lines),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
};
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"ansi-colors":42,"./utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/autocomplete.js
      48: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Select = require('./select');

var highlight = function highlight(input, color) {
  var val = input.toLowerCase();
  return function (str) {
    var s = str.toLowerCase();
    var i = s.indexOf(val);
    var colored = color(str.slice(i, i + val.length));
    return i >= 0 ? str.slice(0, i) + colored + str.slice(i + val.length) : str;
  };
};

var AutoComplete = /*#__PURE__*/function (_Select) {
  _inherits(AutoComplete, _Select);

  var _super = _createSuper(AutoComplete);

  function AutoComplete(options) {
    var _this;

    _classCallCheck(this, AutoComplete);

    _this = _super.call(this, options);

    _this.cursorShow();

    return _this;
  }

  _createClass(AutoComplete, [{
    key: "moveCursor",
    value: function moveCursor(n) {
      this.state.cursor += n;
    }
  }, {
    key: "dispatch",
    value: function dispatch(ch) {
      return this.append(ch);
    }
  }, {
    key: "space",
    value: function space(ch) {
      return this.options.multiple ? _get(_getPrototypeOf(AutoComplete.prototype), "space", this).call(this, ch) : this.append(ch);
    }
  }, {
    key: "append",
    value: function append(ch) {
      var _this$state = this.state,
          cursor = _this$state.cursor,
          input = _this$state.input;
      this.input = input.slice(0, cursor) + ch + input.slice(cursor);
      this.moveCursor(1);
      return this.complete();
    }
  }, {
    key: "delete",
    value: function _delete() {
      var _this$state2 = this.state,
          cursor = _this$state2.cursor,
          input = _this$state2.input;
      if (!input) return this.alert();
      this.input = input.slice(0, cursor - 1) + input.slice(cursor);
      this.moveCursor(-1);
      return this.complete();
    }
  }, {
    key: "deleteForward",
    value: function deleteForward() {
      var _this$state3 = this.state,
          cursor = _this$state3.cursor,
          input = _this$state3.input;
      if (input[cursor] === void 0) return this.alert();
      this.input = "".concat(input).slice(0, cursor) + "".concat(input).slice(cursor + 1);
      return this.complete();
    }
  }, {
    key: "number",
    value: function number(ch) {
      return this.append(ch);
    }
  }, {
    key: "complete",
    value: function () {
      var _complete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.completing = true;
                _context.next = 3;
                return this.suggest(this.input, this.state._choices);

              case 3:
                this.choices = _context.sent;
                this.state.limit = void 0; // allow getter/setter to reset limit

                this.index = Math.min(Math.max(this.visible.length - 1, 0), this.index);
                _context.next = 8;
                return this.render();

              case 8:
                this.completing = false;

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function complete() {
        return _complete.apply(this, arguments);
      }

      return complete;
    }()
  }, {
    key: "suggest",
    value: function suggest() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.input;
      var choices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state._choices;

      if (typeof this.options.suggest === 'function') {
        return this.options.suggest.call(this, input, choices);
      }

      var str = input.toLowerCase();
      return choices.filter(function (ch) {
        return ch.message.toLowerCase().includes(str);
      });
    }
  }, {
    key: "pointer",
    value: function pointer() {
      return '';
    }
  }, {
    key: "format",
    value: function format() {
      var _this2 = this;

      if (!this.focused) return this.input;

      if (this.options.multiple && this.state.submitted) {
        return this.selected.map(function (ch) {
          return _this2.styles.primary(ch.message);
        }).join(', ');
      }

      if (this.state.submitted) {
        var value = this.value = this.input = this.focused.value;
        return this.styles.primary(value);
      }

      return this.input;
    }
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var style, color, choices;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this.state.status !== 'pending')) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", _get(_getPrototypeOf(AutoComplete.prototype), "render", this).call(this));

              case 2:
                style = this.options.highlight ? this.options.highlight.bind(this) : this.styles.placeholder;
                color = highlight(this.input, style);
                choices = this.choices;
                this.choices = choices.map(function (ch) {
                  return _objectSpread(_objectSpread({}, ch), {}, {
                    message: color(ch.message)
                  });
                });
                _context2.next = 8;
                return _get(_getPrototypeOf(AutoComplete.prototype), "render", this).call(this);

              case 8:
                this.choices = choices;

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }, {
    key: "submit",
    value: function submit() {
      if (this.options.multiple) {
        this.value = this.selected.map(function (ch) {
          return ch.name;
        });
      }

      return _get(_getPrototypeOf(AutoComplete.prototype), "submit", this).call(this);
    }
  }]);

  return AutoComplete;
}(Select);

module.exports = AutoComplete;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"./select":60}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/basicauth.js
      49: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AuthPrompt = require('../types/auth');

function defaultAuthenticate(value, state) {
  if (value.username === this.options.username && value.password === this.options.password) {
    return true;
  }

  return false;
}

var factory = function factory() {
  var authenticate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultAuthenticate;
  var choices = [{
    name: 'username',
    message: 'username'
  }, {
    name: 'password',
    message: 'password',
    format: function format(input) {
      if (this.options.showPassword) {
        return input;
      }

      var color = this.state.submitted ? this.styles.primary : this.styles.muted;
      return color(this.symbols.asterisk.repeat(input.length));
    }
  }];

  var BasicAuthPrompt = /*#__PURE__*/function (_AuthPrompt$create) {
    _inherits(BasicAuthPrompt, _AuthPrompt$create);

    var _super = _createSuper(BasicAuthPrompt);

    function BasicAuthPrompt(options) {
      _classCallCheck(this, BasicAuthPrompt);

      return _super.call(this, _objectSpread(_objectSpread({}, options), {}, {
        choices: choices
      }));
    }

    _createClass(BasicAuthPrompt, null, [{
      key: "create",
      value: function create(authenticate) {
        return factory(authenticate);
      }
    }]);

    return BasicAuthPrompt;
  }(AuthPrompt.create(authenticate));

  return BasicAuthPrompt;
};

module.exports = factory();
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/auth":68}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/confirm.js
      50: {
        factory: (module, exports, require) => {
          'use strict';

var _createClass = require("@babel/runtime/helpers/createClass");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BooleanPrompt = require('../types/boolean');

var ConfirmPrompt = /*#__PURE__*/function (_BooleanPrompt) {
  _inherits(ConfirmPrompt, _BooleanPrompt);

  var _super = _createSuper(ConfirmPrompt);

  function ConfirmPrompt(options) {
    var _this;

    _classCallCheck(this, ConfirmPrompt);

    _this = _super.call(this, options);
    _this["default"] = _this.options["default"] || (_this.initial ? '(Y/n)' : '(y/N)');
    return _this;
  }

  return _createClass(ConfirmPrompt);
}(BooleanPrompt);

module.exports = ConfirmPrompt;
        },
        map: {"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/boolean":69}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/editable.js
      51: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Select = require('./select');

var Form = require('./form');

var form = Form.prototype;

var Editable = /*#__PURE__*/function (_Select) {
  _inherits(Editable, _Select);

  var _super = _createSuper(Editable);

  function Editable(options) {
    var _this;

    _classCallCheck(this, Editable);

    _this = _super.call(this, _objectSpread(_objectSpread({}, options), {}, {
      multiple: true
    }));
    _this.align = [_this.options.align, 'left'].find(function (v) {
      return v != null;
    });
    _this.emptyError = '';
    _this.values = {};
    return _this;
  }

  _createClass(Editable, [{
    key: "dispatch",
    value: function dispatch(_char, key) {
      var choice = this.focused;
      var parent = choice.parent || {};

      if (!choice.editable && !parent.editable) {
        if (_char === 'a' || _char === 'i') return _get(_getPrototypeOf(Editable.prototype), _char, this).call(this);
      }

      return form.dispatch.call(this, _char, key);
    }
  }, {
    key: "append",
    value: function append(_char2, key) {
      return form.append.call(this, _char2, key);
    }
  }, {
    key: "delete",
    value: function _delete(_char3, key) {
      return form["delete"].call(this, _char3, key);
    }
  }, {
    key: "space",
    value: function space(_char4) {
      return this.focused.editable ? this.append(_char4) : _get(_getPrototypeOf(Editable.prototype), "space", this).call(this);
    }
  }, {
    key: "number",
    value: function number(_char5) {
      return this.focused.editable ? this.append(_char5) : _get(_getPrototypeOf(Editable.prototype), "number", this).call(this, _char5);
    }
  }, {
    key: "next",
    value: function next() {
      return this.focused.editable ? form.next.call(this) : _get(_getPrototypeOf(Editable.prototype), "next", this).call(this);
    }
  }, {
    key: "prev",
    value: function prev() {
      return this.focused.editable ? form.prev.call(this) : _get(_getPrototypeOf(Editable.prototype), "prev", this).call(this);
    }
  }, {
    key: "indicator",
    value: function () {
      var _indicator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(choice, i) {
        var symbol, value;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                symbol = choice.indicator || '';
                value = choice.editable ? symbol : _get(_getPrototypeOf(Editable.prototype), "indicator", this).call(this, choice, i);
                _context.next = 4;
                return this.resolve(value, this.state, choice, i);

              case 4:
                _context.t0 = _context.sent;

                if (_context.t0) {
                  _context.next = 7;
                  break;
                }

                _context.t0 = '';

              case 7:
                return _context.abrupt("return", _context.t0);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function indicator(_x, _x2) {
        return _indicator.apply(this, arguments);
      }

      return indicator;
    }()
  }, {
    key: "indent",
    value: function indent(choice) {
      return choice.role === 'heading' ? '' : choice.editable ? ' ' : '  ';
    }
  }, {
    key: "renderChoice",
    value: function () {
      var _renderChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(choice, i) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                choice.indent = '';

                if (!choice.editable) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", form.renderChoice.call(this, choice, i));

              case 3:
                return _context2.abrupt("return", _get(_getPrototypeOf(Editable.prototype), "renderChoice", this).call(this, choice, i));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function renderChoice(_x3, _x4) {
        return _renderChoice.apply(this, arguments);
      }

      return renderChoice;
    }()
  }, {
    key: "error",
    value: function error() {
      return '';
    }
  }, {
    key: "footer",
    value: function footer() {
      return this.state.error;
    }
  }, {
    key: "validate",
    value: function () {
      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var result, _iterator, _step, choice, val;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                result = true;
                _iterator = _createForOfIteratorHelper(this.choices);
                _context3.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context3.next = 19;
                  break;
                }

                choice = _step.value;

                if (!(typeof choice.validate !== 'function')) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("continue", 17);

              case 8:
                if (!(choice.role === 'heading')) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("continue", 17);

              case 10:
                val = choice.parent ? this.value[choice.parent.name] : this.value;

                if (choice.editable) {
                  val = choice.value === choice.name ? choice.initial || '' : choice.value;
                } else if (!this.isDisabled(choice)) {
                  val = choice.enabled === true;
                }

                _context3.next = 14;
                return choice.validate(val, this.state);

              case 14:
                result = _context3.sent;

                if (!(result !== true)) {
                  _context3.next = 17;
                  break;
                }

                return _context3.abrupt("break", 19);

              case 17:
                _context3.next = 4;
                break;

              case 19:
                _context3.next = 24;
                break;

              case 21:
                _context3.prev = 21;
                _context3.t0 = _context3["catch"](2);

                _iterator.e(_context3.t0);

              case 24:
                _context3.prev = 24;

                _iterator.f();

                return _context3.finish(24);

              case 27:
                if (result !== true) {
                  this.state.error = typeof result === 'string' ? result : 'Invalid Input';
                }

                return _context3.abrupt("return", result);

              case 29:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 21, 24, 27]]);
      }));

      function validate() {
        return _validate.apply(this, arguments);
      }

      return validate;
    }()
  }, {
    key: "submit",
    value: function submit() {
      if (this.focused.newChoice === true) return _get(_getPrototypeOf(Editable.prototype), "submit", this).call(this);

      if (this.choices.some(function (ch) {
        return ch.newChoice;
      })) {
        return this.alert();
      }

      this.value = {};

      var _iterator2 = _createForOfIteratorHelper(this.choices),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var choice = _step2.value;
          var val = choice.parent ? this.value[choice.parent.name] : this.value;

          if (choice.role === 'heading') {
            this.value[choice.name] = {};
            continue;
          }

          if (choice.editable) {
            val[choice.name] = choice.value === choice.name ? choice.initial || '' : choice.value;
          } else if (!this.isDisabled(choice)) {
            val[choice.name] = choice.enabled === true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return this.base.submit.call(this);
    }
  }]);

  return Editable;
}(Select);

module.exports = Editable;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"./select":60,"./form":52}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/form.js
      52: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var colors = require('ansi-colors');

var SelectPrompt = require('./select');

var placeholder = require('../placeholder');

var FormPrompt = /*#__PURE__*/function (_SelectPrompt) {
  _inherits(FormPrompt, _SelectPrompt);

  var _super = _createSuper(FormPrompt);

  function FormPrompt(options) {
    var _this;

    _classCallCheck(this, FormPrompt);

    _this = _super.call(this, _objectSpread(_objectSpread({}, options), {}, {
      multiple: true
    }));
    _this.type = 'form';
    _this.initial = _this.options.initial;
    _this.align = [_this.options.align, 'right'].find(function (v) {
      return v != null;
    });
    _this.emptyError = '';
    _this.values = {};
    return _this;
  }

  _createClass(FormPrompt, [{
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(first) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _get(_getPrototypeOf(FormPrompt.prototype), "reset", this).call(this);

              case 2:
                if (first === true) this._index = this.index;
                this.index = this._index;
                this.values = {};
                this.choices.forEach(function (choice) {
                  return choice.reset && choice.reset();
                });
                return _context.abrupt("return", this.render());

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function reset(_x) {
        return _reset.apply(this, arguments);
      }

      return reset;
    }()
  }, {
    key: "dispatch",
    value: function dispatch(_char) {
      return !!_char && this.append(_char);
    }
  }, {
    key: "append",
    value: function append(_char2) {
      var choice = this.focused;
      if (!choice) return this.alert();
      var cursor = choice.cursor,
          input = choice.input;
      choice.value = choice.input = input.slice(0, cursor) + _char2 + input.slice(cursor);
      choice.cursor++;
      return this.render();
    }
  }, {
    key: "delete",
    value: function _delete() {
      var choice = this.focused;
      if (!choice || choice.cursor <= 0) return this.alert();
      var cursor = choice.cursor,
          input = choice.input;
      choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);
      choice.cursor--;
      return this.render();
    }
  }, {
    key: "deleteForward",
    value: function deleteForward() {
      var choice = this.focused;
      if (!choice) return this.alert();
      var cursor = choice.cursor,
          input = choice.input;
      if (input[cursor] === void 0) return this.alert();
      var str = "".concat(input).slice(0, cursor) + "".concat(input).slice(cursor + 1);
      choice.value = choice.input = str;
      return this.render();
    }
  }, {
    key: "right",
    value: function right() {
      var choice = this.focused;
      if (!choice) return this.alert();
      if (choice.cursor >= choice.input.length) return this.alert();
      choice.cursor++;
      return this.render();
    }
  }, {
    key: "left",
    value: function left() {
      var choice = this.focused;
      if (!choice) return this.alert();
      if (choice.cursor <= 0) return this.alert();
      choice.cursor--;
      return this.render();
    }
  }, {
    key: "space",
    value: function space(ch, key) {
      return this.dispatch(ch, key);
    }
  }, {
    key: "number",
    value: function number(ch, key) {
      return this.dispatch(ch, key);
    }
  }, {
    key: "next",
    value: function next() {
      var ch = this.focused;
      if (!ch) return this.alert();
      var initial = ch.initial,
          input = ch.input;

      if (initial && initial.startsWith(input) && input !== initial) {
        ch.value = ch.input = initial;
        ch.cursor = ch.value.length;
        return this.render();
      }

      return _get(_getPrototypeOf(FormPrompt.prototype), "next", this).call(this);
    }
  }, {
    key: "prev",
    value: function prev() {
      var ch = this.focused;
      if (!ch) return this.alert();
      if (ch.cursor === 0) return _get(_getPrototypeOf(FormPrompt.prototype), "prev", this).call(this);
      ch.value = ch.input = '';
      ch.cursor = 0;
      return this.render();
    }
  }, {
    key: "separator",
    value: function separator() {
      return '';
    }
  }, {
    key: "format",
    value: function format(value) {
      return !this.state.submitted ? _get(_getPrototypeOf(FormPrompt.prototype), "format", this).call(this, value) : '';
    }
  }, {
    key: "pointer",
    value: function pointer() {
      return '';
    }
  }, {
    key: "indicator",
    value: function indicator(choice) {
      return choice.input ? '⦿' : '⊙';
    }
  }, {
    key: "choiceSeparator",
    value: function () {
      var _choiceSeparator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(choice, i) {
        var sep;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.resolve(choice.separator, this.state, choice, i);

              case 2:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 5;
                  break;
                }

                _context2.t0 = ':';

              case 5:
                sep = _context2.t0;
                return _context2.abrupt("return", sep ? ' ' + this.styles.disabled(sep) : '');

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function choiceSeparator(_x2, _x3) {
        return _choiceSeparator.apply(this, arguments);
      }

      return choiceSeparator;
    }()
  }, {
    key: "renderChoice",
    value: function () {
      var _renderChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(choice, i) {
        var state, styles, cursor, _choice$initial, initial, name, hint, _choice$input, input, muted, submitted, primary, danger, help, focused, validate, sep, msg, value, color, style, indicator, indent, line, _color, options;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.onChoice(choice, i);

              case 2:
                state = this.state, styles = this.styles;
                cursor = choice.cursor, _choice$initial = choice.initial, initial = _choice$initial === void 0 ? '' : _choice$initial, name = choice.name, hint = choice.hint, _choice$input = choice.input, input = _choice$input === void 0 ? '' : _choice$input;
                muted = styles.muted, submitted = styles.submitted, primary = styles.primary, danger = styles.danger;
                help = hint;
                focused = this.index === i;

                validate = choice.validate || function () {
                  return true;
                };

                _context3.next = 10;
                return this.choiceSeparator(choice, i);

              case 10:
                sep = _context3.sent;
                msg = choice.message;
                if (this.align === 'right') msg = msg.padStart(this.longest + 1, ' ');
                if (this.align === 'left') msg = msg.padEnd(this.longest + 1, ' '); // re-populate the form values (answers) object

                value = this.values[name] = input || initial;
                color = input ? 'success' : 'dark';
                _context3.next = 18;
                return validate.call(choice, value, this.state);

              case 18:
                _context3.t0 = _context3.sent;

                if (!(_context3.t0 !== true)) {
                  _context3.next = 21;
                  break;
                }

                color = 'danger';

              case 21:
                style = styles[color];
                _context3.t1 = style;
                _context3.next = 25;
                return this.indicator(choice, i);

              case 25:
                _context3.t2 = _context3.sent;
                _context3.t3 = (0, _context3.t1)(_context3.t2);
                _context3.t4 = choice.pad || '';
                indicator = _context3.t3 + _context3.t4;
                indent = this.indent(choice);

                line = function line() {
                  return [indent, indicator, msg + sep, input, help].filter(Boolean).join(' ');
                };

                if (!state.submitted) {
                  _context3.next = 36;
                  break;
                }

                msg = colors.unstyle(msg);
                input = submitted(input);
                help = '';
                return _context3.abrupt("return", line());

              case 36:
                if (!choice.format) {
                  _context3.next = 42;
                  break;
                }

                _context3.next = 39;
                return choice.format.call(this, input, choice, i);

              case 39:
                input = _context3.sent;
                _context3.next = 45;
                break;

              case 42:
                _color = this.styles.muted;
                options = {
                  input: input,
                  initial: initial,
                  pos: cursor,
                  showCursor: focused,
                  color: _color
                };
                input = placeholder(this, options);

              case 45:
                if (!this.isValue(input)) {
                  input = this.styles.muted(this.symbols.ellipsis);
                }

                if (!choice.result) {
                  _context3.next = 50;
                  break;
                }

                _context3.next = 49;
                return choice.result.call(this, value, choice, i);

              case 49:
                this.values[name] = _context3.sent;

              case 50:
                if (focused) {
                  msg = primary(msg);
                }

                if (choice.error) {
                  input += (input ? ' ' : '') + danger(choice.error.trim());
                } else if (choice.hint) {
                  input += (input ? ' ' : '') + muted(choice.hint.trim());
                }

                return _context3.abrupt("return", line());

              case 53:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function renderChoice(_x4, _x5) {
        return _renderChoice.apply(this, arguments);
      }

      return renderChoice;
    }()
  }, {
    key: "submit",
    value: function () {
      var _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.value = this.values;
                return _context4.abrupt("return", _get(_getPrototypeOf(FormPrompt.prototype), "base", this).submit.call(this));

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function submit() {
        return _submit.apply(this, arguments);
      }

      return submit;
    }()
  }]);

  return FormPrompt;
}(SelectPrompt);

module.exports = FormPrompt;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"ansi-colors":42,"./select":60,"../placeholder":118}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/input.js
      53: {
        factory: (module, exports, require) => {
          'use strict';

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Prompt = require('../types/string');

var completer = require('../completer');

var Input = /*#__PURE__*/function (_Prompt) {
  _inherits(Input, _Prompt);

  var _super = _createSuper(Input);

  function Input(options) {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this, options);
    var history = _this.options.history;

    if (history && history.store) {
      var initial = history.values || _this.initial;
      _this.autosave = !!history.autosave;
      _this.store = history.store;
      _this.data = _this.store.get('values') || {
        past: [],
        present: initial
      };
      _this.initial = _this.data.present || _this.data.past[_this.data.past.length - 1];
    }

    return _this;
  }

  _createClass(Input, [{
    key: "completion",
    value: function completion(action) {
      if (!this.store) return this.alert();
      this.data = completer(action, this.data, this.input);
      if (!this.data.present) return this.alert();
      this.input = this.data.present;
      this.cursor = this.input.length;
      return this.render();
    }
  }, {
    key: "altUp",
    value: function altUp() {
      return this.completion('prev');
    }
  }, {
    key: "altDown",
    value: function altDown() {
      return this.completion('next');
    }
  }, {
    key: "prev",
    value: function prev() {
      this.save();
      return _get(_getPrototypeOf(Input.prototype), "prev", this).call(this);
    }
  }, {
    key: "save",
    value: function save() {
      if (!this.store) return;
      this.data = completer('save', this.data, this.input);
      this.store.set('values', this.data);
    }
  }, {
    key: "submit",
    value: function submit() {
      if (this.store && this.autosave === true) {
        this.save();
      }

      return _get(_getPrototypeOf(Input.prototype), "submit", this).call(this);
    }
  }]);

  return Input;
}(Prompt);

module.exports = Input;
        },
        map: {"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/string":71,"../completer":119}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/invisible.js
      54: {
        factory: (module, exports, require) => {
          'use strict';

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var StringPrompt = require('../types/string');

var InvisiblePrompt = /*#__PURE__*/function (_StringPrompt) {
  _inherits(InvisiblePrompt, _StringPrompt);

  var _super = _createSuper(InvisiblePrompt);

  function InvisiblePrompt() {
    _classCallCheck(this, InvisiblePrompt);

    return _super.apply(this, arguments);
  }

  _createClass(InvisiblePrompt, [{
    key: "format",
    value: function format() {
      return '';
    }
  }]);

  return InvisiblePrompt;
}(StringPrompt);

module.exports = InvisiblePrompt;
        },
        map: {"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/string":71}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/list.js
      55: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var StringPrompt = require('../types/string');

var ListPrompt = /*#__PURE__*/function (_StringPrompt) {
  _inherits(ListPrompt, _StringPrompt);

  var _super = _createSuper(ListPrompt);

  function ListPrompt() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ListPrompt);

    _this = _super.call(this, options);
    _this.sep = _this.options.separator || /, */;
    _this.initial = options.initial || '';
    return _this;
  }

  _createClass(ListPrompt, [{
    key: "split",
    value: function split() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;
      return input ? String(input).split(this.sep) : [];
    }
  }, {
    key: "format",
    value: function format() {
      var style = this.state.submitted ? this.styles.primary : function (val) {
        return val;
      };
      return this.list.map(style).join(', ');
    }
  }, {
    key: "submit",
    value: function () {
      var _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {
        var result;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = this.state.error;

                if (_context.t0) {
                  _context.next = 5;
                  break;
                }

                _context.next = 4;
                return this.validate(this.list, this.state);

              case 4:
                _context.t0 = _context.sent;

              case 5:
                result = _context.t0;

                if (!(result !== true)) {
                  _context.next = 9;
                  break;
                }

                this.state.error = result;
                return _context.abrupt("return", _get(_getPrototypeOf(ListPrompt.prototype), "submit", this).call(this));

              case 9:
                this.value = this.list;
                return _context.abrupt("return", _get(_getPrototypeOf(ListPrompt.prototype), "submit", this).call(this));

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function submit(_x) {
        return _submit.apply(this, arguments);
      }

      return submit;
    }()
  }, {
    key: "list",
    get: function get() {
      return this.split();
    }
  }]);

  return ListPrompt;
}(StringPrompt);

module.exports = ListPrompt;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/string":71}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/multiselect.js
      56: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _createClass = require("@babel/runtime/helpers/createClass");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Select = require('./select');

var MultiSelect = /*#__PURE__*/function (_Select) {
  _inherits(MultiSelect, _Select);

  var _super = _createSuper(MultiSelect);

  function MultiSelect(options) {
    _classCallCheck(this, MultiSelect);

    return _super.call(this, _objectSpread(_objectSpread({}, options), {}, {
      multiple: true
    }));
  }

  return _createClass(MultiSelect);
}(Select);

module.exports = MultiSelect;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"./select":60}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/numeral.js
      57: {
        factory: (module, exports, require) => {
          module.exports = require('../types/number');
        },
        map: {"../types/number":70}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/password.js
      58: {
        factory: (module, exports, require) => {
          'use strict';

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var StringPrompt = require('../types/string');

var PasswordPrompt = /*#__PURE__*/function (_StringPrompt) {
  _inherits(PasswordPrompt, _StringPrompt);

  var _super = _createSuper(PasswordPrompt);

  function PasswordPrompt(options) {
    var _this;

    _classCallCheck(this, PasswordPrompt);

    _this = _super.call(this, options);

    _this.cursorShow();

    return _this;
  }

  _createClass(PasswordPrompt, [{
    key: "format",
    value: function format() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.input;
      if (!this.keypressed) return '';
      var color = this.state.submitted ? this.styles.primary : this.styles.muted;
      return color(this.symbols.asterisk.repeat(input.length));
    }
  }]);

  return PasswordPrompt;
}(StringPrompt);

module.exports = PasswordPrompt;
        },
        map: {"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/string":71}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/scale.js
      59: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var colors = require('ansi-colors');

var ArrayPrompt = require('../types/array');

var utils = require('../utils');

var LikertScale = /*#__PURE__*/function (_ArrayPrompt) {
  _inherits(LikertScale, _ArrayPrompt);

  var _super = _createSuper(LikertScale);

  function LikertScale() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, LikertScale);

    _this = _super.call(this, options);
    _this.widths = [].concat(options.messageWidth || 50);
    _this.align = [].concat(options.align || 'left');
    _this.linebreak = options.linebreak || false;
    _this.edgeLength = options.edgeLength || 3;
    _this.newline = options.newline || '\n   ';
    var start = options.startNumber || 1;

    if (typeof _this.scale === 'number') {
      _this.scaleKey = false;
      _this.scale = Array(_this.scale).fill(0).map(function (v, i) {
        return {
          name: i + start
        };
      });
    }

    return _this;
  }

  _createClass(LikertScale, [{
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.tableized = false;
                _context.next = 3;
                return _get(_getPrototypeOf(LikertScale.prototype), "reset", this).call(this);

              case 3:
                return _context.abrupt("return", this.render());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function reset() {
        return _reset.apply(this, arguments);
      }

      return reset;
    }()
  }, {
    key: "tableize",
    value: function tableize() {
      if (this.tableized === true) return;
      this.tableized = true;
      var longest = 0;

      var _iterator = _createForOfIteratorHelper(this.choices),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ch = _step.value;
          longest = Math.max(longest, ch.message.length);
          ch.scaleIndex = ch.initial || 2;
          ch.scale = [];

          for (var i = 0; i < this.scale.length; i++) {
            ch.scale.push({
              index: i
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.widths[0] = Math.min(this.widths[0], longest + 3);
    }
  }, {
    key: "dispatch",
    value: function () {
      var _dispatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(s, key) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.multiple) {
                  _context2.next = 11;
                  break;
                }

                if (!this[key.name]) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 4;
                return this[key.name](s, key);

              case 4:
                _context2.t0 = _context2.sent;
                _context2.next = 10;
                break;

              case 7:
                _context2.next = 9;
                return _get(_getPrototypeOf(LikertScale.prototype), "dispatch", this).call(this, s, key);

              case 9:
                _context2.t0 = _context2.sent;

              case 10:
                return _context2.abrupt("return", _context2.t0);

              case 11:
                this.alert();

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function dispatch(_x, _x2) {
        return _dispatch.apply(this, arguments);
      }

      return dispatch;
    }()
  }, {
    key: "heading",
    value: function heading(msg, item, i) {
      return this.styles.strong(msg);
    }
  }, {
    key: "separator",
    value: function separator() {
      return this.styles.muted(this.symbols.ellipsis);
    }
  }, {
    key: "right",
    value: function right() {
      var choice = this.focused;
      if (choice.scaleIndex >= this.scale.length - 1) return this.alert();
      choice.scaleIndex++;
      return this.render();
    }
  }, {
    key: "left",
    value: function left() {
      var choice = this.focused;
      if (choice.scaleIndex <= 0) return this.alert();
      choice.scaleIndex--;
      return this.render();
    }
  }, {
    key: "indent",
    value: function indent() {
      return '';
    }
  }, {
    key: "format",
    value: function format() {
      var _this2 = this;

      if (this.state.submitted) {
        var values = this.choices.map(function (ch) {
          return _this2.styles.info(ch.index);
        });
        return values.join(', ');
      }

      return '';
    }
  }, {
    key: "pointer",
    value: function pointer() {
      return '';
    }
    /**
     * Render the scale "Key". Something like:
     * @return {String}
     */

  }, {
    key: "renderScaleKey",
    value: function renderScaleKey() {
      var _this3 = this;

      if (this.scaleKey === false) return '';
      if (this.state.submitted) return '';
      var scale = this.scale.map(function (item) {
        return "   ".concat(item.name, " - ").concat(item.message);
      });
      var key = [''].concat(_toConsumableArray(scale)).map(function (item) {
        return _this3.styles.muted(item);
      });
      return key.join('\n');
    }
    /**
     * Render the heading row for the scale.
     * @return {String}
     */

  }, {
    key: "renderScaleHeading",
    value: function renderScaleHeading(max) {
      var _this4 = this;

      var keys = this.scale.map(function (ele) {
        return ele.name;
      });

      if (typeof this.options.renderScaleHeading === 'function') {
        keys = this.options.renderScaleHeading.call(this, max);
      }

      var diff = this.scaleLength - keys.join('').length;
      var spacing = Math.round(diff / (keys.length - 1));
      var names = keys.map(function (key) {
        return _this4.styles.strong(key);
      });
      var headings = names.join(' '.repeat(spacing));
      var padding = ' '.repeat(this.widths[0]);
      return this.margin[3] + padding + this.margin[1] + headings;
    }
    /**
     * Render a scale indicator => ◯ or ◉ by default
     */

  }, {
    key: "scaleIndicator",
    value: function scaleIndicator(choice, item, i) {
      if (typeof this.options.scaleIndicator === 'function') {
        return this.options.scaleIndicator.call(this, choice, item, i);
      }

      var enabled = choice.scaleIndex === item.index;
      if (item.disabled) return this.styles.hint(this.symbols.radio.disabled);
      if (enabled) return this.styles.success(this.symbols.radio.on);
      return this.symbols.radio.off;
    }
    /**
     * Render the actual scale => ◯────◯────◉────◯────◯
     */

  }, {
    key: "renderScale",
    value: function renderScale(choice, i) {
      var _this5 = this;

      var scale = choice.scale.map(function (item) {
        return _this5.scaleIndicator(choice, item, i);
      });
      var padding = this.term === 'Hyper' ? '' : ' ';
      return scale.join(padding + this.symbols.line.repeat(this.edgeLength));
    }
    /**
     * Render a choice, including scale =>
     *   "The website is easy to navigate. ◯───◯───◉───◯───◯"
     */

  }, {
    key: "renderChoice",
    value: function () {
      var _renderChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(choice, i) {
        var _this6 = this;

        var focused, pointer, hint, pad, newline, ind, message, scale, margin, msg, lines;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.onChoice(choice, i);

              case 2:
                focused = this.index === i;
                _context3.next = 5;
                return this.pointer(choice, i);

              case 5:
                pointer = _context3.sent;
                _context3.next = 8;
                return choice.hint;

              case 8:
                hint = _context3.sent;

                if (hint && !utils.hasColor(hint)) {
                  hint = this.styles.muted(hint);
                }

                pad = function pad(str) {
                  return _this6.margin[3] + str.replace(/\s+$/, '').padEnd(_this6.widths[0], ' ');
                };

                newline = this.newline;
                ind = this.indent(choice);
                _context3.next = 15;
                return this.resolve(choice.message, this.state, choice, i);

              case 15:
                message = _context3.sent;
                _context3.next = 18;
                return this.renderScale(choice, i);

              case 18:
                scale = _context3.sent;
                margin = this.margin[1] + this.margin[3];
                this.scaleLength = colors.unstyle(scale).length;
                this.widths[0] = Math.min(this.widths[0], this.width - this.scaleLength - margin.length);
                msg = utils.wordWrap(message, {
                  width: this.widths[0],
                  newline: newline
                });
                lines = msg.split('\n').map(function (line) {
                  return pad(line) + _this6.margin[1];
                });

                if (focused) {
                  scale = this.styles.info(scale);
                  lines = lines.map(function (line) {
                    return _this6.styles.info(line);
                  });
                }

                lines[0] += scale;
                if (this.linebreak) lines.push('');
                return _context3.abrupt("return", [ind + pointer, lines.join('\n')].filter(Boolean));

              case 28:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function renderChoice(_x3, _x4) {
        return _renderChoice.apply(this, arguments);
      }

      return renderChoice;
    }()
  }, {
    key: "renderChoices",
    value: function () {
      var _renderChoices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var _this7 = this;

        var choices, visible, heading;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.state.submitted) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return", '');

              case 2:
                this.tableize();
                choices = this.visible.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ch, i) {
                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return _this7.renderChoice(ch, i);

                          case 2:
                            return _context4.abrupt("return", _context4.sent);

                          case 3:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x5, _x6) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context5.next = 6;
                return Promise.all(choices);

              case 6:
                visible = _context5.sent;
                _context5.next = 9;
                return this.renderScaleHeading();

              case 9:
                heading = _context5.sent;
                return _context5.abrupt("return", this.margin[0] + [heading].concat(_toConsumableArray(visible.map(function (v) {
                  return v.join(' ');
                }))).join('\n'));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function renderChoices() {
        return _renderChoices.apply(this, arguments);
      }

      return renderChoices;
    }()
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var _this$state, submitted, size, prefix, separator, message, prompt, header, output, key, help, body, footer, err;

        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _this$state = this.state, submitted = _this$state.submitted, size = _this$state.size;
                _context6.next = 3;
                return this.prefix();

              case 3:
                prefix = _context6.sent;
                _context6.next = 6;
                return this.separator();

              case 6:
                separator = _context6.sent;
                _context6.next = 9;
                return this.message();

              case 9:
                message = _context6.sent;
                prompt = '';

                if (this.options.promptLine !== false) {
                  prompt = [prefix, message, separator, ''].join(' ');
                  this.state.prompt = prompt;
                }

                _context6.next = 14;
                return this.header();

              case 14:
                header = _context6.sent;
                _context6.next = 17;
                return this.format();

              case 17:
                output = _context6.sent;
                _context6.next = 20;
                return this.renderScaleKey();

              case 20:
                key = _context6.sent;
                _context6.next = 23;
                return this.error();

              case 23:
                _context6.t0 = _context6.sent;

                if (_context6.t0) {
                  _context6.next = 28;
                  break;
                }

                _context6.next = 27;
                return this.hint();

              case 27:
                _context6.t0 = _context6.sent;

              case 28:
                help = _context6.t0;
                _context6.next = 31;
                return this.renderChoices();

              case 31:
                body = _context6.sent;
                _context6.next = 34;
                return this.footer();

              case 34:
                footer = _context6.sent;
                err = this.emptyError;
                if (output) prompt += output;
                if (help && !prompt.includes(help)) prompt += ' ' + help;

                if (submitted && !output && !body.trim() && this.multiple && err != null) {
                  prompt += this.styles.danger(err);
                }

                this.clear(size);
                this.write([header, prompt, key, body, footer].filter(Boolean).join('\n'));

                if (!this.state.submitted) {
                  this.write(this.margin[2]);
                }

                this.restore();

              case 43:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }, {
    key: "submit",
    value: function submit() {
      this.value = {};

      var _iterator2 = _createForOfIteratorHelper(this.choices),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var choice = _step2.value;
          this.value[choice.name] = choice.scaleIndex;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return this.base.submit.call(this);
    }
  }]);

  return LikertScale;
}(ArrayPrompt);

module.exports = LikertScale;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"ansi-colors":42,"../types/array":67,"../utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/select.js
      60: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ArrayPrompt = require('../types/array');

var utils = require('../utils');

var SelectPrompt = /*#__PURE__*/function (_ArrayPrompt) {
  _inherits(SelectPrompt, _ArrayPrompt);

  var _super = _createSuper(SelectPrompt);

  function SelectPrompt(options) {
    var _this;

    _classCallCheck(this, SelectPrompt);

    _this = _super.call(this, options);
    _this.emptyError = _this.options.emptyError || 'No items were selected';
    return _this;
  }

  _createClass(SelectPrompt, [{
    key: "dispatch",
    value: function () {
      var _dispatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(s, key) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.multiple) {
                  _context.next = 11;
                  break;
                }

                if (!this[key.name]) {
                  _context.next = 7;
                  break;
                }

                _context.next = 4;
                return this[key.name](s, key);

              case 4:
                _context.t0 = _context.sent;
                _context.next = 10;
                break;

              case 7:
                _context.next = 9;
                return _get(_getPrototypeOf(SelectPrompt.prototype), "dispatch", this).call(this, s, key);

              case 9:
                _context.t0 = _context.sent;

              case 10:
                return _context.abrupt("return", _context.t0);

              case 11:
                this.alert();

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function dispatch(_x, _x2) {
        return _dispatch.apply(this, arguments);
      }

      return dispatch;
    }()
  }, {
    key: "separator",
    value: function separator() {
      if (this.options.separator) return _get(_getPrototypeOf(SelectPrompt.prototype), "separator", this).call(this);
      var sep = this.styles.muted(this.symbols.ellipsis);
      return this.state.submitted ? _get(_getPrototypeOf(SelectPrompt.prototype), "separator", this).call(this) : sep;
    }
  }, {
    key: "pointer",
    value: function pointer(choice, i) {
      return !this.multiple || this.options.pointer ? _get(_getPrototypeOf(SelectPrompt.prototype), "pointer", this).call(this, choice, i) : '';
    }
  }, {
    key: "indicator",
    value: function indicator(choice, i) {
      return this.multiple ? _get(_getPrototypeOf(SelectPrompt.prototype), "indicator", this).call(this, choice, i) : '';
    }
  }, {
    key: "choiceMessage",
    value: function choiceMessage(choice, i) {
      var message = this.resolve(choice.message, this.state, choice, i);

      if (choice.role === 'heading' && !utils.hasColor(message)) {
        message = this.styles.strong(message);
      }

      return this.resolve(message, this.state, choice, i);
    }
  }, {
    key: "choiceSeparator",
    value: function choiceSeparator() {
      return ':';
    }
  }, {
    key: "renderChoice",
    value: function () {
      var _renderChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(choice, i) {
        var _this2 = this;

        var focused, pointer, check, hint, ind, msg, line;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.onChoice(choice, i);

              case 2:
                focused = this.index === i;
                _context2.next = 5;
                return this.pointer(choice, i);

              case 5:
                pointer = _context2.sent;
                _context2.next = 8;
                return this.indicator(choice, i);

              case 8:
                _context2.t0 = _context2.sent;
                _context2.t1 = choice.pad || '';
                check = _context2.t0 + _context2.t1;
                _context2.next = 13;
                return this.resolve(choice.hint, this.state, choice, i);

              case 13:
                hint = _context2.sent;

                if (hint && !utils.hasColor(hint)) {
                  hint = this.styles.muted(hint);
                }

                ind = this.indent(choice);
                _context2.next = 18;
                return this.choiceMessage(choice, i);

              case 18:
                msg = _context2.sent;

                line = function line() {
                  return [_this2.margin[3], ind + pointer + check, msg, _this2.margin[1], hint].filter(Boolean).join(' ');
                };

                if (!(choice.role === 'heading')) {
                  _context2.next = 22;
                  break;
                }

                return _context2.abrupt("return", line());

              case 22:
                if (!choice.disabled) {
                  _context2.next = 25;
                  break;
                }

                if (!utils.hasColor(msg)) {
                  msg = this.styles.disabled(msg);
                }

                return _context2.abrupt("return", line());

              case 25:
                if (focused) {
                  msg = this.styles.em(msg);
                }

                return _context2.abrupt("return", line());

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function renderChoice(_x3, _x4) {
        return _renderChoice.apply(this, arguments);
      }

      return renderChoice;
    }()
  }, {
    key: "renderChoices",
    value: function () {
      var _renderChoices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this3 = this;

        var choices, visible, result, header;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(this.state.loading === 'choices')) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", this.styles.warning('Loading choices'));

              case 2:
                if (!this.state.submitted) {
                  _context4.next = 4;
                  break;
                }

                return _context4.abrupt("return", '');

              case 4:
                choices = this.visible.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(ch, i) {
                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this3.renderChoice(ch, i);

                          case 2:
                            return _context3.abrupt("return", _context3.sent);

                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x5, _x6) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context4.next = 7;
                return Promise.all(choices);

              case 7:
                visible = _context4.sent;
                if (!visible.length) visible.push(this.styles.danger('No matching choices'));
                result = this.margin[0] + visible.join('\n');

                if (!this.options.choicesHeader) {
                  _context4.next = 14;
                  break;
                }

                _context4.next = 13;
                return this.resolve(this.options.choicesHeader, this.state);

              case 13:
                header = _context4.sent;

              case 14:
                return _context4.abrupt("return", [header, result].filter(Boolean).join('\n'));

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function renderChoices() {
        return _renderChoices.apply(this, arguments);
      }

      return renderChoices;
    }()
  }, {
    key: "format",
    value: function format() {
      var _this4 = this;

      if (!this.state.submitted || this.state.cancelled) return '';

      if (Array.isArray(this.selected)) {
        return this.selected.map(function (choice) {
          return _this4.styles.primary(choice.name);
        }).join(', ');
      }

      return this.styles.primary(this.selected.name);
    }
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var _this$state, submitted, size, prompt, header, prefix, separator, message, output, help, body, footer;

        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _this$state = this.state, submitted = _this$state.submitted, size = _this$state.size;
                prompt = '';
                _context5.next = 4;
                return this.header();

              case 4:
                header = _context5.sent;
                _context5.next = 7;
                return this.prefix();

              case 7:
                prefix = _context5.sent;
                _context5.next = 10;
                return this.separator();

              case 10:
                separator = _context5.sent;
                _context5.next = 13;
                return this.message();

              case 13:
                message = _context5.sent;

                if (this.options.promptLine !== false) {
                  prompt = [prefix, message, separator, ''].join(' ');
                  this.state.prompt = prompt;
                }

                _context5.next = 17;
                return this.format();

              case 17:
                output = _context5.sent;
                _context5.next = 20;
                return this.error();

              case 20:
                _context5.t0 = _context5.sent;

                if (_context5.t0) {
                  _context5.next = 25;
                  break;
                }

                _context5.next = 24;
                return this.hint();

              case 24:
                _context5.t0 = _context5.sent;

              case 25:
                help = _context5.t0;
                _context5.next = 28;
                return this.renderChoices();

              case 28:
                body = _context5.sent;
                _context5.next = 31;
                return this.footer();

              case 31:
                footer = _context5.sent;
                if (output) prompt += output;
                if (help && !prompt.includes(help)) prompt += ' ' + help;

                if (submitted && !output && !body.trim() && this.multiple && this.emptyError != null) {
                  prompt += this.styles.danger(this.emptyError);
                }

                this.clear(size);
                this.write([header, prompt, body, footer].filter(Boolean).join('\n'));
                this.write(this.margin[2]);
                this.restore();

              case 39:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }]);

  return SelectPrompt;
}(ArrayPrompt);

module.exports = SelectPrompt;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/array":67,"../utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/snippet.js
      61: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var colors = require('ansi-colors');

var interpolate = require('../interpolate');

var Prompt = require('../prompt');

var SnippetPrompt = /*#__PURE__*/function (_Prompt) {
  _inherits(SnippetPrompt, _Prompt);

  var _super = _createSuper(SnippetPrompt);

  function SnippetPrompt(options) {
    var _this;

    _classCallCheck(this, SnippetPrompt);

    _this = _super.call(this, options);

    _this.cursorHide();

    _this.reset(true);

    return _this;
  }

  _createClass(SnippetPrompt, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return interpolate(this);

              case 2:
                this.interpolate = _context.sent;
                _context.next = 5;
                return _get(_getPrototypeOf(SnippetPrompt.prototype), "initialize", this).call(this);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initialize() {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
  }, {
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(first) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.state.keys = [];
                this.state.invalid = new Map();
                this.state.missing = new Set();
                this.state.completed = 0;
                this.state.values = {};

                if (!(first !== true)) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 8;
                return this.initialize();

              case 8:
                _context2.next = 10;
                return this.render();

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function reset(_x) {
        return _reset.apply(this, arguments);
      }

      return reset;
    }()
  }, {
    key: "moveCursor",
    value: function moveCursor(n) {
      var item = this.getItem();
      this.cursor += n;
      item.cursor += n;
    }
  }, {
    key: "dispatch",
    value: function dispatch(ch, key) {
      if (!key.code && !key.ctrl && ch != null && this.getItem()) {
        this.append(ch, key);
        return;
      }

      this.alert();
    }
  }, {
    key: "append",
    value: function append(ch, key) {
      var item = this.getItem();
      var prefix = item.input.slice(0, this.cursor);
      var suffix = item.input.slice(this.cursor);
      this.input = item.input = "".concat(prefix).concat(ch).concat(suffix);
      this.moveCursor(1);
      this.render();
    }
  }, {
    key: "delete",
    value: function _delete() {
      var item = this.getItem();
      if (this.cursor <= 0 || !item.input) return this.alert();
      var suffix = item.input.slice(this.cursor);
      var prefix = item.input.slice(0, this.cursor - 1);
      this.input = item.input = "".concat(prefix).concat(suffix);
      this.moveCursor(-1);
      this.render();
    }
  }, {
    key: "increment",
    value: function increment(i) {
      return i >= this.state.keys.length - 1 ? 0 : i + 1;
    }
  }, {
    key: "decrement",
    value: function decrement(i) {
      return i <= 0 ? this.state.keys.length - 1 : i - 1;
    }
  }, {
    key: "first",
    value: function first() {
      this.state.index = 0;
      this.render();
    }
  }, {
    key: "last",
    value: function last() {
      this.state.index = this.state.keys.length - 1;
      this.render();
    }
  }, {
    key: "right",
    value: function right() {
      if (this.cursor >= this.input.length) return this.alert();
      this.moveCursor(1);
      this.render();
    }
  }, {
    key: "left",
    value: function left() {
      if (this.cursor <= 0) return this.alert();
      this.moveCursor(-1);
      this.render();
    }
  }, {
    key: "prev",
    value: function prev() {
      this.state.index = this.decrement(this.state.index);
      this.getItem();
      this.render();
    }
  }, {
    key: "next",
    value: function next() {
      this.state.index = this.increment(this.state.index);
      this.getItem();
      this.render();
    }
  }, {
    key: "up",
    value: function up() {
      this.prev();
    }
  }, {
    key: "down",
    value: function down() {
      this.next();
    }
  }, {
    key: "format",
    value: function format(value) {
      var color = this.state.completed < 100 ? this.styles.warning : this.styles.success;

      if (this.state.submitted === true && this.state.completed !== 100) {
        color = this.styles.danger;
      }

      return color("".concat(this.state.completed, "% completed"));
    }
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this$state, index, _this$state$keys, keys, submitted, size, newline, prefix, separator, message, prompt, header, error, hint, body, key, input, footer, lines;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _this$state = this.state, index = _this$state.index, _this$state$keys = _this$state.keys, keys = _this$state$keys === void 0 ? [] : _this$state$keys, submitted = _this$state.submitted, size = _this$state.size;
                newline = [this.options.newline, '\n'].find(function (v) {
                  return v != null;
                });
                _context3.next = 4;
                return this.prefix();

              case 4:
                prefix = _context3.sent;
                _context3.next = 7;
                return this.separator();

              case 7:
                separator = _context3.sent;
                _context3.next = 10;
                return this.message();

              case 10:
                message = _context3.sent;
                prompt = [prefix, message, separator].filter(Boolean).join(' ');
                this.state.prompt = prompt;
                _context3.next = 15;
                return this.header();

              case 15:
                header = _context3.sent;
                _context3.next = 18;
                return this.error();

              case 18:
                _context3.t0 = _context3.sent;

                if (_context3.t0) {
                  _context3.next = 21;
                  break;
                }

                _context3.t0 = '';

              case 21:
                error = _context3.t0;
                _context3.next = 24;
                return this.hint();

              case 24:
                _context3.t1 = _context3.sent;

                if (_context3.t1) {
                  _context3.next = 27;
                  break;
                }

                _context3.t1 = '';

              case 27:
                hint = _context3.t1;

                if (!submitted) {
                  _context3.next = 32;
                  break;
                }

                _context3.t2 = '';
                _context3.next = 35;
                break;

              case 32:
                _context3.next = 34;
                return this.interpolate(this.state);

              case 34:
                _context3.t2 = _context3.sent;

              case 35:
                body = _context3.t2;
                key = this.state.key = keys[index] || '';
                _context3.next = 39;
                return this.format(key);

              case 39:
                input = _context3.sent;
                _context3.next = 42;
                return this.footer();

              case 42:
                footer = _context3.sent;
                if (input) prompt += ' ' + input;
                if (hint && !input && this.state.completed === 0) prompt += ' ' + hint;
                this.clear(size);
                lines = [header, prompt, body, footer, error.trim()];
                this.write(lines.filter(Boolean).join(newline));
                this.restore();

              case 49:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }, {
    key: "getItem",
    value: function getItem(name) {
      var _this$state2 = this.state,
          items = _this$state2.items,
          keys = _this$state2.keys,
          index = _this$state2.index;
      var item = items.find(function (ch) {
        return ch.name === keys[index];
      });

      if (item && item.input != null) {
        this.input = item.input;
        this.cursor = item.cursor;
      }

      return item;
    }
  }, {
    key: "submit",
    value: function () {
      var _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this$state3, invalid, missing, output, values, err, _iterator, _step, _step$value, key, value, lines, result;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(typeof this.interpolate !== 'function')) {
                  _context4.next = 3;
                  break;
                }

                _context4.next = 3;
                return this.initialize();

              case 3:
                _context4.next = 5;
                return this.interpolate(this.state, true);

              case 5:
                _this$state3 = this.state, invalid = _this$state3.invalid, missing = _this$state3.missing, output = _this$state3.output, values = _this$state3.values;

                if (!invalid.size) {
                  _context4.next = 12;
                  break;
                }

                err = '';
                _iterator = _createForOfIteratorHelper(invalid);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
                    err += "Invalid ".concat(key, ": ").concat(value, "\n");
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                this.state.error = err;
                return _context4.abrupt("return", _get(_getPrototypeOf(SnippetPrompt.prototype), "submit", this).call(this));

              case 12:
                if (!missing.size) {
                  _context4.next = 15;
                  break;
                }

                this.state.error = 'Required: ' + _toConsumableArray(missing.keys()).join(', ');
                return _context4.abrupt("return", _get(_getPrototypeOf(SnippetPrompt.prototype), "submit", this).call(this));

              case 15:
                lines = colors.unstyle(output).split('\n');
                result = lines.map(function (v) {
                  return v.slice(1);
                }).join('\n');
                this.value = {
                  values: values,
                  result: result
                };
                return _context4.abrupt("return", _get(_getPrototypeOf(SnippetPrompt.prototype), "submit", this).call(this));

              case 19:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function submit() {
        return _submit.apply(this, arguments);
      }

      return submit;
    }()
  }]);

  return SnippetPrompt;
}(Prompt);

module.exports = SnippetPrompt;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/slicedToArray":120,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"ansi-colors":42,"../interpolate":121,"../prompt":20}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/sort.js
      62: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _assertThisInitialized = require("@babel/runtime/helpers/assertThisInitialized");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var hint = '(Use <shift>+<up/down> to sort)';

var Prompt = require('./select');

var Sort = /*#__PURE__*/function (_Prompt) {
  _inherits(Sort, _Prompt);

  var _super = _createSuper(Sort);

  function Sort(options) {
    var _this;

    _classCallCheck(this, Sort);

    _this = _super.call(this, _objectSpread(_objectSpread({}, options), {}, {
      reorder: false,
      sort: true,
      multiple: true
    }));
    _this.state.hint = [_this.options.hint, hint].find(_this.isValue.bind(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(Sort, [{
    key: "indicator",
    value: function indicator() {
      return '';
    }
  }, {
    key: "renderChoice",
    value: function () {
      var _renderChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(choice, i) {
        var str, sym, pre;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _get(_getPrototypeOf(Sort.prototype), "renderChoice", this).call(this, choice, i);

              case 2:
                str = _context.sent;
                sym = this.symbols.identicalTo + ' ';
                pre = this.index === i && this.sorting ? this.styles.muted(sym) : '  ';
                if (this.options.drag === false) pre = '';

                if (!(this.options.numbered === true)) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", pre + "".concat(i + 1, " - ") + str);

              case 8:
                return _context.abrupt("return", pre + str);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function renderChoice(_x, _x2) {
        return _renderChoice.apply(this, arguments);
      }

      return renderChoice;
    }()
  }, {
    key: "selected",
    get: function get() {
      return this.choices;
    }
  }, {
    key: "submit",
    value: function submit() {
      this.value = this.choices.map(function (choice) {
        return choice.value;
      });
      return _get(_getPrototypeOf(Sort.prototype), "submit", this).call(this);
    }
  }]);

  return Sort;
}(Prompt);

module.exports = Sort;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/assertThisInitialized":41,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"./select":60}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/survey.js
      63: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ArrayPrompt = require('../types/array');

var Survey = /*#__PURE__*/function (_ArrayPrompt) {
  _inherits(Survey, _ArrayPrompt);

  var _super = _createSuper(Survey);

  function Survey() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Survey);

    _this = _super.call(this, options);
    _this.emptyError = options.emptyError || 'No items were selected';
    _this.term = process.env.TERM_PROGRAM;

    if (!_this.options.header) {
      var header = ['', '4 - Strongly Agree', '3 - Agree', '2 - Neutral', '1 - Disagree', '0 - Strongly Disagree', ''];
      header = header.map(function (ele) {
        return _this.styles.muted(ele);
      });
      _this.state.header = header.join('\n   ');
    }

    return _this;
  }

  _createClass(Survey, [{
    key: "toChoices",
    value: function () {
      var _toChoices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _get2;

        var _len,
            args,
            _key,
            choices,
            _iterator,
            _step,
            choice,
            _args = arguments;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.createdScales) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", false);

              case 2:
                this.createdScales = true;

                for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = _args[_key];
                }

                _context.next = 6;
                return (_get2 = _get(_getPrototypeOf(Survey.prototype), "toChoices", this)).call.apply(_get2, [this].concat(args));

              case 6:
                choices = _context.sent;
                _iterator = _createForOfIteratorHelper(choices);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    choice = _step.value;
                    choice.scale = createScale(5, this.options);
                    choice.scaleIdx = 2;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                return _context.abrupt("return", choices);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function toChoices() {
        return _toChoices.apply(this, arguments);
      }

      return toChoices;
    }()
  }, {
    key: "dispatch",
    value: function dispatch() {
      this.alert();
    }
  }, {
    key: "space",
    value: function space() {
      var choice = this.focused;
      var ele = choice.scale[choice.scaleIdx];
      var selected = ele.selected;
      choice.scale.forEach(function (e) {
        return e.selected = false;
      });
      ele.selected = !selected;
      return this.render();
    }
  }, {
    key: "indicator",
    value: function indicator() {
      return '';
    }
  }, {
    key: "pointer",
    value: function pointer() {
      return '';
    }
  }, {
    key: "separator",
    value: function separator() {
      return this.styles.muted(this.symbols.ellipsis);
    }
  }, {
    key: "right",
    value: function right() {
      var choice = this.focused;
      if (choice.scaleIdx >= choice.scale.length - 1) return this.alert();
      choice.scaleIdx++;
      return this.render();
    }
  }, {
    key: "left",
    value: function left() {
      var choice = this.focused;
      if (choice.scaleIdx <= 0) return this.alert();
      choice.scaleIdx--;
      return this.render();
    }
  }, {
    key: "indent",
    value: function indent() {
      return '   ';
    }
  }, {
    key: "renderChoice",
    value: function () {
      var _renderChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(item, i) {
        var _this2 = this;

        var focused, isHyper, n, s, ln, sp, dot, num, color, msg, indent, scale, val, next, line, lines;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.onChoice(item, i);

              case 2:
                focused = this.index === i;
                isHyper = this.term === 'Hyper';
                n = !isHyper ? 8 : 9;
                s = !isHyper ? ' ' : '';
                ln = this.symbols.line.repeat(n);
                sp = ' '.repeat(n + (isHyper ? 0 : 1));

                dot = function dot(enabled) {
                  return (enabled ? _this2.styles.success('◉') : '◯') + s;
                };

                num = i + 1 + '.';
                color = focused ? this.styles.heading : this.styles.noop;
                _context2.next = 13;
                return this.resolve(item.message, this.state, item, i);

              case 13:
                msg = _context2.sent;
                indent = this.indent(item);
                scale = indent + item.scale.map(function (e, i) {
                  return dot(i === item.scaleIdx);
                }).join(ln);

                val = function val(i) {
                  return i === item.scaleIdx ? color(i) : i;
                };

                next = indent + item.scale.map(function (e, i) {
                  return val(i);
                }).join(sp);

                line = function line() {
                  return [num, msg].filter(Boolean).join(' ');
                };

                lines = function lines() {
                  return [line(), scale, next, ' '].filter(Boolean).join('\n');
                };

                if (focused) {
                  scale = this.styles.cyan(scale);
                  next = this.styles.cyan(next);
                }

                return _context2.abrupt("return", lines());

              case 22:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function renderChoice(_x, _x2) {
        return _renderChoice.apply(this, arguments);
      }

      return renderChoice;
    }()
  }, {
    key: "renderChoices",
    value: function () {
      var _renderChoices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this3 = this;

        var choices, visible;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.state.submitted) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", '');

              case 2:
                choices = this.visible.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(ch, i) {
                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this3.renderChoice(ch, i);

                          case 2:
                            return _context3.abrupt("return", _context3.sent);

                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x3, _x4) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context4.next = 5;
                return Promise.all(choices);

              case 5:
                visible = _context4.sent;
                if (!visible.length) visible.push(this.styles.danger('No matching choices'));
                return _context4.abrupt("return", visible.join('\n'));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function renderChoices() {
        return _renderChoices.apply(this, arguments);
      }

      return renderChoices;
    }()
  }, {
    key: "format",
    value: function format() {
      var _this4 = this;

      if (this.state.submitted) {
        var values = this.choices.map(function (ch) {
          return _this4.styles.info(ch.scaleIdx);
        });
        return values.join(', ');
      }

      return '';
    }
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var _this$state, submitted, size, prefix, separator, message, prompt, header, output, help, body, footer;

        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _this$state = this.state, submitted = _this$state.submitted, size = _this$state.size;
                _context5.next = 3;
                return this.prefix();

              case 3:
                prefix = _context5.sent;
                _context5.next = 6;
                return this.separator();

              case 6:
                separator = _context5.sent;
                _context5.next = 9;
                return this.message();

              case 9:
                message = _context5.sent;
                prompt = [prefix, message, separator].filter(Boolean).join(' ');
                this.state.prompt = prompt;
                _context5.next = 14;
                return this.header();

              case 14:
                header = _context5.sent;
                _context5.next = 17;
                return this.format();

              case 17:
                output = _context5.sent;
                _context5.next = 20;
                return this.error();

              case 20:
                _context5.t0 = _context5.sent;

                if (_context5.t0) {
                  _context5.next = 25;
                  break;
                }

                _context5.next = 24;
                return this.hint();

              case 24:
                _context5.t0 = _context5.sent;

              case 25:
                help = _context5.t0;
                _context5.next = 28;
                return this.renderChoices();

              case 28:
                body = _context5.sent;
                _context5.next = 31;
                return this.footer();

              case 31:
                footer = _context5.sent;
                if (output || !help) prompt += ' ' + output;
                if (help && !prompt.includes(help)) prompt += ' ' + help;

                if (submitted && !output && !body && this.multiple && this.type !== 'form') {
                  prompt += this.styles.danger(this.emptyError);
                }

                this.clear(size);
                this.write([prompt, header, body, footer].filter(Boolean).join('\n'));
                this.restore();

              case 38:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }, {
    key: "submit",
    value: function submit() {
      this.value = {};

      var _iterator2 = _createForOfIteratorHelper(this.choices),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var choice = _step2.value;
          this.value[choice.name] = choice.scaleIdx;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return this.base.submit.call(this);
    }
  }]);

  return Survey;
}(ArrayPrompt);

function createScale(n) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (Array.isArray(options.scale)) {
    return options.scale.map(function (ele) {
      return _objectSpread({}, ele);
    });
  }

  var scale = [];

  for (var i = 1; i < n + 1; i++) {
    scale.push({
      i: i,
      selected: false
    });
  }

  return scale;
}

module.exports = Survey;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/array":67}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/text.js
      64: {
        factory: (module, exports, require) => {
          module.exports = require('./input');
        },
        map: {"./input":53}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/toggle.js
      65: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var BooleanPrompt = require('../types/boolean');

var TogglePrompt = /*#__PURE__*/function (_BooleanPrompt) {
  _inherits(TogglePrompt, _BooleanPrompt);

  var _super = _createSuper(TogglePrompt);

  function TogglePrompt() {
    _classCallCheck(this, TogglePrompt);

    return _super.apply(this, arguments);
  }

  _createClass(TogglePrompt, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _get(_getPrototypeOf(TogglePrompt.prototype), "initialize", this).call(this);

              case 2:
                this.value = this.initial = !!this.options.initial;
                this.disabled = this.options.disabled || 'no';
                this.enabled = this.options.enabled || 'yes';
                _context.next = 7;
                return this.render();

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initialize() {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
  }, {
    key: "reset",
    value: function reset() {
      this.value = this.initial;
      this.render();
    }
  }, {
    key: "delete",
    value: function _delete() {
      this.alert();
    }
  }, {
    key: "toggle",
    value: function toggle() {
      this.value = !this.value;
      this.render();
    }
  }, {
    key: "enable",
    value: function enable() {
      if (this.value === true) return this.alert();
      this.value = true;
      this.render();
    }
  }, {
    key: "disable",
    value: function disable() {
      if (this.value === false) return this.alert();
      this.value = false;
      this.render();
    }
  }, {
    key: "up",
    value: function up() {
      this.toggle();
    }
  }, {
    key: "down",
    value: function down() {
      this.toggle();
    }
  }, {
    key: "right",
    value: function right() {
      this.toggle();
    }
  }, {
    key: "left",
    value: function left() {
      this.toggle();
    }
  }, {
    key: "next",
    value: function next() {
      this.toggle();
    }
  }, {
    key: "prev",
    value: function prev() {
      this.toggle();
    }
  }, {
    key: "dispatch",
    value: function dispatch() {
      var ch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var key = arguments.length > 1 ? arguments[1] : undefined;

      switch (ch.toLowerCase()) {
        case ' ':
          return this.toggle();

        case '1':
        case 'y':
        case 't':
          return this.enable();

        case '0':
        case 'n':
        case 'f':
          return this.disable();

        default:
          {
            return this.alert();
          }
      }
    }
  }, {
    key: "format",
    value: function format() {
      var _this = this;

      var active = function active(str) {
        return _this.styles.primary.underline(str);
      };

      var value = [this.value ? this.disabled : active(this.disabled), this.value ? active(this.enabled) : this.enabled];
      return value.join(this.styles.muted(' / '));
    }
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var size, header, prefix, separator, message, output, help, footer, prompt;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                size = this.state.size;
                _context2.next = 3;
                return this.header();

              case 3:
                header = _context2.sent;
                _context2.next = 6;
                return this.prefix();

              case 6:
                prefix = _context2.sent;
                _context2.next = 9;
                return this.separator();

              case 9:
                separator = _context2.sent;
                _context2.next = 12;
                return this.message();

              case 12:
                message = _context2.sent;
                _context2.next = 15;
                return this.format();

              case 15:
                output = _context2.sent;
                _context2.next = 18;
                return this.error();

              case 18:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 23;
                  break;
                }

                _context2.next = 22;
                return this.hint();

              case 22:
                _context2.t0 = _context2.sent;

              case 23:
                help = _context2.t0;
                _context2.next = 26;
                return this.footer();

              case 26:
                footer = _context2.sent;
                prompt = [prefix, message, separator, output].join(' ');
                this.state.prompt = prompt;
                if (help && !prompt.includes(help)) prompt += ' ' + help;
                this.clear(size);
                this.write([header, prompt, footer].filter(Boolean).join('\n'));
                this.write(this.margin[2]);
                this.restore();

              case 34:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }]);

  return TogglePrompt;
}(BooleanPrompt);

module.exports = TogglePrompt;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../types/boolean":69}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/prompts/quiz.js
      66: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SelectPrompt = require('./select');

var Quiz = /*#__PURE__*/function (_SelectPrompt) {
  _inherits(Quiz, _SelectPrompt);

  var _super = _createSuper(Quiz);

  function Quiz(options) {
    var _this;

    _classCallCheck(this, Quiz);

    _this = _super.call(this, options);

    if (typeof _this.options.correctChoice !== 'number' || _this.options.correctChoice < 0) {
      throw new Error('Please specify the index of the correct answer from the list of choices');
    }

    return _this;
  }

  _createClass(Quiz, [{
    key: "toChoices",
    value: function () {
      var _toChoices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value, parent) {
        var choices;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _get(_getPrototypeOf(Quiz.prototype), "toChoices", this).call(this, value, parent);

              case 2:
                choices = _context.sent;

                if (!(choices.length < 2)) {
                  _context.next = 5;
                  break;
                }

                throw new Error('Please give at least two choices to the user');

              case 5:
                if (!(this.options.correctChoice > choices.length)) {
                  _context.next = 7;
                  break;
                }

                throw new Error('Please specify the index of the correct answer from the list of choices');

              case 7:
                return _context.abrupt("return", choices);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function toChoices(_x, _x2) {
        return _toChoices.apply(this, arguments);
      }

      return toChoices;
    }()
  }, {
    key: "check",
    value: function check(state) {
      return state.index === this.options.correctChoice;
    }
  }, {
    key: "result",
    value: function () {
      var _result = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(selected) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = selected;
                _context2.t1 = this.options.choices[this.options.correctChoice].value;
                _context2.next = 4;
                return this.check(this.state);

              case 4:
                _context2.t2 = _context2.sent;
                return _context2.abrupt("return", {
                  selectedAnswer: _context2.t0,
                  correctAnswer: _context2.t1,
                  correct: _context2.t2
                });

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function result(_x3) {
        return _result.apply(this, arguments);
      }

      return result;
    }()
  }]);

  return Quiz;
}(SelectPrompt);

module.exports = Quiz;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"./select":60}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/types/array.js
      67: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _set = require("@babel/runtime/helpers/set");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var colors = require('ansi-colors');

var Prompt = require('../prompt');

var roles = require('../roles');

var utils = require('../utils');

var reorder = utils.reorder,
    _scrollUp = utils.scrollUp,
    _scrollDown = utils.scrollDown,
    isObject = utils.isObject,
    _swap = utils.swap;

var ArrayPrompt = /*#__PURE__*/function (_Prompt) {
  _inherits(ArrayPrompt, _Prompt);

  var _super = _createSuper(ArrayPrompt);

  function ArrayPrompt(options) {
    var _this;

    _classCallCheck(this, ArrayPrompt);

    _this = _super.call(this, options);

    _this.cursorHide();

    _this.maxSelected = options.maxSelected || Infinity;
    _this.multiple = options.multiple || false;
    _this.initial = options.initial || 0;
    _this.delay = options.delay || 0;
    _this.longest = 0;
    _this.num = '';
    return _this;
  }

  _createClass(ArrayPrompt, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof this.options.initial === 'function')) {
                  _context.next = 4;
                  break;
                }

                _context.next = 3;
                return this.options.initial.call(this);

              case 3:
                this.initial = _context.sent;

              case 4:
                _context.next = 6;
                return this.reset(true);

              case 6:
                _context.next = 8;
                return _get(_getPrototypeOf(ArrayPrompt.prototype), "initialize", this).call(this);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initialize() {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
  }, {
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2 = this;

        var _this$options, choices, initial, autofocus, suggest;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this$options = this.options, choices = _this$options.choices, initial = _this$options.initial, autofocus = _this$options.autofocus, suggest = _this$options.suggest;
                this.state._choices = [];
                this.state.choices = [];
                _context2.t0 = Promise;
                _context2.next = 6;
                return this.toChoices(choices);

              case 6:
                _context2.t1 = _context2.sent;
                _context2.next = 9;
                return _context2.t0.all.call(_context2.t0, _context2.t1);

              case 9:
                this.choices = _context2.sent;
                this.choices.forEach(function (ch) {
                  return ch.enabled = false;
                });

                if (!(typeof suggest !== 'function' && this.selectable.length === 0)) {
                  _context2.next = 13;
                  break;
                }

                throw new Error('At least one choice must be selectable');

              case 13:
                if (isObject(initial)) initial = Object.keys(initial);

                if (!Array.isArray(initial)) {
                  _context2.next = 21;
                  break;
                }

                if (autofocus != null) this.index = this.findIndex(autofocus);
                initial.forEach(function (v) {
                  return _this2.enable(_this2.find(v));
                });
                _context2.next = 19;
                return this.render();

              case 19:
                _context2.next = 24;
                break;

              case 21:
                if (autofocus != null) initial = autofocus;
                if (typeof initial === 'string') initial = this.findIndex(initial);

                if (typeof initial === 'number' && initial > -1) {
                  this.index = Math.max(0, Math.min(initial, this.choices.length));
                  this.enable(this.find(this.index));
                }

              case 24:
                if (!this.isDisabled(this.focused)) {
                  _context2.next = 27;
                  break;
                }

                _context2.next = 27;
                return this.down();

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function reset() {
        return _reset.apply(this, arguments);
      }

      return reset;
    }()
  }, {
    key: "toChoices",
    value: function () {
      var _toChoices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(value, parent) {
        var _this3 = this;

        var choices, index, toChoices;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.state.loadingChoices = true;
                choices = [];
                index = 0;

                toChoices = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(items, parent) {
                    var i, choice;
                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!(typeof items === 'function')) {
                              _context3.next = 4;
                              break;
                            }

                            _context3.next = 3;
                            return items.call(_this3);

                          case 3:
                            items = _context3.sent;

                          case 4:
                            if (!(items instanceof Promise)) {
                              _context3.next = 8;
                              break;
                            }

                            _context3.next = 7;
                            return items;

                          case 7:
                            items = _context3.sent;

                          case 8:
                            i = 0;

                          case 9:
                            if (!(i < items.length)) {
                              _context3.next = 20;
                              break;
                            }

                            _context3.next = 12;
                            return _this3.toChoice(items[i], index++, parent);

                          case 12:
                            choice = items[i] = _context3.sent;
                            choices.push(choice);

                            if (!choice.choices) {
                              _context3.next = 17;
                              break;
                            }

                            _context3.next = 17;
                            return toChoices(choice.choices, choice);

                          case 17:
                            i++;
                            _context3.next = 9;
                            break;

                          case 20:
                            return _context3.abrupt("return", choices);

                          case 21:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function toChoices(_x3, _x4) {
                    return _ref.apply(this, arguments);
                  };
                }();

                return _context4.abrupt("return", toChoices(value, parent).then(function (choices) {
                  _this3.state.loadingChoices = false;
                  return choices;
                }));

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function toChoices(_x, _x2) {
        return _toChoices.apply(this, arguments);
      }

      return toChoices;
    }()
  }, {
    key: "toChoice",
    value: function () {
      var _toChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(ele, i, parent) {
        var origVal, role, choice;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(typeof ele === 'function')) {
                  _context5.next = 4;
                  break;
                }

                _context5.next = 3;
                return ele.call(this, this);

              case 3:
                ele = _context5.sent;

              case 4:
                if (!(ele instanceof Promise)) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 7;
                return ele;

              case 7:
                ele = _context5.sent;

              case 8:
                if (typeof ele === 'string') ele = {
                  name: ele
                };

                if (!ele.normalized) {
                  _context5.next = 11;
                  break;
                }

                return _context5.abrupt("return", ele);

              case 11:
                ele.normalized = true;
                origVal = ele.value;
                role = roles(ele.role, this.options);
                ele = role(this, ele);

                if (typeof ele.disabled === 'string' && !ele.hint) {
                  ele.hint = ele.disabled;
                  ele.disabled = true;
                }

                if (ele.disabled === true && ele.hint == null) {
                  ele.hint = '(disabled)';
                } // if the choice was already normalized, return it


                if (!(ele.index != null)) {
                  _context5.next = 19;
                  break;
                }

                return _context5.abrupt("return", ele);

              case 19:
                ele.name = ele.name || ele.key || ele.title || ele.value || ele.message;
                ele.message = ele.message || ele.name || '';
                ele.value = [ele.value, ele.name].find(this.isValue.bind(this));
                ele.input = '';
                ele.index = i;
                ele.cursor = 0;
                utils.define(ele, 'parent', parent);
                ele.level = parent ? parent.level + 1 : 1;

                if (ele.indent == null) {
                  ele.indent = parent ? parent.indent + '  ' : ele.indent || '';
                }

                ele.path = parent ? parent.path + '.' + ele.name : ele.name;
                ele.enabled = !!(this.multiple && !this.isDisabled(ele) && (ele.enabled || this.isSelected(ele)));

                if (!this.isDisabled(ele)) {
                  this.longest = Math.max(this.longest, colors.unstyle(ele.message).length);
                } // shallow clone the choice first


                choice = _objectSpread({}, ele); // then allow the choice to be reset using the "original" values

                ele.reset = function () {
                  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : choice.input;
                  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : choice.value;

                  for (var _i = 0, _Object$keys = Object.keys(choice); _i < _Object$keys.length; _i++) {
                    var key = _Object$keys[_i];
                    ele[key] = choice[key];
                  }

                  ele.input = input;
                  ele.value = value;
                };

                if (!(origVal == null && typeof ele.initial === 'function')) {
                  _context5.next = 37;
                  break;
                }

                _context5.next = 36;
                return ele.initial.call(this, this.state, ele, i);

              case 36:
                ele.input = _context5.sent;

              case 37:
                return _context5.abrupt("return", ele);

              case 38:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function toChoice(_x5, _x6, _x7) {
        return _toChoice.apply(this, arguments);
      }

      return toChoice;
    }()
  }, {
    key: "onChoice",
    value: function () {
      var _onChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(choice, i) {
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this.emit('choice', choice, i, this);

                if (!(typeof choice.onChoice === 'function')) {
                  _context6.next = 4;
                  break;
                }

                _context6.next = 4;
                return choice.onChoice.call(this, this.state, choice, i);

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function onChoice(_x8, _x9) {
        return _onChoice.apply(this, arguments);
      }

      return onChoice;
    }()
  }, {
    key: "addChoice",
    value: function () {
      var _addChoice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(ele, i, parent) {
        var choice;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.toChoice(ele, i, parent);

              case 2:
                choice = _context7.sent;
                this.choices.push(choice);
                this.index = this.choices.length - 1;
                this.limit = this.choices.length;
                return _context7.abrupt("return", choice);

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function addChoice(_x10, _x11, _x12) {
        return _addChoice.apply(this, arguments);
      }

      return addChoice;
    }()
  }, {
    key: "newItem",
    value: function () {
      var _newItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(item, i, parent) {
        var ele, choice;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                ele = _objectSpread({
                  name: 'New choice name?',
                  editable: true,
                  newChoice: true
                }, item);
                _context8.next = 3;
                return this.addChoice(ele, i, parent);

              case 3:
                choice = _context8.sent;

                choice.updateChoice = function () {
                  delete choice.newChoice;
                  choice.name = choice.message = choice.input;
                  choice.input = '';
                  choice.cursor = 0;
                };

                return _context8.abrupt("return", this.render());

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function newItem(_x13, _x14, _x15) {
        return _newItem.apply(this, arguments);
      }

      return newItem;
    }()
  }, {
    key: "indent",
    value: function indent(choice) {
      if (choice.indent == null) {
        return choice.level > 1 ? '  '.repeat(choice.level - 1) : '';
      }

      return choice.indent;
    }
  }, {
    key: "dispatch",
    value: function dispatch(s, key) {
      if (this.multiple && this[key.name]) return this[key.name]();
      this.alert();
    }
  }, {
    key: "focus",
    value: function focus(choice, enabled) {
      if (typeof enabled !== 'boolean') enabled = choice.enabled;

      if (enabled && !choice.enabled && this.selected.length >= this.maxSelected) {
        return this.alert();
      }

      this.index = choice.index;
      choice.enabled = enabled && !this.isDisabled(choice);
      return choice;
    }
  }, {
    key: "space",
    value: function space() {
      if (!this.multiple) return this.alert();
      this.toggle(this.focused);
      return this.render();
    }
  }, {
    key: "a",
    value: function a() {
      if (this.maxSelected < this.choices.length) return this.alert();
      var enabled = this.selectable.every(function (ch) {
        return ch.enabled;
      });
      this.choices.forEach(function (ch) {
        return ch.enabled = !enabled;
      });
      return this.render();
    }
  }, {
    key: "i",
    value: function i() {
      // don't allow choices to be inverted if it will result in
      // more than the maximum number of allowed selected items.
      if (this.choices.length - this.selected.length > this.maxSelected) {
        return this.alert();
      }

      this.choices.forEach(function (ch) {
        return ch.enabled = !ch.enabled;
      });
      return this.render();
    }
  }, {
    key: "g",
    value: function g() {
      var choice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.focused;
      if (!this.choices.some(function (ch) {
        return !!ch.parent;
      })) return this.a();
      this.toggle(choice.parent && !choice.choices ? choice.parent : choice);
      return this.render();
    }
  }, {
    key: "toggle",
    value: function toggle(choice, enabled) {
      var _this4 = this;

      if (!choice.enabled && this.selected.length >= this.maxSelected) {
        return this.alert();
      }

      if (typeof enabled !== 'boolean') enabled = !choice.enabled;
      choice.enabled = enabled;

      if (choice.choices) {
        choice.choices.forEach(function (ch) {
          return _this4.toggle(ch, enabled);
        });
      }

      var parent = choice.parent;

      while (parent) {
        var choices = parent.choices.filter(function (ch) {
          return _this4.isDisabled(ch);
        });
        parent.enabled = choices.every(function (ch) {
          return ch.enabled === true;
        });
        parent = parent.parent;
      }

      reset(this, this.choices);
      this.emit('toggle', choice, this);
      return choice;
    }
  }, {
    key: "enable",
    value: function enable(choice) {
      if (this.selected.length >= this.maxSelected) return this.alert();
      choice.enabled = !this.isDisabled(choice);
      choice.choices && choice.choices.forEach(this.enable.bind(this));
      return choice;
    }
  }, {
    key: "disable",
    value: function disable(choice) {
      choice.enabled = false;
      choice.choices && choice.choices.forEach(this.disable.bind(this));
      return choice;
    }
  }, {
    key: "number",
    value: function number(n) {
      var _this5 = this;

      this.num += n;

      var number = function number(num) {
        var i = Number(num);
        if (i > _this5.choices.length - 1) return _this5.alert();
        var focused = _this5.focused;

        var choice = _this5.choices.find(function (ch) {
          return i === ch.index;
        });

        if (!choice.enabled && _this5.selected.length >= _this5.maxSelected) {
          return _this5.alert();
        }

        if (_this5.visible.indexOf(choice) === -1) {
          var choices = reorder(_this5.choices);
          var actualIdx = choices.indexOf(choice);

          if (focused.index > actualIdx) {
            var start = choices.slice(actualIdx, actualIdx + _this5.limit);
            var end = choices.filter(function (ch) {
              return !start.includes(ch);
            });
            _this5.choices = start.concat(end);
          } else {
            var pos = actualIdx - _this5.limit + 1;
            _this5.choices = choices.slice(pos).concat(choices.slice(0, pos));
          }
        }

        _this5.index = _this5.choices.indexOf(choice);

        _this5.toggle(_this5.focused);

        return _this5.render();
      };

      clearTimeout(this.numberTimeout);
      return new Promise(function (resolve) {
        var len = _this5.choices.length;
        var num = _this5.num;

        var handle = function handle() {
          var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var res = arguments.length > 1 ? arguments[1] : undefined;
          clearTimeout(_this5.numberTimeout);
          if (val) res = number(num);
          _this5.num = '';
          resolve(res);
        };

        if (num === '0' || num.length === 1 && Number(num + '0') > len) {
          return handle(true);
        }

        if (Number(num) > len) {
          return handle(false, _this5.alert());
        }

        _this5.numberTimeout = setTimeout(function () {
          return handle(true);
        }, _this5.delay);
      });
    }
  }, {
    key: "home",
    value: function home() {
      this.choices = reorder(this.choices);
      this.index = 0;
      return this.render();
    }
  }, {
    key: "end",
    value: function end() {
      var pos = this.choices.length - this.limit;
      var choices = reorder(this.choices);
      this.choices = choices.slice(pos).concat(choices.slice(0, pos));
      this.index = this.limit - 1;
      return this.render();
    }
  }, {
    key: "first",
    value: function first() {
      this.index = 0;
      return this.render();
    }
  }, {
    key: "last",
    value: function last() {
      this.index = this.visible.length - 1;
      return this.render();
    }
  }, {
    key: "prev",
    value: function prev() {
      if (this.visible.length <= 1) return this.alert();
      return this.up();
    }
  }, {
    key: "next",
    value: function next() {
      if (this.visible.length <= 1) return this.alert();
      return this.down();
    }
  }, {
    key: "right",
    value: function right() {
      if (this.cursor >= this.input.length) return this.alert();
      this.cursor++;
      return this.render();
    }
  }, {
    key: "left",
    value: function left() {
      if (this.cursor <= 0) return this.alert();
      this.cursor--;
      return this.render();
    }
  }, {
    key: "up",
    value: function up() {
      var len = this.choices.length;
      var vis = this.visible.length;
      var idx = this.index;

      if (this.options.scroll === false && idx === 0) {
        return this.alert();
      }

      if (len > vis && idx === 0) {
        return this.scrollUp();
      }

      this.index = (idx - 1 % len + len) % len;

      if (this.isDisabled()) {
        return this.up();
      }

      return this.render();
    }
  }, {
    key: "down",
    value: function down() {
      var len = this.choices.length;
      var vis = this.visible.length;
      var idx = this.index;

      if (this.options.scroll === false && idx === vis - 1) {
        return this.alert();
      }

      if (len > vis && idx === vis - 1) {
        return this.scrollDown();
      }

      this.index = (idx + 1) % len;

      if (this.isDisabled()) {
        return this.down();
      }

      return this.render();
    }
  }, {
    key: "scrollUp",
    value: function scrollUp() {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.choices = _scrollUp(this.choices);
      this.index = i;

      if (this.isDisabled()) {
        return this.up();
      }

      return this.render();
    }
  }, {
    key: "scrollDown",
    value: function scrollDown() {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.visible.length - 1;
      this.choices = _scrollDown(this.choices);
      this.index = i;

      if (this.isDisabled()) {
        return this.down();
      }

      return this.render();
    }
  }, {
    key: "shiftUp",
    value: function () {
      var _shiftUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(this.options.sort === true)) {
                  _context9.next = 7;
                  break;
                }

                this.sorting = true;
                this.swap(this.index - 1);
                _context9.next = 5;
                return this.up();

              case 5:
                this.sorting = false;
                return _context9.abrupt("return");

              case 7:
                return _context9.abrupt("return", this.scrollUp(this.index));

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function shiftUp() {
        return _shiftUp.apply(this, arguments);
      }

      return shiftUp;
    }()
  }, {
    key: "shiftDown",
    value: function () {
      var _shiftDown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!(this.options.sort === true)) {
                  _context10.next = 7;
                  break;
                }

                this.sorting = true;
                this.swap(this.index + 1);
                _context10.next = 5;
                return this.down();

              case 5:
                this.sorting = false;
                return _context10.abrupt("return");

              case 7:
                return _context10.abrupt("return", this.scrollDown(this.index));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function shiftDown() {
        return _shiftDown.apply(this, arguments);
      }

      return shiftDown;
    }()
  }, {
    key: "pageUp",
    value: function pageUp() {
      if (this.visible.length <= 1) return this.alert();
      this.limit = Math.max(this.limit - 1, 0);
      this.index = Math.min(this.limit - 1, this.index);
      this._limit = this.limit;

      if (this.isDisabled()) {
        return this.up();
      }

      return this.render();
    }
  }, {
    key: "pageDown",
    value: function pageDown() {
      if (this.visible.length >= this.choices.length) return this.alert();
      this.index = Math.max(0, this.index);
      this.limit = Math.min(this.limit + 1, this.choices.length);
      this._limit = this.limit;

      if (this.isDisabled()) {
        return this.down();
      }

      return this.render();
    }
  }, {
    key: "swap",
    value: function swap(pos) {
      _swap(this.choices, this.index, pos);
    }
  }, {
    key: "isDisabled",
    value: function isDisabled() {
      var choice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.focused;
      var keys = ['disabled', 'collapsed', 'hidden', 'completing', 'readonly'];

      if (choice && keys.some(function (key) {
        return choice[key] === true;
      })) {
        return true;
      }

      return choice && choice.role === 'heading';
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      var _this6 = this;

      var choice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.focused;
      if (Array.isArray(choice)) return choice.every(function (ch) {
        return _this6.isEnabled(ch);
      });

      if (choice.choices) {
        var choices = choice.choices.filter(function (ch) {
          return !_this6.isDisabled(ch);
        });
        return choice.enabled && choices.every(function (ch) {
          return _this6.isEnabled(ch);
        });
      }

      return choice.enabled && !this.isDisabled(choice);
    }
  }, {
    key: "isChoice",
    value: function isChoice(choice, value) {
      return choice.name === value || choice.index === Number(value);
    }
  }, {
    key: "isSelected",
    value: function isSelected(choice) {
      var _this7 = this;

      if (Array.isArray(this.initial)) {
        return this.initial.some(function (value) {
          return _this7.isChoice(choice, value);
        });
      }

      return this.isChoice(choice, this.initial);
    }
  }, {
    key: "map",
    value: function map() {
      var _this8 = this;

      var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';
      return [].concat(names || []).reduce(function (acc, name) {
        acc[name] = _this8.find(name, prop);
        return acc;
      }, {});
    }
  }, {
    key: "filter",
    value: function filter(value, prop) {
      var isChoice = function isChoice(ele, i) {
        return [ele.name, i].includes(value);
      };

      var fn = typeof value === 'function' ? value : isChoice;
      var choices = this.options.multiple ? this.state._choices : this.choices;
      var result = choices.filter(fn);

      if (prop) {
        return result.map(function (ch) {
          return ch[prop];
        });
      }

      return result;
    }
  }, {
    key: "find",
    value: function find(value, prop) {
      if (isObject(value)) return prop ? value[prop] : value;

      var isChoice = function isChoice(ele, i) {
        return [ele.name, i].includes(value);
      };

      var fn = typeof value === 'function' ? value : isChoice;
      var choice = this.choices.find(fn);

      if (choice) {
        return prop ? choice[prop] : choice;
      }
    }
  }, {
    key: "findIndex",
    value: function findIndex(value) {
      return this.choices.indexOf(this.find(value));
    }
  }, {
    key: "submit",
    value: function () {
      var _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        var choice, _this$options2, reorder, sort, multi, value;

        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                choice = this.focused;

                if (choice) {
                  _context11.next = 3;
                  break;
                }

                return _context11.abrupt("return", this.alert());

              case 3:
                if (!choice.newChoice) {
                  _context11.next = 8;
                  break;
                }

                if (choice.input) {
                  _context11.next = 6;
                  break;
                }

                return _context11.abrupt("return", this.alert());

              case 6:
                choice.updateChoice();
                return _context11.abrupt("return", this.render());

              case 8:
                if (!this.choices.some(function (ch) {
                  return ch.newChoice;
                })) {
                  _context11.next = 10;
                  break;
                }

                return _context11.abrupt("return", this.alert());

              case 10:
                _this$options2 = this.options, reorder = _this$options2.reorder, sort = _this$options2.sort;
                multi = this.multiple === true;
                value = this.selected;

                if (!(value === void 0)) {
                  _context11.next = 15;
                  break;
                }

                return _context11.abrupt("return", this.alert());

              case 15:
                // re-sort choices to original order
                if (Array.isArray(value) && reorder !== false && sort !== true) {
                  value = utils.reorder(value);
                }

                this.value = multi ? value.map(function (ch) {
                  return ch.name;
                }) : value.name;
                return _context11.abrupt("return", _get(_getPrototypeOf(ArrayPrompt.prototype), "submit", this).call(this));

              case 18:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function submit() {
        return _submit.apply(this, arguments);
      }

      return submit;
    }()
  }, {
    key: "choices",
    get: function get() {
      return reset(this, this.state.choices || []);
    },
    set: function set(choices) {
      var _this9 = this;

      if (choices === void 0) {
        choices = [];
      }

      this.state._choices = this.state._choices || [];
      this.state.choices = choices;

      var _iterator = _createForOfIteratorHelper(choices),
          _step;

      try {
        var _loop = function _loop() {
          var choice = _step.value;

          if (!_this9.state._choices.some(function (ch) {
            return ch.name === choice.name;
          })) {
            _this9.state._choices.push(choice);
          }
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (!this._initial && this.options.initial) {
        this._initial = true;
        var init = this.initial;

        if (typeof init === 'string' || typeof init === 'number') {
          var choice = this.find(init);

          if (choice) {
            this.initial = choice.index;
            this.focus(choice, true);
          }
        }
      }
    }
  }, {
    key: "visible",
    get: function get() {
      return (this.state.visible || this.choices).slice(0, this.limit);
    },
    set: function set(visible) {
      this.state.visible = visible;
    }
  }, {
    key: "limit",
    get: function get() {
      var state = this.state,
          options = this.options,
          choices = this.choices;
      var limit = state.limit || this._limit || options.limit || choices.length;
      return Math.min(limit, this.height);
    },
    set: function set(num) {
      this.state.limit = num;
    }
  }, {
    key: "value",
    get: function get() {
      if (typeof _get(_getPrototypeOf(ArrayPrompt.prototype), "value", this) !== 'string' && _get(_getPrototypeOf(ArrayPrompt.prototype), "value", this) === this.initial) {
        return this.input;
      }

      return _get(_getPrototypeOf(ArrayPrompt.prototype), "value", this);
    },
    set: function set(value) {
      _set(_getPrototypeOf(ArrayPrompt.prototype), "value", value, this, true);
    }
  }, {
    key: "index",
    get: function get() {
      return Math.max(0, this.state ? this.state.index : 0);
    },
    set: function set(i) {
      this.state.index = i;
    }
  }, {
    key: "enabled",
    get: function get() {
      return this.filter(this.isEnabled.bind(this));
    }
  }, {
    key: "focused",
    get: function get() {
      var choice = this.choices[this.index];

      if (choice && this.state.submitted && this.multiple !== true) {
        choice.enabled = true;
      }

      return choice;
    }
  }, {
    key: "selectable",
    get: function get() {
      var _this10 = this;

      return this.choices.filter(function (choice) {
        return !_this10.isDisabled(choice);
      });
    }
  }, {
    key: "selected",
    get: function get() {
      return this.multiple ? this.enabled : this.focused;
    }
  }]);

  return ArrayPrompt;
}(Prompt);

function reset(prompt, choices) {
  if (choices instanceof Promise) return choices;

  if (typeof choices === 'function') {
    if (utils.isAsyncFn(choices)) return choices;
    choices = choices.call(prompt, prompt);
  }

  var _iterator2 = _createForOfIteratorHelper(choices),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var choice = _step2.value;

      if (Array.isArray(choice.choices)) {
        var items = choice.choices.filter(function (ch) {
          return !prompt.isDisabled(ch);
        });
        choice.enabled = items.every(function (ch) {
          return ch.enabled === true;
        });
      }

      if (prompt.isDisabled(choice) === true) {
        delete choice.enabled;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return choices;
}

module.exports = ArrayPrompt;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/set":122,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"ansi-colors":42,"../prompt":20,"../roles":123,"../utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/types/auth.js
      68: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var FormPrompt = require('../prompts/form');

var defaultAuthenticate = function defaultAuthenticate() {
  throw new Error('expected prompt to have a custom authenticate method');
};

var factory = function factory() {
  var authenticate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultAuthenticate;

  var AuthPrompt = /*#__PURE__*/function (_FormPrompt) {
    _inherits(AuthPrompt, _FormPrompt);

    var _super = _createSuper(AuthPrompt);

    function AuthPrompt(options) {
      _classCallCheck(this, AuthPrompt);

      return _super.call(this, options);
    }

    _createClass(AuthPrompt, [{
      key: "submit",
      value: function () {
        var _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return authenticate.call(this, this.values, this.state);

                case 2:
                  this.value = _context.sent;

                  _get(_getPrototypeOf(AuthPrompt.prototype), "base", this).submit.call(this);

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function submit() {
          return _submit.apply(this, arguments);
        }

        return submit;
      }()
    }], [{
      key: "create",
      value: function create(authenticate) {
        return factory(authenticate);
      }
    }]);

    return AuthPrompt;
  }(FormPrompt);

  return AuthPrompt;
};

module.exports = factory();
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../prompts/form":52}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/types/boolean.js
      69: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _set = require("@babel/runtime/helpers/set");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Prompt = require('../prompt');

var _require = require('../utils'),
    isPrimitive = _require.isPrimitive,
    hasColor = _require.hasColor;

var BooleanPrompt = /*#__PURE__*/function (_Prompt) {
  _inherits(BooleanPrompt, _Prompt);

  var _super = _createSuper(BooleanPrompt);

  function BooleanPrompt(options) {
    var _this;

    _classCallCheck(this, BooleanPrompt);

    _this = _super.call(this, options);

    _this.cursorHide();

    return _this;
  }

  _createClass(BooleanPrompt, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var initial;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.resolve(this.initial, this.state);

              case 2:
                initial = _context.sent;
                _context.next = 5;
                return this.cast(initial);

              case 5:
                this.input = _context.sent;
                _context.next = 8;
                return _get(_getPrototypeOf(BooleanPrompt.prototype), "initialize", this).call(this);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initialize() {
        return _initialize.apply(this, arguments);
      }

      return initialize;
    }()
  }, {
    key: "dispatch",
    value: function dispatch(ch) {
      if (!this.isValue(ch)) return this.alert();
      this.input = ch;
      return this.submit();
    }
  }, {
    key: "format",
    value: function format(value) {
      var styles = this.styles,
          state = this.state;
      return !state.submitted ? styles.primary(value) : styles.success(value);
    }
  }, {
    key: "cast",
    value: function cast(input) {
      return this.isTrue(input);
    }
  }, {
    key: "isTrue",
    value: function isTrue(input) {
      return /^[ty1]/i.test(input);
    }
  }, {
    key: "isFalse",
    value: function isFalse(input) {
      return /^[fn0]/i.test(input);
    }
  }, {
    key: "isValue",
    value: function isValue(value) {
      return isPrimitive(value) && (this.isTrue(value) || this.isFalse(value));
    }
  }, {
    key: "hint",
    value: function () {
      var _hint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _hint2;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this.state.status === 'pending')) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 3;
                return this.element('hint');

              case 3:
                _hint2 = _context2.sent;

                if (hasColor(_hint2)) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", this.styles.muted(_hint2));

              case 6:
                return _context2.abrupt("return", _hint2);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function hint() {
        return _hint.apply(this, arguments);
      }

      return hint;
    }()
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this$state, input, size, prefix, sep, msg, hint, promptLine, header, value, output, help, footer;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _this$state = this.state, input = _this$state.input, size = _this$state.size;
                _context3.next = 3;
                return this.prefix();

              case 3:
                prefix = _context3.sent;
                _context3.next = 6;
                return this.separator();

              case 6:
                sep = _context3.sent;
                _context3.next = 9;
                return this.message();

              case 9:
                msg = _context3.sent;
                hint = this.styles.muted(this["default"]);
                promptLine = [prefix, msg, hint, sep].filter(Boolean).join(' ');
                this.state.prompt = promptLine;
                _context3.next = 15;
                return this.header();

              case 15:
                header = _context3.sent;
                value = this.value = this.cast(input);
                _context3.next = 19;
                return this.format(value);

              case 19:
                output = _context3.sent;
                _context3.next = 22;
                return this.error();

              case 22:
                _context3.t0 = _context3.sent;

                if (_context3.t0) {
                  _context3.next = 27;
                  break;
                }

                _context3.next = 26;
                return this.hint();

              case 26:
                _context3.t0 = _context3.sent;

              case 27:
                help = _context3.t0;
                _context3.next = 30;
                return this.footer();

              case 30:
                footer = _context3.sent;
                if (help && !promptLine.includes(help)) output += ' ' + help;
                promptLine += ' ' + output;
                this.clear(size);
                this.write([header, promptLine, footer].filter(Boolean).join('\n'));
                this.restore();

              case 36:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }, {
    key: "value",
    get: function get() {
      return this.cast(_get(_getPrototypeOf(BooleanPrompt.prototype), "value", this));
    },
    set: function set(value) {
      _set(_getPrototypeOf(BooleanPrompt.prototype), "value", value, this, true);
    }
  }]);

  return BooleanPrompt;
}(Prompt);

module.exports = BooleanPrompt;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/set":122,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../prompt":20,"../utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/types/number.js
      70: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var StringPrompt = require('./string');

var NumberPrompt = /*#__PURE__*/function (_StringPrompt) {
  _inherits(NumberPrompt, _StringPrompt);

  var _super = _createSuper(NumberPrompt);

  function NumberPrompt() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NumberPrompt);

    _this = _super.call(this, _objectSpread({
      style: 'number'
    }, options));
    _this.min = _this.isValue(options.min) ? _this.toNumber(options.min) : -Infinity;
    _this.max = _this.isValue(options.max) ? _this.toNumber(options.max) : Infinity;
    _this.delay = options.delay != null ? options.delay : 1000;
    _this["float"] = options["float"] !== false;
    _this.round = options.round === true || options["float"] === false;
    _this.major = options.major || 10;
    _this.minor = options.minor || 1;
    _this.initial = options.initial != null ? options.initial : '';
    _this.input = String(_this.initial);
    _this.cursor = _this.input.length;

    _this.cursorShow();

    return _this;
  }

  _createClass(NumberPrompt, [{
    key: "append",
    value: function append(ch) {
      if (!/[-+.]/.test(ch) || ch === '.' && this.input.includes('.')) {
        return this.alert('invalid number');
      }

      return _get(_getPrototypeOf(NumberPrompt.prototype), "append", this).call(this, ch);
    }
  }, {
    key: "number",
    value: function number(ch) {
      return _get(_getPrototypeOf(NumberPrompt.prototype), "append", this).call(this, ch);
    }
  }, {
    key: "next",
    value: function next() {
      if (this.input && this.input !== this.initial) return this.alert();
      if (!this.isValue(this.initial)) return this.alert();
      this.input = this.initial;
      this.cursor = String(this.initial).length;
      return this.render();
    }
  }, {
    key: "up",
    value: function up(number) {
      var step = number || this.minor;
      var num = this.toNumber(this.input);
      if (num > this.max + step) return this.alert();
      this.input = "".concat(num + step);
      return this.render();
    }
  }, {
    key: "down",
    value: function down(number) {
      var step = number || this.minor;
      var num = this.toNumber(this.input);
      if (num < this.min - step) return this.alert();
      this.input = "".concat(num - step);
      return this.render();
    }
  }, {
    key: "shiftDown",
    value: function shiftDown() {
      return this.down(this.major);
    }
  }, {
    key: "shiftUp",
    value: function shiftUp() {
      return this.up(this.major);
    }
  }, {
    key: "format",
    value: function format() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.input;

      if (typeof this.options.format === 'function') {
        return this.options.format.call(this, input);
      }

      return this.styles.info(input);
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return this["float"] ? +value : Math.round(+value);
    }
  }, {
    key: "isValue",
    value: function isValue(value) {
      return /^[-+]?[0-9]+((\.)|(\.[0-9]+))?$/.test(value);
    }
  }, {
    key: "submit",
    value: function submit() {
      var _this2 = this;

      var value = [this.input, this.initial].find(function (v) {
        return _this2.isValue(v);
      });
      this.value = this.toNumber(value || 0);
      return _get(_getPrototypeOf(NumberPrompt.prototype), "submit", this).call(this);
    }
  }]);

  return NumberPrompt;
}(StringPrompt);

module.exports = NumberPrompt;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"./string":71}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/types/string.js
      71: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _get = require("@babel/runtime/helpers/get");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Prompt = require('../prompt');

var placeholder = require('../placeholder');

var _require = require('../utils'),
    isPrimitive = _require.isPrimitive;

var StringPrompt = /*#__PURE__*/function (_Prompt) {
  _inherits(StringPrompt, _Prompt);

  var _super = _createSuper(StringPrompt);

  function StringPrompt(options) {
    var _this;

    _classCallCheck(this, StringPrompt);

    _this = _super.call(this, options);
    _this.initial = isPrimitive(_this.initial) ? String(_this.initial) : '';
    if (_this.initial) _this.cursorHide();
    _this.state.prevCursor = 0;
    _this.state.clipboard = [];
    return _this;
  }

  _createClass(StringPrompt, [{
    key: "keypress",
    value: function () {
      var _keypress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input) {
        var key,
            prev,
            _args = arguments;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                key = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                prev = this.state.prevKeypress;
                this.state.prevKeypress = key;

                if (!(this.options.multiline === true && key.name === 'return')) {
                  _context.next = 6;
                  break;
                }

                if (!(!prev || prev.name !== 'return')) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", this.append('\n', key));

              case 6:
                return _context.abrupt("return", _get(_getPrototypeOf(StringPrompt.prototype), "keypress", this).call(this, input, key));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function keypress(_x) {
        return _keypress.apply(this, arguments);
      }

      return keypress;
    }()
  }, {
    key: "moveCursor",
    value: function moveCursor(n) {
      this.cursor += n;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.input = this.value = '';
      this.cursor = 0;
      return this.render();
    }
  }, {
    key: "dispatch",
    value: function dispatch(ch, key) {
      if (!ch || key.ctrl || key.code) return this.alert();
      this.append(ch);
    }
  }, {
    key: "append",
    value: function append(ch) {
      var _this$state = this.state,
          cursor = _this$state.cursor,
          input = _this$state.input;
      this.input = "".concat(input).slice(0, cursor) + ch + "".concat(input).slice(cursor);
      this.moveCursor(String(ch).length);
      this.render();
    }
  }, {
    key: "insert",
    value: function insert(str) {
      this.append(str);
    }
  }, {
    key: "delete",
    value: function _delete() {
      var _this$state2 = this.state,
          cursor = _this$state2.cursor,
          input = _this$state2.input;
      if (cursor <= 0) return this.alert();
      this.input = "".concat(input).slice(0, cursor - 1) + "".concat(input).slice(cursor);
      this.moveCursor(-1);
      this.render();
    }
  }, {
    key: "deleteForward",
    value: function deleteForward() {
      var _this$state3 = this.state,
          cursor = _this$state3.cursor,
          input = _this$state3.input;
      if (input[cursor] === void 0) return this.alert();
      this.input = "".concat(input).slice(0, cursor) + "".concat(input).slice(cursor + 1);
      this.render();
    }
  }, {
    key: "cutForward",
    value: function cutForward() {
      var pos = this.cursor;
      if (this.input.length <= pos) return this.alert();
      this.state.clipboard.push(this.input.slice(pos));
      this.input = this.input.slice(0, pos);
      this.render();
    }
  }, {
    key: "cutLeft",
    value: function cutLeft() {
      var pos = this.cursor;
      if (pos === 0) return this.alert();
      var before = this.input.slice(0, pos);
      var after = this.input.slice(pos);
      var words = before.split(' ');
      this.state.clipboard.push(words.pop());
      this.input = words.join(' ');
      this.cursor = this.input.length;
      this.input += after;
      this.render();
    }
  }, {
    key: "paste",
    value: function paste() {
      if (!this.state.clipboard.length) return this.alert();
      this.insert(this.state.clipboard.pop());
      this.render();
    }
  }, {
    key: "toggleCursor",
    value: function toggleCursor() {
      if (this.state.prevCursor) {
        this.cursor = this.state.prevCursor;
        this.state.prevCursor = 0;
      } else {
        this.state.prevCursor = this.cursor;
        this.cursor = 0;
      }

      this.render();
    }
  }, {
    key: "first",
    value: function first() {
      this.cursor = 0;
      this.render();
    }
  }, {
    key: "last",
    value: function last() {
      this.cursor = this.input.length - 1;
      this.render();
    }
  }, {
    key: "next",
    value: function next() {
      var init = this.initial != null ? String(this.initial) : '';
      if (!init || !init.startsWith(this.input)) return this.alert();
      this.input = this.initial;
      this.cursor = this.initial.length;
      this.render();
    }
  }, {
    key: "prev",
    value: function prev() {
      if (!this.input) return this.alert();
      this.reset();
    }
  }, {
    key: "backward",
    value: function backward() {
      return this.left();
    }
  }, {
    key: "forward",
    value: function forward() {
      return this.right();
    }
  }, {
    key: "right",
    value: function right() {
      if (this.cursor >= this.input.length) return this.alert();
      this.moveCursor(1);
      return this.render();
    }
  }, {
    key: "left",
    value: function left() {
      if (this.cursor <= 0) return this.alert();
      this.moveCursor(-1);
      return this.render();
    }
  }, {
    key: "isValue",
    value: function isValue(value) {
      return !!value;
    }
  }, {
    key: "format",
    value: function () {
      var _format = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var input,
            initial,
            _args2 = arguments;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                input = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : this.value;
                _context2.next = 3;
                return this.resolve(this.initial, this.state);

              case 3:
                initial = _context2.sent;

                if (this.state.submitted) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", placeholder(this, {
                  input: input,
                  initial: initial,
                  pos: this.cursor
                }));

              case 6:
                return _context2.abrupt("return", this.styles.submitted(input || initial));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function format() {
        return _format.apply(this, arguments);
      }

      return format;
    }()
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var size, prefix, separator, message, prompt, header, output, help, footer;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                size = this.state.size;
                _context3.next = 3;
                return this.prefix();

              case 3:
                prefix = _context3.sent;
                _context3.next = 6;
                return this.separator();

              case 6:
                separator = _context3.sent;
                _context3.next = 9;
                return this.message();

              case 9:
                message = _context3.sent;
                prompt = [prefix, message, separator].filter(Boolean).join(' ');
                this.state.prompt = prompt;
                _context3.next = 14;
                return this.header();

              case 14:
                header = _context3.sent;
                _context3.next = 17;
                return this.format();

              case 17:
                output = _context3.sent;
                _context3.next = 20;
                return this.error();

              case 20:
                _context3.t0 = _context3.sent;

                if (_context3.t0) {
                  _context3.next = 25;
                  break;
                }

                _context3.next = 24;
                return this.hint();

              case 24:
                _context3.t0 = _context3.sent;

              case 25:
                help = _context3.t0;
                _context3.next = 28;
                return this.footer();

              case 28:
                footer = _context3.sent;
                if (help && !output.includes(help)) output += ' ' + help;
                prompt += ' ' + output;
                this.clear(size);
                this.write([header, prompt, footer].filter(Boolean).join('\n'));
                this.restore();

              case 34:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function render() {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }]);

  return StringPrompt;
}(Prompt);

module.exports = StringPrompt;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/get":117,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"../prompt":20,"../placeholder":118,"../utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/execa/index.js
      72: {
        factory: (module, exports, require) => {
          'use strict';

var path = require('path');

var childProcess = require('child_process');

var crossSpawn = require('cross-spawn');

var stripEof = require('strip-eof');

var npmRunPath = require('npm-run-path');

var isStream = require('is-stream');

var _getStream = require('get-stream');

var pFinally = require('p-finally');

var onExit = require('signal-exit');

var errname = require('./lib/errname');

var stdio = require('./lib/stdio');

var TEN_MEGABYTES = 1000 * 1000 * 10;

function handleArgs(cmd, args, opts) {
  var parsed;
  opts = Object.assign({
    extendEnv: true,
    env: {}
  }, opts);

  if (opts.extendEnv) {
    opts.env = Object.assign({}, process.env, opts.env);
  }

  if (opts.__winShell === true) {
    delete opts.__winShell;
    parsed = {
      command: cmd,
      args: args,
      options: opts,
      file: cmd,
      original: {
        cmd: cmd,
        args: args
      }
    };
  } else {
    parsed = crossSpawn._parse(cmd, args, opts);
  }

  opts = Object.assign({
    maxBuffer: TEN_MEGABYTES,
    buffer: true,
    stripEof: true,
    preferLocal: true,
    localDir: parsed.options.cwd || process.cwd(),
    encoding: 'utf8',
    reject: true,
    cleanup: true
  }, parsed.options);
  opts.stdio = stdio(opts);

  if (opts.preferLocal) {
    opts.env = npmRunPath.env(Object.assign({}, opts, {
      cwd: opts.localDir
    }));
  }

  if (opts.detached) {
    // #115
    opts.cleanup = false;
  }

  if (process.platform === 'win32' && path.basename(parsed.command) === 'cmd.exe') {
    // #116
    parsed.args.unshift('/q');
  }

  return {
    cmd: parsed.command,
    args: parsed.args,
    opts: opts,
    parsed: parsed
  };
}

function handleInput(spawned, input) {
  if (input === null || input === undefined) {
    return;
  }

  if (isStream(input)) {
    input.pipe(spawned.stdin);
  } else {
    spawned.stdin.end(input);
  }
}

function handleOutput(opts, val) {
  if (val && opts.stripEof) {
    val = stripEof(val);
  }

  return val;
}

function handleShell(fn, cmd, opts) {
  var file = '/bin/sh';
  var args = ['-c', cmd];
  opts = Object.assign({}, opts);

  if (process.platform === 'win32') {
    opts.__winShell = true;
    file = process.env.comspec || 'cmd.exe';
    args = ['/s', '/c', "\"".concat(cmd, "\"")];
    opts.windowsVerbatimArguments = true;
  }

  if (opts.shell) {
    file = opts.shell;
    delete opts.shell;
  }

  return fn(file, args, opts);
}

function getStream(process, stream, _ref) {
  var encoding = _ref.encoding,
      buffer = _ref.buffer,
      maxBuffer = _ref.maxBuffer;

  if (!process[stream]) {
    return null;
  }

  var ret;

  if (!buffer) {
    // TODO: Use `ret = util.promisify(stream.finished)(process[stream]);` when targeting Node.js 10
    ret = new Promise(function (resolve, reject) {
      process[stream].once('end', resolve).once('error', reject);
    });
  } else if (encoding) {
    ret = _getStream(process[stream], {
      encoding: encoding,
      maxBuffer: maxBuffer
    });
  } else {
    ret = _getStream.buffer(process[stream], {
      maxBuffer: maxBuffer
    });
  }

  return ret["catch"](function (err) {
    err.stream = stream;
    err.message = "".concat(stream, " ").concat(err.message);
    throw err;
  });
}

function makeError(result, options) {
  var stdout = result.stdout,
      stderr = result.stderr;
  var err = result.error;
  var code = result.code,
      signal = result.signal;
  var parsed = options.parsed,
      joinedCmd = options.joinedCmd;
  var timedOut = options.timedOut || false;

  if (!err) {
    var output = '';

    if (Array.isArray(parsed.opts.stdio)) {
      if (parsed.opts.stdio[2] !== 'inherit') {
        output += output.length > 0 ? stderr : "\n".concat(stderr);
      }

      if (parsed.opts.stdio[1] !== 'inherit') {
        output += "\n".concat(stdout);
      }
    } else if (parsed.opts.stdio !== 'inherit') {
      output = "\n".concat(stderr).concat(stdout);
    }

    err = new Error("Command failed: ".concat(joinedCmd).concat(output));
    err.code = code < 0 ? errname(code) : code;
  }

  err.stdout = stdout;
  err.stderr = stderr;
  err.failed = true;
  err.signal = signal || null;
  err.cmd = joinedCmd;
  err.timedOut = timedOut;
  return err;
}

function joinCmd(cmd, args) {
  var joinedCmd = cmd;

  if (Array.isArray(args) && args.length > 0) {
    joinedCmd += ' ' + args.join(' ');
  }

  return joinedCmd;
}

module.exports = function (cmd, args, opts) {
  var parsed = handleArgs(cmd, args, opts);
  var _parsed$opts = parsed.opts,
      encoding = _parsed$opts.encoding,
      buffer = _parsed$opts.buffer,
      maxBuffer = _parsed$opts.maxBuffer;
  var joinedCmd = joinCmd(cmd, args);
  var spawned;

  try {
    spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
  } catch (err) {
    return Promise.reject(err);
  }

  var removeExitHandler;

  if (parsed.opts.cleanup) {
    removeExitHandler = onExit(function () {
      spawned.kill();
    });
  }

  var timeoutId = null;
  var timedOut = false;

  var cleanup = function cleanup() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }

    if (removeExitHandler) {
      removeExitHandler();
    }
  };

  if (parsed.opts.timeout > 0) {
    timeoutId = setTimeout(function () {
      timeoutId = null;
      timedOut = true;
      spawned.kill(parsed.opts.killSignal);
    }, parsed.opts.timeout);
  }

  var processDone = new Promise(function (resolve) {
    spawned.on('exit', function (code, signal) {
      cleanup();
      resolve({
        code: code,
        signal: signal
      });
    });
    spawned.on('error', function (err) {
      cleanup();
      resolve({
        error: err
      });
    });

    if (spawned.stdin) {
      spawned.stdin.on('error', function (err) {
        cleanup();
        resolve({
          error: err
        });
      });
    }
  });

  function destroy() {
    if (spawned.stdout) {
      spawned.stdout.destroy();
    }

    if (spawned.stderr) {
      spawned.stderr.destroy();
    }
  }

  var handlePromise = function handlePromise() {
    return pFinally(Promise.all([processDone, getStream(spawned, 'stdout', {
      encoding: encoding,
      buffer: buffer,
      maxBuffer: maxBuffer
    }), getStream(spawned, 'stderr', {
      encoding: encoding,
      buffer: buffer,
      maxBuffer: maxBuffer
    })]).then(function (arr) {
      var result = arr[0];
      result.stdout = arr[1];
      result.stderr = arr[2];

      if (result.error || result.code !== 0 || result.signal !== null) {
        var err = makeError(result, {
          joinedCmd: joinedCmd,
          parsed: parsed,
          timedOut: timedOut
        }); // TODO: missing some timeout logic for killed
        // https://github.com/nodejs/node/blob/master/lib/child_process.js#L203
        // err.killed = spawned.killed || killed;

        err.killed = err.killed || spawned.killed;

        if (!parsed.opts.reject) {
          return err;
        }

        throw err;
      }

      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: false,
        killed: false,
        signal: null,
        cmd: joinedCmd,
        timedOut: false
      };
    }), destroy);
  };

  crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

  handleInput(spawned, parsed.opts.input);

  spawned.then = function (onfulfilled, onrejected) {
    return handlePromise().then(onfulfilled, onrejected);
  };

  spawned["catch"] = function (onrejected) {
    return handlePromise()["catch"](onrejected);
  };

  return spawned;
}; // TODO: set `stderr: 'ignore'` when that option is implemented


module.exports.stdout = function () {
  var _module;

  return (_module = module).exports.apply(_module, arguments).then(function (x) {
    return x.stdout;
  });
}; // TODO: set `stdout: 'ignore'` when that option is implemented


module.exports.stderr = function () {
  var _module2;

  return (_module2 = module).exports.apply(_module2, arguments).then(function (x) {
    return x.stderr;
  });
};

module.exports.shell = function (cmd, opts) {
  return handleShell(module.exports, cmd, opts);
};

module.exports.sync = function (cmd, args, opts) {
  var parsed = handleArgs(cmd, args, opts);
  var joinedCmd = joinCmd(cmd, args);

  if (isStream(parsed.opts.input)) {
    throw new TypeError('The `input` option cannot be a stream in sync mode');
  }

  var result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
  result.code = result.status;

  if (result.error || result.status !== 0 || result.signal !== null) {
    var err = makeError(result, {
      joinedCmd: joinedCmd,
      parsed: parsed
    });

    if (!parsed.opts.reject) {
      return err;
    }

    throw err;
  }

  return {
    stdout: handleOutput(parsed.opts, result.stdout),
    stderr: handleOutput(parsed.opts, result.stderr),
    code: 0,
    failed: false,
    signal: null,
    cmd: joinedCmd,
    timedOut: false
  };
};

module.exports.shellSync = function (cmd, opts) {
  return handleShell(module.exports.sync, cmd, opts);
};
        },
        map: {"path":-19260817,"child_process":-19260817,"cross-spawn":124,"strip-eof":125,"npm-run-path":126,"is-stream":127,"get-stream":128,"p-finally":129,"signal-exit":130,"./lib/errname":131,"./lib/stdio":132}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/arch/index.js
      73: {
        factory: (module, exports, require) => {
          /*! arch. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var cp = require('child_process');

var fs = require('fs');

var path = require('path');
/**
 * Returns the operating system's CPU architecture. This is different than
 * `process.arch` or `os.arch()` which returns the architecture the Node.js (or
 * Electron) binary was compiled for.
 */


module.exports = function arch() {
  /**
   * The running binary is 64-bit, so the OS is clearly 64-bit.
   */
  if (process.arch === 'x64') {
    return 'x64';
  }
  /**
   * All recent versions of Mac OS are 64-bit.
   */


  if (process.platform === 'darwin') {
    return 'x64';
  }
  /**
   * On Windows, the most reliable way to detect a 64-bit OS from within a 32-bit
   * app is based on the presence of a WOW64 file: %SystemRoot%\SysNative.
   * See: https://twitter.com/feross/status/776949077208510464
   */


  if (process.platform === 'win32') {
    var useEnv = false;

    try {
      useEnv = !!(process.env.SYSTEMROOT && fs.statSync(process.env.SYSTEMROOT));
    } catch (err) {}

    var sysRoot = useEnv ? process.env.SYSTEMROOT : 'C:\\Windows'; // If %SystemRoot%\SysNative exists, we are in a WOW64 FS Redirected application.

    var isWOW64 = false;

    try {
      isWOW64 = !!fs.statSync(path.join(sysRoot, 'sysnative'));
    } catch (err) {}

    return isWOW64 ? 'x64' : 'x86';
  }
  /**
   * On Linux, use the `getconf` command to get the architecture.
   */


  if (process.platform === 'linux') {
    var output = cp.execSync('getconf LONG_BIT', {
      encoding: 'utf8'
    });
    return output === '64\n' ? 'x64' : 'x86';
  }
  /**
   * If none of the above, assume the architecture is 32-bit.
   */


  return 'x86';
};
        },
        map: {"child_process":-19260817,"fs":-19260817,"path":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/ansible.js
      74: {
        factory: (module, exports, require) => {
          var util = require('../util');

var nunjucks = require('nunjucks');

var querystring = require('query-string');

var ansibleTemplate = require('../templates/ansible.js');

function getDataString(request) {
  var parsedQueryString = querystring.parse(request.data, {
    sort: false
  });
  var keyCount = Object.keys(parsedQueryString).length;
  var singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]];
  var singularData = request.isDataBinary || singleKeyOnly;

  if (singularData) {
    return JSON.parse(request.data);
  } else {
    return request.data;
  }
}

var toAnsible = function toAnsible(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var convertedData;

  if (typeof request.data === 'string' || typeof request.data === 'number') {
    convertedData = getDataString(request);
  }

  var result = nunjucks.renderString(ansibleTemplate, {
    request: request,
    data: convertedData
  });
  return result;
};

module.exports = toAnsible;
        },
        map: {"../util":133,"nunjucks":134,"query-string":135,"../templates/ansible.js":136}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/dart.js
      75: {
        factory: (module, exports, require) => {
          var util = require('../util');

var jsesc = require('jsesc');

function repr(value) {
  // In context of url parameters, don't accept nulls and such.
  if (!value) {
    return "''";
  } else {
    return "'" + jsesc(value, {
      quotes: 'single'
    }) + "'";
  }
}

var toDart = function toDart(curlCommand) {
  var r = util.parseCurlCommand(curlCommand);
  var s = '';
  if (r.auth || r.isDataBinary) s += "import 'dart:convert';\n";
  s += "import 'package:http/http.dart' as http;\n" + '\n' + 'void main() async {\n';

  if (r.auth) {
    var splitAuth = r.auth.split(':');
    var uname = splitAuth[0] || '';
    var pword = splitAuth[1] || '';
    s += "  var uname = '" + uname + "';\n" + "  var pword = '" + pword + "';\n" + "  var authn = 'Basic ' + base64Encode(utf8.encode('$uname:$pword'));\n" + '\n';
  }

  var hasHeaders = r.headers || r.cookies || r.compressed || r.isDataBinary || r.method === 'put';

  if (hasHeaders) {
    s += '  var headers = {\n';

    for (var hname in r.headers) {
      s += "    '" + hname + "': '" + r.headers[hname] + "',\n";
    }

    if (r.cookies) {
      var cookiestr = util.serializeCookies(r.cookies);
      s += "    'Cookie': '" + cookiestr + "',\n";
    }

    if (r.auth) s += "    'Authorization': authn,\n";
    if (r.compressed) s += "    'Accept-Encoding': 'gzip',\n";

    if (!hasHeaders['Content-Type'] && (r.isDataBinary || r.method === 'put')) {
      s += "    'Content-Type': 'application/x-www-form-urlencoded',\n";
    }

    s += '  };\n';
    s += '\n';
  }

  var hasQuery = r.query;

  if (hasQuery) {
    s += '  var params = {\n';

    for (var paramName in r.query) {
      var rawValue = r.query[paramName];
      var paramValue = void 0;

      if (Array.isArray(rawValue)) {
        paramValue = '[' + rawValue.map(repr).join(', ') + ']';
      } else {
        paramValue = repr(rawValue);
      }

      s += '    ' + repr(paramName) + ': ' + paramValue + ',\n';
    }

    s += '  };\n';
    /* eslint-disable no-template-curly-in-string */

    s += "  var query = params.entries.map((p) => '${p.key}=${p.value}').join('&');\n";
    s += '\n';
  }

  if (r.data === true) {
    r.data = '';
  }

  var hasData = r.data;

  if (typeof r.data === 'number') {
    r.data = r.data.toString();
  }

  if (hasData) {
    // escape single quotes if there're not already escaped
    if (r.data.indexOf("'") !== -1 && r.data.indexOf("\\'") === -1) r.data = jsesc(r.data);

    if (r.dataArray) {
      s += '  var data = {\n';

      for (var i = 0; i !== r.dataArray.length; ++i) {
        var kv = r.dataArray[i];
        var splitKv = kv.replace(/\\"/g, '"').split('=');
        var key = splitKv[0] || '';
        var val = splitKv[1] || '';
        s += "    '" + key + "': '" + val + "',\n";
      }

      s += '  };\n';
      s += '\n';
    } else if (r.isDataBinary) {
      s += "  var data = utf8.encode('".concat(r.data, "');\n\n");
    } else {
      s += "  var data = '".concat(r.data, "';\n\n");
    }
  }

  if (hasQuery) {
    s += '  var res = await http.' + r.method + "('" + r.urlWithoutQuery + "?$query'";
  } else {
    s += '  var res = await http.' + r.method + "('" + r.url + "'";
  }

  if (hasHeaders) s += ', headers: headers';else if (r.auth) s += ", headers: {'Authorization': authn}";
  if (hasData) s += ', body: data';
  /* eslint-disable no-template-curly-in-string */

  s += ');\n' + "  if (res.statusCode != 200) throw Exception('http." + r.method + " error: statusCode= ${res.statusCode}');\n" + '  print(res.body);\n' + '}';
  return s + '\n';
};

module.exports = toDart;
        },
        map: {"../util":133,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/elixir.js
      76: {
        factory: (module, exports, require) => {
          var util = require('../util');

var jsesc = require('jsesc');

var querystring = require('query-string');

require('string.prototype.startswith');

function repr(value) {
  // In context of url parameters, don't accept nulls and such.
  if (!value) {
    return '""';
  } else {
    return "~s|".concat(jsesc(value, {
      quotes: 'backticks'
    }), "|");
  }
}

function getCookies(request) {
  if (!request.cookies) {
    return '';
  }

  var cookies = [];

  for (var cookieName in request.cookies) {
    cookies.push("".concat(cookieName, "=").concat(request.cookies[cookieName]));
  }

  return "cookies: [~s|".concat(cookies.join('; '), "|]");
}

function getOptions(request) {
  var hackneyOptions = [];
  var auth = getBasicAuth(request);

  if (auth) {
    hackneyOptions.push(auth);
  }

  if (request.insecure) {
    hackneyOptions.push(':insecure');
  }

  var cookies = getCookies(request);

  if (cookies) {
    hackneyOptions.push(cookies);
  }

  var hackneyOptionsString = '';

  if (hackneyOptions.length) {
    hackneyOptionsString = "hackney: [".concat(hackneyOptions.join(', '), "]");
  }

  return "[".concat(hackneyOptionsString, "]");
}

function getBasicAuth(request) {
  if (!request.auth) {
    return '';
  }

  var splitAuth = request.auth.split(':');
  var user = splitAuth[0] || '';
  var password = splitAuth[1] || '';
  return "basic_auth: {".concat(repr(user), ", ").concat(repr(password), "}");
}

function getQueryDict(request) {
  if (!request.query) {
    return '[]';
  }

  var queryDict = '[\n';

  for (var paramName in request.query) {
    var rawValue = request.query[paramName];
    var paramValue;

    if (Array.isArray(rawValue)) {
      paramValue = '[' + rawValue.map(repr).join(', ') + ']';
    } else {
      paramValue = repr(rawValue);
    }

    queryDict += "    {".concat(repr(paramName), ", ").concat(paramValue, "},\n");
  }

  queryDict += '  ]';
  return queryDict;
}

function getHeadersDict(request) {
  if (!request.headers) {
    return '[]';
  }

  var dict = '[\n';

  for (var headerName in request.headers) {
    dict += "    {".concat(repr(headerName), ", ").concat(repr(request.headers[headerName]), "},\n");
  }

  dict += '  ]';
  return dict;
}

function getBody(request) {
  var formData = getFormDataString(request);

  if (formData) {
    return formData;
  }

  return '""';
}

function getFormDataString(request) {
  if (typeof request.data === 'string' || typeof request.data === 'number') {
    return getDataString(request);
  }

  if (!request.multipartUploads) {
    return '';
  }

  var fileArgs = [];
  var dataArgs = [];

  for (var multipartKey in request.multipartUploads) {
    var multipartValue = request.multipartUploads[multipartKey];

    if (multipartValue.startsWith('@')) {
      var fileName = multipartValue.slice(1);
      fileArgs.push("    {:file, ~s|".concat(fileName, "|}"));
    } else {
      dataArgs.push("    {".concat(repr(multipartKey), ", ").concat(repr(multipartValue), "}"));
    }
  }

  var content = [];
  fileArgs = fileArgs.join(',\n');

  if (fileArgs) {
    content.push(fileArgs);
  }

  dataArgs = dataArgs.join(',\n');

  if (dataArgs) {
    content.push(dataArgs);
  }

  content = content.join(',\n');

  if (content) {
    return "{:multipart, [\n".concat(content, "\n]}");
  }

  return '';
}

function getDataString(request) {
  if (typeof request.data === 'number') {
    request.data = request.data.toString();
  }

  if (!request.isDataRaw && request.data.startsWith('@')) {
    var filePath = request.data.slice(1);

    if (request.isDataBinary) {
      return "File.read!(\"".concat(filePath, "\")");
    } else {
      return "{:file, ~s|".concat(filePath, "|}");
    }
  }

  var parsedQueryString = querystring.parse(request.data, {
    sort: false
  });
  var keyCount = Object.keys(parsedQueryString).length;
  var singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]];
  var singularData = request.isDataBinary || singleKeyOnly;

  if (singularData) {
    return "~s|".concat(request.data, "|");
  } else {
    return getMultipleDataString(request, parsedQueryString);
  }
}

function getMultipleDataString(request, parsedQueryString) {
  var repeatedKey = false;

  for (var key in parsedQueryString) {
    var value = parsedQueryString[key];

    if (Array.isArray(value)) {
      repeatedKey = true;
    }
  }

  var dataString;

  if (repeatedKey) {
    var data = [];

    for (key in parsedQueryString) {
      value = parsedQueryString[key];

      if (Array.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          data.push("    {".concat(repr(key), ", ").concat(repr(value[i]), "}"));
        }
      } else {
        data.push("    {".concat(repr(key), ", ").concat(repr(value), "}"));
      }
    }

    dataString = "[\n".concat(data.join(',\n'), "\n  ]");
  } else {
    var _data = [];

    for (key in parsedQueryString) {
      value = parsedQueryString[key];

      _data.push("    {".concat(repr(key), ", ").concat(repr(value), "}"));
    }

    dataString = "[\n".concat(_data.join(',\n'), "\n  ]");
  }

  return dataString;
}

var toElixir = function toElixir(curlCommand) {
  var request = util.parseCurlCommand(curlCommand); // curl automatically prepends 'http' if the scheme is missing, but python fails and returns an error
  // we tack it on here to mimic curl

  if (!request.url.match(/https?:/)) {
    request.url = 'http://' + request.url;
  }

  if (!request.urlWithoutQuery.match(/https?:/)) {
    request.urlWithoutQuery = 'http://' + request.urlWithoutQuery;
  }

  var template = "request = %HTTPoison.Request{\n  method: :".concat(request.method, ",\n  url: \"").concat(request.urlWithoutQuery, "\",\n  options: ").concat(getOptions(request), ",\n  headers: ").concat(getHeadersDict(request), ",\n  params: ").concat(getQueryDict(request), ",\n  body: ").concat(getBody(request), "\n}\n\nresponse = HTTPoison.request(request)\n");
  return template;
};

module.exports = toElixir;
        },
        map: {"../util":133,"jsesc":137,"query-string":135,"string.prototype.startswith":138}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/javascript/browser.js
      77: {
        factory: (module, exports, require) => {
          var toJsFetch = require('./fetch');

var toBrowser = function toBrowser(curlCommand) {
  var browserCode = toJsFetch(curlCommand);
  return browserCode;
};

module.exports = toBrowser;
        },
        map: {"./fetch":139}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/go.js
      78: {
        factory: (module, exports, require) => {
          var util = require('../util');

var jsesc = require('jsesc');

var toGo = function toGo(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var goCode = 'package main\n\n';
  goCode += 'import (\n\t"fmt"\n\t"io/ioutil"\n\t"log"\n\t"net/http"\n)\n\n';
  goCode += 'func main() {\n';
  goCode += '\tclient := &http.Client{}\n';

  if (request.data === true) {
    request.data = '';
  }

  if (request.data) {
    if (typeof request.data === 'number') {
      request.data = request.data.toString();
    }

    if (request.data.indexOf("'") > -1) {
      request.data = jsesc(request.data);
    } // import strings


    goCode = goCode.replace('\n)', '\n\t"strings"\n)');
    goCode += '\tvar data = strings.NewReader(`' + request.data + '`)\n';
    goCode += '\treq, err := http.NewRequest("' + request.method.toUpperCase() + '", "' + request.url + '", data)\n';
  } else {
    goCode += '\treq, err := http.NewRequest("' + request.method.toUpperCase() + '", "' + request.url + '", nil)\n';
  }

  goCode += '\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n';

  if (request.headers || request.cookies) {
    for (var headerName in request.headers) {
      goCode += '\treq.Header.Set("' + headerName + '", "' + request.headers[headerName] + '")\n';
    }

    if (request.cookies) {
      var cookieString = util.serializeCookies(request.cookies);
      goCode += '\treq.Header.Set("Cookie", "' + cookieString + '")\n';
    }
  }

  if (request.auth) {
    var splitAuth = request.auth.split(':');
    var user = splitAuth[0] || '';
    var password = splitAuth[1] || '';
    goCode += '\treq.SetBasicAuth("' + user + '", "' + password + '")\n';
  }

  goCode += '\tresp, err := client.Do(req)\n';
  goCode += '\tif err != nil {\n';
  goCode += '\t\tlog.Fatal(err)\n';
  goCode += '\t}\n';
  goCode += '\tdefer resp.Body.Close()\n';
  goCode += '\tbodyText, err := ioutil.ReadAll(resp.Body)\n';
  goCode += '\tif err != nil {\n';
  goCode += '\t\tlog.Fatal(err)\n';
  goCode += '\t}\n';
  goCode += '\tfmt.Printf("%s\\n", bodyText)\n';
  goCode += '}';
  return goCode + '\n';
};

module.exports = toGo;
        },
        map: {"../util":133,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/json.js
      79: {
        factory: (module, exports, require) => {
          // Author: ssi-anik (sirajul.islam.anik@gmail.com)
var util = require('../util');

var querystring = require('query-string');

var jsesc = require('jsesc');

require('string.prototype.startswith');

function repr(value, isKey) {
  // In context of url parameters, don't accept nulls and such.

  /*
    if ( !value ) {
   return ""
   } else {
   return "'" + jsesc(value, { quotes: 'single' }) + "'"
   } */
  return isKey ? "'" + jsesc(value, {
    quotes: 'single'
  }) + "'" : value;
}

function getQueries(request) {
  var queries = {};

  for (var paramName in request.query) {
    var rawValue = request.query[paramName];
    var paramValue = void 0;

    if (Array.isArray(rawValue)) {
      paramValue = rawValue.map(repr);
    } else {
      paramValue = repr(rawValue);
    }

    queries[repr(paramName)] = paramValue;
  }

  return queries;
}

function getDataString(request) {
  if (typeof request.data === 'number') {
    request.data = request.data.toString();
  }
  /*
    if ( !request.isDataRaw && request.data.startsWith('@') ) {
   var filePath = request.data.slice(1);
   return filePath;
   }
   */


  var parsedQueryString = querystring.parse(request.data, {
    sort: false
  });
  var keyCount = Object.keys(parsedQueryString).length;
  var singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]];
  var singularData = request.isDataBinary || singleKeyOnly;

  if (singularData) {
    var data = {};
    data[repr(request.data)] = '';
    return {
      data: data
    };
  } else {
    return getMultipleDataString(request, parsedQueryString);
  }
}

function getMultipleDataString(request, parsedQueryString) {
  var data = {};

  for (var key in parsedQueryString) {
    var value = parsedQueryString[key];

    if (Array.isArray(value)) {
      data[repr(key)] = value;
    } else {
      data[repr(key)] = repr(value);
    }
  }

  return {
    data: data
  };
}

function getFilesString(request) {
  var data = {};
  data.files = {};
  data.data = {};

  for (var multipartKey in request.multipartUploads) {
    var multipartValue = request.multipartUploads[multipartKey];

    if (multipartValue.startsWith('@')) {
      var fileName = multipartValue.slice(1);
      data.files[repr(multipartKey)] = repr(fileName);
    } else {
      data.data[repr(multipartKey)] = repr(multipartValue);
    }
  }

  if (Object.keys(data.files).length === 0) {
    delete data.files;
  }

  if (Object.keys(data.data).length === 0) {
    delete data.data;
  }

  return data;
}

var toJsonString = function toJsonString(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var requestJson = {}; // curl automatically prepends 'http' if the scheme is missing, but python fails and returns an error
  // we tack it on here to mimic curl

  if (!request.url.match(/https?:/)) {
    request.url = 'http://' + request.url;
  }

  if (!request.urlWithoutQuery.match(/https?:/)) {
    request.urlWithoutQuery = 'http://' + request.urlWithoutQuery;
  }

  requestJson.url = request.urlWithoutQuery.replace(/\/$/, '');
  requestJson.raw_url = request.url;
  requestJson.method = request.method;

  if (request.cookies) {
    var cookies = {};

    for (var cookieName in request.cookies) {
      cookies[repr(cookieName)] = repr(request.cookies[cookieName]);
    }

    requestJson.cookies = cookies;
  }

  if (request.headers) {
    var headers = {};

    for (var headerName in request.headers) {
      headers[repr(headerName)] = repr(request.headers[headerName]);
    }

    requestJson.headers = headers;
  }

  if (request.query) {
    requestJson.queries = getQueries(request);
  }

  if (typeof request.data === 'string' || typeof request.data === 'number') {
    Object.assign(requestJson, getDataString(request));
  } else if (request.multipartUploads) {
    Object.assign(requestJson, getFilesString(request));
  }

  if (request.insecure) {
    requestJson.insecure = false;
  }

  if (request.auth) {
    var splitAuth = request.auth.split(':');
    var user = splitAuth[0] || '';
    var password = splitAuth[1] || '';
    requestJson.auth = {
      user: repr(user),
      password: repr(password)
    };
  }

  return JSON.stringify(Object.keys(requestJson).length ? requestJson : '{}', null, 4) + '\n';
};

module.exports = toJsonString;
        },
        map: {"../util":133,"query-string":135,"jsesc":137,"string.prototype.startswith":138}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/javascript/node-fetch.js
      80: {
        factory: (module, exports, require) => {
          var toJsFetch = require('./fetch');

var toNodeFetch = function toNodeFetch(curlCommand) {
  var nodeFetchCode = 'var fetch = require(\'node-fetch\');\n\n';
  nodeFetchCode += toJsFetch(curlCommand);
  return nodeFetchCode;
};

module.exports = toNodeFetch;
        },
        map: {"./fetch":139}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/javascript/node-request.js
      81: {
        factory: (module, exports, require) => {
          var util = require('../../util');

var jsesc = require('jsesc');

var toNodeRequest = function toNodeRequest(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var nodeRequestCode = 'var request = require(\'request\');\n\n';

  if (request.headers || request.cookies) {
    nodeRequestCode += 'var headers = {\n';
    var headerCount = Object.keys(request.headers).length;
    var i = 0;

    for (var headerName in request.headers) {
      nodeRequestCode += '    \'' + headerName + '\': \'' + request.headers[headerName] + '\'';

      if (i < headerCount - 1 || request.cookies) {
        nodeRequestCode += ',\n';
      } else {
        nodeRequestCode += '\n';
      }

      i++;
    }

    if (request.cookies) {
      var cookieString = util.serializeCookies(request.cookies);
      nodeRequestCode += '    \'Cookie\': \'' + cookieString + '\'\n';
    }

    nodeRequestCode += '};\n\n';
  }

  if (request.data === true) {
    request.data = '';
  }

  if (request.data) {
    if (typeof request.data === 'number') {
      request.data = request.data.toString();
    } // escape single quotes if there are any in there


    if (request.data.indexOf("'") > -1) {
      request.data = jsesc(request.data);
    }

    nodeRequestCode += 'var dataString = \'' + request.data + '\';\n\n';
  }

  nodeRequestCode += 'var options = {\n';
  nodeRequestCode += '    url: \'' + request.url + '\'';

  if (request.method !== 'get') {
    nodeRequestCode += ',\n    method: \'' + request.method.toUpperCase() + '\'';
  }

  if (request.headers || request.cookies) {
    nodeRequestCode += ',\n';
    nodeRequestCode += '    headers: headers';
  }

  if (request.data) {
    nodeRequestCode += ',\n    body: dataString';
  }

  if (request.auth) {
    nodeRequestCode += ',\n';
    var splitAuth = request.auth.split(':');
    var user = splitAuth[0] || '';
    var password = splitAuth[1] || '';
    nodeRequestCode += '    auth: {\n';
    nodeRequestCode += "        'user': '" + user + "',\n";
    nodeRequestCode += "        'pass': '" + password + "'\n";
    nodeRequestCode += '    }\n';
  } else {
    nodeRequestCode += '\n';
  }

  nodeRequestCode += '};\n\n';
  nodeRequestCode += 'function callback(error, response, body) {\n';
  nodeRequestCode += '    if (!error && response.statusCode == 200) {\n';
  nodeRequestCode += '        console.log(body);\n';
  nodeRequestCode += '    }\n';
  nodeRequestCode += '}\n\n';
  nodeRequestCode += 'request(options, callback);';
  return nodeRequestCode + '\n';
};

module.exports = toNodeRequest;
        },
        map: {"../../util":133,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/php.js
      82: {
        factory: (module, exports, require) => {
          var util = require('../util');

var querystring = require('query-string');

var jsesc = require('jsesc');

var quote = function quote(str) {
  return jsesc(str, {
    quotes: 'single'
  });
};

var toPhp = function toPhp(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var headerString = false;

  if (request.headers) {
    headerString = '$headers = array(\n';
    var i = 0;
    var headerCount = Object.keys(request.headers).length;

    for (var headerName in request.headers) {
      headerString += "    '" + headerName + "' => '" + quote(request.headers[headerName]) + "'";

      if (i < headerCount - 1) {
        headerString += ',\n';
      }

      i++;
    }

    if (request.cookies) {
      var cookieString = quote(util.serializeCookies(request.cookies));
      headerString += ",\n    'Cookie' => '" + cookieString + "'";
    }

    headerString += '\n);';
  } else {
    headerString = '$headers = array();';
  }

  var optionsString = false;

  if (request.auth) {
    var splitAuth = request.auth.split(':').map(quote);
    var user = splitAuth[0] || '';
    var password = splitAuth[1] || '';
    optionsString = "$options = array('auth' => array('" + user + "', '" + password + "'));";
  }

  var dataString = false;

  if (request.data) {
    if (typeof request.data === 'number') {
      request.data = request.data.toString();
    }

    var parsedQueryString = querystring.parse(request.data, {
      sort: false
    });
    dataString = '$data = array(\n';
    var dataCount = Object.keys(parsedQueryString).length;

    if (dataCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]]) {
      dataString = "$data = '" + quote(request.data) + "';";
    } else {
      var dataIndex = 0;

      for (var key in parsedQueryString) {
        var value = parsedQueryString[key];
        dataString += "    '" + key + "' => '" + quote(value) + "'";

        if (dataIndex < dataCount - 1) {
          dataString += ',\n';
        }

        dataIndex++;
      }

      dataString += '\n);';
    }
  }

  var requestLine = '$response = Requests::' + request.method + '(\'' + request.url + '\'';
  requestLine += ', $headers';

  if (dataString) {
    requestLine += ', $data';
  }

  if (optionsString) {
    requestLine += ', $options';
  }

  requestLine += ');';
  var phpCode = '<?php\n';
  phpCode += 'include(\'vendor/rmccue/requests/library/Requests.php\');\n';
  phpCode += 'Requests::register_autoloader();\n';
  phpCode += headerString + '\n';

  if (dataString) {
    phpCode += dataString + '\n';
  }

  if (optionsString) {
    phpCode += optionsString + '\n';
  }

  phpCode += requestLine;
  return phpCode + '\n';
};

module.exports = toPhp;
        },
        map: {"../util":133,"query-string":135,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/python.js
      83: {
        factory: (module, exports, require) => {
          var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var util = require('../util');

var jsesc = require('jsesc');

var querystring = require('query-string');

require('string.prototype.startswith');

function reprWithVariable(value, hasEnvironmentVariable) {
  if (!value) {
    return "''";
  }

  if (!hasEnvironmentVariable) {
    return "'" + jsesc(value, {
      quotes: 'single'
    }) + "'";
  }

  return 'f"' + jsesc(value, {
    quotes: 'double'
  }) + '"';
}

function repr(value) {
  // In context of url parameters, don't accept nulls and such.
  return reprWithVariable(value, false);
}

function getQueryDict(request) {
  var queryDict = 'params = (\n';

  for (var paramName in request.query) {
    var rawValue = request.query[paramName];
    var paramValue = void 0;

    if (Array.isArray(rawValue)) {
      paramValue = '[' + rawValue.map(repr).join(', ') + ']';
    } else {
      paramValue = repr(rawValue);
    }

    queryDict += '    (' + repr(paramName) + ', ' + paramValue + '),\n';
  }

  queryDict += ')\n';
  return queryDict;
}

function getDataString(request) {
  if (typeof request.data === 'number') {
    request.data = request.data.toString();
  }

  if (!request.isDataRaw && request.data.startsWith('@')) {
    var filePath = request.data.slice(1);

    if (request.isDataBinary) {
      return 'data = open(\'' + filePath + '\', \'rb\').read()';
    } else {
      return 'data = open(\'' + filePath + '\')';
    }
  }

  var parsedQueryString = querystring.parse(request.data, {
    sort: false
  });
  var keyCount = Object.keys(parsedQueryString).length;
  var singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]];
  var singularData = request.isDataBinary || singleKeyOnly;

  if (singularData) {
    return 'data = ' + repr(request.data) + '\n';
  } else {
    return getMultipleDataString(request, parsedQueryString);
  }
}

function getMultipleDataString(request, parsedQueryString) {
  var repeatedKey = false;

  for (var key in parsedQueryString) {
    var value = parsedQueryString[key];

    if (Array.isArray(value)) {
      repeatedKey = true;
    }
  }

  var dataString;

  if (repeatedKey) {
    dataString = 'data = [\n';

    for (var _key in parsedQueryString) {
      var _value = parsedQueryString[_key];

      if (Array.isArray(_value)) {
        for (var i = 0; i < _value.length; i++) {
          dataString += '  (' + repr(_key) + ', ' + repr(_value[i]) + '),\n';
        }
      } else {
        dataString += '  (' + repr(_key) + ', ' + repr(_value) + '),\n';
      }
    }

    dataString += ']\n';
  } else {
    dataString = 'data = {\n';
    var elementCount = Object.keys(parsedQueryString).length;
    var _i = 0;

    for (var _key2 in parsedQueryString) {
      var _value2 = parsedQueryString[_key2];
      dataString += '  ' + repr(_key2) + ': ' + repr(_value2);

      if (_i === elementCount - 1) {
        dataString += '\n';
      } else {
        dataString += ',\n';
      }

      ++_i;
    }

    dataString += '}\n';
  }

  return dataString;
}

function getFilesString(request) {
  // http://docs.python-requests.org/en/master/user/quickstart/#post-a-multipart-encoded-file
  var filesString = 'files = {\n';

  for (var multipartKey in request.multipartUploads) {
    var multipartValue = request.multipartUploads[multipartKey];

    if (multipartValue.startsWith('@')) {
      var fileName = multipartValue.slice(1);
      filesString += '    ' + repr(multipartKey) + ': (' + repr(fileName) + ', open(' + repr(fileName) + ", 'rb')),\n";
    } else {
      filesString += '    ' + repr(multipartKey) + ': (None, ' + repr(multipartValue) + '),\n';
    }
  }

  filesString += '}\n';
  return filesString;
} // convertVarToStringFormat will convert if inputString to f"..." format
// if inputString has possible variable as its substring


function detectEnvVar(inputString) {
  // Using state machine to detect environment variable
  // Each character is an edge, state machine:
  // IN_ENV_VAR: means that currently we are iterating inside a possible environment variable
  // IN_STRING: means that currently we are iterating inside a normal string
  // For example:
  // "Hi my name is $USER_NAME !"
  // '$' --> will move state from IN_STRING to IN_ENV_VAR
  // ' ' --> will move state to IN_STRING, regardless the previous state
  var IN_ENV_VAR = 0;
  var IN_STRING = 1; // We only care for the unique element

  var detectedVariables = new Set();
  var currState = IN_STRING;
  var envVarStartIndex = -1;
  var whiteSpaceSet = new Set();
  whiteSpaceSet.add(' ');
  whiteSpaceSet.add('\n');
  whiteSpaceSet.add('\t');
  var modifiedString = [];

  for (var idx in inputString) {
    var currIdx = +idx;
    var currChar = inputString[currIdx];

    if (currState === IN_ENV_VAR && whiteSpaceSet.has(currChar)) {
      var newVariable = inputString.substring(envVarStartIndex, currIdx);

      if (newVariable !== '') {
        detectedVariables.add(newVariable); // Change $ -> {
        // Add } after the last variable name

        modifiedString.push('{' + newVariable + '}' + currChar);
      } else {
        modifiedString.push('$' + currChar);
      }

      currState = IN_STRING;
      envVarStartIndex = -1;
      continue;
    }

    if (currState === IN_ENV_VAR) {
      // Skip until we actually have the new variable
      continue;
    } // currState === IN_STRING


    if (currChar === '$') {
      currState = IN_ENV_VAR;
      envVarStartIndex = currIdx + 1;
    } else {
      modifiedString.push(currChar);
    }
  }

  if (currState === IN_ENV_VAR) {
    var _newVariable = inputString.substring(envVarStartIndex, inputString.length);

    if (_newVariable !== '') {
      detectedVariables.add(_newVariable);
      modifiedString.push('{' + _newVariable + '}');
    } else {
      modifiedString.push('$');
    }
  }

  return [detectedVariables, modifiedString.join('')];
}

var toPython = function toPython(curlCommand) {
  var request = util.parseCurlCommand(curlCommand); // Currently, only assuming that the env-var only used in
  // the value part of cookies, params, or body

  var osVariables = new Set();
  var cookieDict;

  if (request.cookies) {
    cookieDict = 'cookies = {\n';

    for (var cookieName in request.cookies) {
      var _detectEnvVar = detectEnvVar(request.cookies[cookieName]),
          _detectEnvVar2 = _slicedToArray(_detectEnvVar, 2),
          detectedVars = _detectEnvVar2[0],
          modifiedString = _detectEnvVar2[1];

      var hasEnvironmentVariable = detectedVars.size > 0;

      var _iterator = _createForOfIteratorHelper(detectedVars),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var newVar = _step.value;
          osVariables.add(newVar);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      cookieDict += '    ' + repr(cookieName) + ': ' + reprWithVariable(modifiedString, hasEnvironmentVariable) + ',\n';
    }

    cookieDict += '}\n';
  }

  var headerDict;

  if (request.headers) {
    headerDict = 'headers = {\n';

    for (var headerName in request.headers) {
      var _detectEnvVar3 = detectEnvVar(request.headers[headerName]),
          _detectEnvVar4 = _slicedToArray(_detectEnvVar3, 2),
          _detectedVars = _detectEnvVar4[0],
          _modifiedString = _detectEnvVar4[1];

      var hasVariable = _detectedVars.size > 0;

      var _iterator2 = _createForOfIteratorHelper(_detectedVars),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _newVar = _step2.value;
          osVariables.add(_newVar);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      headerDict += '    ' + repr(headerName) + ': ' + reprWithVariable(_modifiedString, hasVariable) + ',\n';
    }

    headerDict += '}\n';
  }

  var queryDict;

  if (request.query) {
    queryDict = getQueryDict(request);
  }

  var dataString;
  var filesString;

  if (typeof request.data === 'string' || typeof request.data === 'number') {
    dataString = getDataString(request);
  } else if (request.multipartUploads) {
    filesString = getFilesString(request);
  } // curl automatically prepends 'http' if the scheme is missing, but python fails and returns an error
  // we tack it on here to mimic curl


  if (!request.url.match(/https?:/)) {
    request.url = 'http://' + request.url;
  }

  if (!request.urlWithoutQuery.match(/https?:/)) {
    request.urlWithoutQuery = 'http://' + request.urlWithoutQuery;
  }

  var requestLineWithUrlParams = 'response = requests.' + request.method + '(\'' + request.urlWithoutQuery + '\'';
  var requestLineWithOriginalUrl = 'response = requests.' + request.method + '(\'' + request.url + '\'';
  var requestLineBody = '';

  if (request.headers) {
    requestLineBody += ', headers=headers';
  }

  if (request.query) {
    requestLineBody += ', params=params';
  }

  if (request.cookies) {
    requestLineBody += ', cookies=cookies';
  }

  if (typeof request.data === 'string') {
    requestLineBody += ', data=data';
  } else if (request.multipartUploads) {
    requestLineBody += ', files=files';
  }

  if (request.insecure) {
    requestLineBody += ', verify=False';
  }

  if (request.auth) {
    var splitAuth = request.auth.split(':');
    var user = splitAuth[0] || '';
    var password = splitAuth[1] || '';
    requestLineBody += ', auth=(' + repr(user) + ', ' + repr(password) + ')';
  }

  requestLineBody += ')';
  requestLineWithOriginalUrl += requestLineBody.replace(', params=params', '');
  requestLineWithUrlParams += requestLineBody;
  var pythonCode = ''; // Sort import by name

  if (osVariables.size > 0) {
    pythonCode += 'import os\n';
  }

  pythonCode += 'import requests\n\n';

  if (osVariables.size > 0) {
    var _iterator3 = _createForOfIteratorHelper(osVariables),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var osVar = _step3.value;
        var line = "".concat(osVar, " = os.getenv('").concat(osVar, "')\n");
        pythonCode += line;
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    pythonCode += '\n';
  }

  if (cookieDict) {
    pythonCode += cookieDict + '\n';
  }

  if (headerDict) {
    pythonCode += headerDict + '\n';
  }

  if (queryDict) {
    pythonCode += queryDict + '\n';
  }

  if (dataString) {
    pythonCode += dataString + '\n';
  } else if (filesString) {
    pythonCode += filesString + '\n';
  }

  pythonCode += requestLineWithUrlParams;

  if (request.query) {
    pythonCode += '\n\n' + '#NB. Original query string below. It seems impossible to parse and\n' + '#reproduce query strings 100% accurately so the one below is given\n' + '#in case the reproduced version is not "correct".\n';
    pythonCode += '# ' + requestLineWithOriginalUrl;
  }

  return pythonCode + '\n';
};

module.exports = toPython;
        },
        map: {"@babel/runtime/helpers/slicedToArray":120,"../util":133,"jsesc":137,"query-string":135,"string.prototype.startswith":138}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/r.js
      84: {
        factory: (module, exports, require) => {
          // Author: Bob Rudis (bob@rud.is)
var util = require('../util');

var jsesc = require('jsesc');

var querystring = require('query-string');

require('string.prototype.startswith');

function reprn(value) {
  // back-tick quote names
  if (!value) {
    return '``';
  } else {
    return '`' + value + '`';
  }
}

function repr(value) {
  // In context of url parameters, don't accept nulls and such.
  if (!value) {
    return "''";
  } else {
    return "'" + jsesc(value, {
      quotes: 'single'
    }) + "'";
  }
}

function getQueryDict(request) {
  var queryDict = 'params = list(\n';
  queryDict += Object.keys(request.query).map(function (paramName) {
    var rawValue = request.query[paramName];
    var paramValue;

    if (Array.isArray(rawValue)) {
      paramValue = 'c(' + rawValue.map(repr).join(', ') + ')';
    } else {
      paramValue = repr(rawValue);
    }

    return '  ' + reprn(paramName) + ' = ' + paramValue;
  }).join(',\n');
  queryDict += '\n)\n';
  return queryDict;
}

function getDataString(request) {
  if (typeof request.data === 'number') {
    request.data = request.data.toString();
  }

  if (!request.isDataRaw && request.data.startsWith('@')) {
    var filePath = request.data.slice(1);
    return 'data = upload_file(\'' + filePath + '\')';
  }

  var parsedQueryString = querystring.parse(request.data, {
    sort: false
  });
  var keyCount = Object.keys(parsedQueryString).length;
  var singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]];
  var singularData = request.isDataBinary || singleKeyOnly;

  if (singularData) {
    return 'data = ' + repr(request.data) + '\n';
  } else {
    return getMultipleDataString(request, parsedQueryString);
  }
}

function getMultipleDataString(request, parsedQueryString) {
  var repeatedKey = false;

  for (var key in parsedQueryString) {
    var value = parsedQueryString[key];

    if (Array.isArray(value)) {
      repeatedKey = true;
    }
  }

  var dataString;

  if (repeatedKey) {
    var els = [];
    dataString = 'data = list(\n';

    for (var _key in parsedQueryString) {
      var _value = parsedQueryString[_key];

      if (Array.isArray(_value)) {
        for (var i = 0; i < _value.length; i++) {
          els.push('  ' + reprn(_key) + ' = ' + repr(_value[i]));
        }
      } else {
        els.push('  ' + reprn(_key) + ' = ' + repr(_value));
      }
    }

    dataString += els.join(',\n');
    dataString += '\n)\n';
  } else {
    dataString = 'data = list(\n';
    dataString += Object.keys(parsedQueryString).map(function (key) {
      var value = parsedQueryString[key];
      return '  ' + reprn(key) + ' = ' + repr(value);
    }).join(',\n');
    dataString += '\n)\n';
  }

  return dataString;
}

function getFilesString(request) {
  // http://docs.rstats-requests.org/en/master/user/quickstart/#post-a-multipart-encoded-file
  var filesString = 'files = list(\n';
  filesString += Object.keys(request.multipartUploads).map(function (multipartKey) {
    var multipartValue = request.multipartUploads[multipartKey];
    var fileParam;

    if (multipartValue.startsWith('@')) {
      var fileName = multipartValue.slice(1); // filesString += '    ' + reprn(multipartKey) + ' (' + repr(fileName) + ', upload_file(' + repr(fileName) + '))'

      fileParam = '  ' + reprn(multipartKey) + ' = upload_file(' + repr(fileName) + ')';
    } else {
      fileParam = '  ' + reprn(multipartKey) + ' = ' + repr(multipartValue) + '';
    }

    return fileParam;
  }).join(',\n');
  filesString += '\n)\n';
  return filesString;
}

var torstats = function torstats(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var cookieDict;

  if (request.cookies) {
    cookieDict = 'cookies = c(\n';
    cookieDict += Object.keys(request.cookies).map(function (cookieName) {
      return '  ' + repr(cookieName) + ' = ' + repr(request.cookies[cookieName]);
    }).join(',\n');
    cookieDict += '\n)\n';
  }

  var headerDict;

  if (request.headers) {
    var hels = [];
    headerDict = 'headers = c(\n';

    for (var headerName in request.headers) {
      hels.push('  ' + reprn(headerName) + ' = ' + repr(request.headers[headerName]));
    }

    headerDict += hels.join(',\n');
    headerDict += '\n)\n';
  }

  var queryDict;

  if (request.query) {
    queryDict = getQueryDict(request);
  }

  var dataString;
  var filesString;

  if (typeof request.data === 'string' || typeof request.data === 'number') {
    dataString = getDataString(request);
  } else if (request.multipartUploads) {
    filesString = getFilesString(request);
  } // curl automatically prepends 'http' if the scheme is missing, but rstats fails and returns an error
  // we tack it on here to mimic curl


  if (!request.url.match(/https?:/)) {
    request.url = 'http://' + request.url;
  }

  if (!request.urlWithoutQuery.match(/https?:/)) {
    request.urlWithoutQuery = 'http://' + request.urlWithoutQuery;
  }

  var requestLineWithUrlParams = 'res <- httr::' + request.method.toUpperCase() + '(url = \'' + request.urlWithoutQuery + '\'';
  var requestLineWithOriginalUrl = 'res <- httr::' + request.method.toUpperCase() + '(url = \'' + request.url + '\'';
  var requestLineBody = '';

  if (request.headers) {
    requestLineBody += ', httr::add_headers(.headers=headers)';
  }

  if (request.query) {
    requestLineBody += ', query = params';
  }

  if (request.cookies) {
    requestLineBody += ', httr::set_cookies(.cookies = cookies)';
  }

  if (typeof request.data === 'string') {
    requestLineBody += ', body = data';
  } else if (request.multipartUploads) {
    requestLineBody += ', body = files';
  }

  if (request.insecure) {
    requestLineBody += ', config = httr::config(ssl_verifypeer = FALSE)';
  }

  if (request.auth) {
    var splitAuth = request.auth.split(':');
    var user = splitAuth[0] || '';
    var password = splitAuth[1] || '';
    requestLineBody += ', httr::authenticate(' + repr(user) + ', ' + repr(password) + ')';
  }

  requestLineBody += ')';
  requestLineWithOriginalUrl += requestLineBody.replace(', query = params', '');
  requestLineWithUrlParams += requestLineBody;
  var rstatsCode = '';
  rstatsCode += 'require(httr)\n\n';

  if (cookieDict) {
    rstatsCode += cookieDict + '\n';
  }

  if (headerDict) {
    rstatsCode += headerDict + '\n';
  }

  if (queryDict) {
    rstatsCode += queryDict + '\n';
  }

  if (dataString) {
    rstatsCode += dataString + '\n';
  } else if (filesString) {
    rstatsCode += filesString + '\n';
  }

  rstatsCode += requestLineWithUrlParams;

  if (request.query) {
    rstatsCode += '\n\n' + '#NB. Original query string below. It seems impossible to parse and\n' + '#reproduce query strings 100% accurately so the one below is given\n' + '#in case the reproduced version is not "correct".\n';
    rstatsCode += '# ' + requestLineWithOriginalUrl;
  }

  return rstatsCode + '\n';
};

module.exports = torstats;
        },
        map: {"../util":133,"jsesc":137,"query-string":135,"string.prototype.startswith":138}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/rust.js
      85: {
        factory: (module, exports, require) => {
          var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var util = require('../util');

var jsesc = require('jsesc');

var INDENTATION = ' '.repeat(4);

var indent = function indent(line) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return INDENTATION.repeat(level) + line;
};

var quote = function quote(str) {
  return jsesc(str, {
    quotes: 'double'
  });
};

function toRust(curlCommand) {
  var lines = ['extern crate reqwest;'];
  var request = util.parseCurlCommand(curlCommand);
  var hasHeaders = request.headers || request.cookies;
  {
    // Generate imports.
    var imports = [{
      want: 'header',
      condition: hasHeaders
    }, {
      want: 'multipart',
      condition: !!request.multipartUploads
    }].filter(function (i) {
      return i.condition;
    }).map(function (i) {
      return i.want;
    });

    if (imports.length > 1) {
      lines.push("use reqwest::{".concat(imports.join(', '), "};"));
    } else if (imports.length) {
      lines.push("use reqwest::".concat(imports[0], ";"));
    }
  }
  lines.push('', 'fn main() -> Result<(), Box<dyn std::error::Error>> {');

  if (request.headers || request.cookies) {
    lines.push(indent('let mut headers = header::HeaderMap::new();'));

    for (var headerName in request.headers) {
      var headerValue = quote(request.headers[headerName]);
      lines.push(indent("headers.insert(\"".concat(headerName, "\", \"").concat(headerValue, "\".parse().unwrap());")));
    }

    if (request.cookies) {
      var cookies = Object.keys(request.cookies).map(function (key) {
        return "".concat(key, "=").concat(request.cookies[key]);
      }).join('; ');
      lines.push(indent("headers.insert(header::COOKIE, \"".concat(quote(cookies), "\".parse().unwrap());")));
    }

    lines.push('');
  }

  if (request.multipartUploads) {
    lines.push(indent('let form = multipart::Form::new()'));
    var parts = Object.keys(request.multipartUploads).map(function (partType) {
      var partValue = request.multipartUploads[partType];

      switch (partType) {
        case 'image':
        case 'file':
          {
            var path = partValue.split('@')[1];
            return indent(".file(\"".concat(partType, "\", \"").concat(quote(path), "\")?"), 2);
          }

        default:
          return indent(".text(\"".concat(partType, "\", \"").concat(quote(partValue), "\")"), 2);
      }
    });
    parts[parts.length - 1] += ';';
    lines.push.apply(lines, _toConsumableArray(parts).concat(['']));
  }

  lines.push(indent('let res = reqwest::Client::new()'));
  lines.push(indent(".".concat(request.method, "(\"").concat(quote(request.url), "\")"), 2));

  if (request.auth) {
    var _request$auth$split$m = request.auth.split(':', 2).map(quote),
        _request$auth$split$m2 = _slicedToArray(_request$auth$split$m, 2),
        user = _request$auth$split$m2[0],
        password = _request$auth$split$m2[1];

    lines.push(indent(".basic_auth(\"".concat(user || '', "\", Some(\"").concat(password || '', "\"))"), 2));
  }

  if (hasHeaders) {
    lines.push(indent('.headers(headers)', 2));
  }

  if (request.multipartUploads) {
    lines.push(indent('.multipart(form)', 2));
  }

  if (request.data) {
    if (typeof request.data === 'string' && request.data.indexOf('\n') !== -1) {
      // Use raw strings for multiline content
      lines.push(indent('.body(r#"', 2), request.data, '"#', indent(')', 2));
    } else {
      lines.push(indent(".body(\"".concat(quote(request.data), "\")"), 2));
    }
  }

  lines.push(indent('.send()?', 2), indent('.text()?;', 2), indent('println!("{}", res);'), '', indent('Ok(())'), '}');
  return lines.join('\n') + '\n';
}

module.exports = toRust;
        },
        map: {"@babel/runtime/helpers/slicedToArray":120,"@babel/runtime/helpers/toConsumableArray":35,"../util":133,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/strest.js
      86: {
        factory: (module, exports, require) => {
          var util = require('../util');

var yaml = require('yamljs');

var jsesc = require('jsesc');

var querystring = require('query-string');

function getDataString(request) {
  var mimeType = 'application/json';

  if (typeof request.data === 'number') {
    request.data = request.data.toString();
    mimeType = 'text/plain';
  }

  if (request.data.indexOf("'") > -1) {
    request.data = jsesc(request.data);
  }

  var parsedQueryString = querystring.parse(request.data, {
    sort: false
  });
  var keyCount = Object.keys(parsedQueryString).length;
  var singleKeyOnly = keyCount === 1 && !parsedQueryString[Object.keys(parsedQueryString)[0]];
  var singularData = request.isDataBinary || singleKeyOnly;

  if (singularData) {
    return {
      mimeType: mimeType,
      text: JSON.parse(request.data)
    };
  } else {
    for (var paramName in request.headers) {
      if (paramName === 'Content-Type') {
        mimeType = request.headers[paramName];
      }
    }

    return {
      mimeType: mimeType,
      text: request.data
    };
  }
}

function getQueryList(request) {
  var queryList = [];

  for (var paramName in request.query) {
    var rawValue = request.query[paramName];
    queryList.push({
      name: paramName,
      value: rawValue
    });
  }

  return queryList;
}

var toStrest = function toStrest(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var response = {
    version: 2
  };

  if (request.insecure) {
    response.allowInsecure = true;
  }

  if (!request.urlWithoutQuery.match(/https?:/)) {
    request.urlWithoutQuery = 'http://' + request.urlWithoutQuery;
  }

  response.requests = {
    curl_converter: {
      request: {
        url: request.urlWithoutQuery.toString(),
        method: request.method.toUpperCase()
      }
    }
  };

  if (typeof request.data === 'string' || typeof request.data === 'number') {
    response.requests.curl_converter.request.postData = getDataString(request);
  }

  if (request.headers) {
    response.requests.curl_converter.request.headers = [];

    for (var prop in request.headers) {
      response.requests.curl_converter.request.headers.push({
        name: prop,
        value: request.headers[prop]
      });
    }

    if (request.cookieString) {
      response.requests.curl_converter.request.headers.push({
        name: 'Cookie',
        value: request.cookieString
      });
    }
  }

  if (request.auth) {
    response.requests.curl_converter.auth = {
      basic: {}
    };

    if (request.auth.split(':')[0]) {
      response.requests.curl_converter.auth.basic.username = request.auth.split(':')[0];
    }

    response.requests.curl_converter.auth.basic.password = request.auth.split(':')[1];
  }

  var queryList;

  if (request.query) {
    queryList = getQueryList(request);
    response.requests.curl_converter.request.queryString = queryList;
  }

  var yamlString = yaml.stringify(response, 100, 2);
  return yamlString;
};

module.exports = toStrest;
        },
        map: {"../util":133,"yamljs":140,"jsesc":137,"query-string":135}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/matlab/matlab.js
      87: {
        factory: (module, exports, require) => {
          var util = require('../../util');

var toWebServices = require('./webservices');

var toHTTPInterface = require('./httpinterface'); // We polyfill the flat function for node 10 which is still the default node version on ubuntu 20.04


if (!Array.prototype.flat) {
  Object.defineProperty(Array.prototype, 'flat', {
    value: function value() {
      var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.reduce(function (flat, toFlatten) {
        return flat.concat(Array.isArray(toFlatten) && depth > 1 ? toFlatten.flat(depth - 1) : toFlatten);
      }, []);
    }
  });
}

var toMATLAB = function toMATLAB(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var lines = toWebServices(request).concat('', toHTTPInterface(request));
  return lines.flat().filter(function (line) {
    return line !== null;
  }).join('\n');
};

module.exports = toMATLAB;
        },
        map: {"../../util":133,"./webservices":141,"./httpinterface":142}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/java.js
      88: {
        factory: (module, exports, require) => {
          var util = require('../util');

var jsesc = require('jsesc');

var doubleQuotes = function doubleQuotes(str) {
  return jsesc(str, {
    quotes: 'double'
  });
};

var toJava = function toJava(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var javaCode = '';

  if (request.auth) {
    javaCode += 'import javax.xml.bind.DatatypeConverter;\n';
  }

  javaCode += 'import java.io.IOException;\n';
  javaCode += 'import java.io.InputStream;\n';

  if (request.data) {
    javaCode += 'import java.io.OutputStreamWriter;\n';
  }

  javaCode += 'import java.net.HttpURLConnection;\n';
  javaCode += 'import java.net.URL;\n';
  javaCode += 'import java.util.Scanner;\n';
  javaCode += '\nclass Main {\n\n';
  javaCode += '\tpublic static void main(String[] args) throws IOException {\n';
  javaCode += '\t\tURL url = new URL("' + request.url + '");\n';
  javaCode += '\t\tHttpURLConnection httpConn = (HttpURLConnection) url.openConnection();\n';
  javaCode += '\t\thttpConn.setRequestMethod("' + request.method.toUpperCase() + '");\n\n';
  var gzip = false;

  if (request.headers) {
    for (var headerName in request.headers) {
      javaCode += '\t\thttpConn.setRequestProperty("' + headerName + '", "' + doubleQuotes(request.headers[headerName]) + '");\n';

      if (headerName.toLowerCase() === 'accept-encoding') {
        gzip = request.headers[headerName].indexOf('gzip') !== -1;
      }
    }

    javaCode += '\n';
  }

  if (request.cookies) {
    var cookieString = util.serializeCookies(request.cookies);
    javaCode += '\t\thttpConn.setRequestProperty("Cookie", "' + doubleQuotes(cookieString) + '");\n';
    javaCode += '\n';
  }

  if (request.auth) {
    javaCode += '\t\tbyte[] message = ("' + doubleQuotes(request.auth) + '").getBytes("UTF-8");\n';
    javaCode += '\t\tString basicAuth = DatatypeConverter.printBase64Binary(message);\n';
    javaCode += '\t\thttpConn.setRequestProperty("Authorization", "Basic " + basicAuth);\n';
    javaCode += '\n';
  }

  if (request.data) {
    if (typeof request.data === 'number') {
      request.data = request.data.toString();
    }

    request.data = doubleQuotes(request.data);
    javaCode += '\t\thttpConn.setDoOutput(true);\n';
    javaCode += '\t\tOutputStreamWriter writer = new OutputStreamWriter(httpConn.getOutputStream());\n';
    javaCode += '\t\twriter.write("' + request.data + '");\n';
    javaCode += '\t\twriter.flush();\n';
    javaCode += '\t\twriter.close();\n';
    javaCode += '\t\thttpConn.getOutputStream().close();\n';
    javaCode += '\n';
  }

  javaCode += '\t\tInputStream responseStream = httpConn.getResponseCode() / 100 == 2\n';
  javaCode += '\t\t\t\t? httpConn.getInputStream()\n';
  javaCode += '\t\t\t\t: httpConn.getErrorStream();\n';

  if (gzip) {
    javaCode += '\t\tif ("gzip".equals(httpConn.getContentEncoding())) {\n';
    javaCode += '\t\t\tresponseStream = new GZIPInputStream(responseStream);\n';
    javaCode += '\t\t}\n';
  }

  javaCode += '\t\tScanner s = new Scanner(responseStream).useDelimiter("\\\\A");\n';
  javaCode += '\t\tString response = s.hasNext() ? s.next() : "";\n';
  javaCode += '\t\tSystem.out.println(response);\n';
  javaCode += '\t}\n';
  javaCode += '}';
  return javaCode + '\n';
};

module.exports = toJava;
        },
        map: {"../util":133,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_arrayMap.js
      89: {
        factory: (module, exports, require) => {
          /**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseClone.js
      90: {
        factory: (module, exports, require) => {
          var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys'),
    keysIn = require('./keysIn');
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;
        },
        map: {"./_Stack":143,"./_arrayEach":96,"./_assignValue":144,"./_baseAssign":145,"./_baseAssignIn":146,"./_cloneBuffer":147,"./_copyArray":148,"./_copySymbols":149,"./_copySymbolsIn":150,"./_getAllKeys":151,"./_getAllKeysIn":95,"./_getTag":152,"./_initCloneArray":153,"./_initCloneByTag":154,"./_initCloneObject":155,"./isArray":99,"./isBuffer":156,"./isMap":157,"./isObject":158,"./isSet":159,"./keys":160,"./keysIn":161}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseUnset.js
      91: {
        factory: (module, exports, require) => {
          var castPath = require('./_castPath'),
    last = require('./last'),
    parent = require('./_parent'),
    toKey = require('./_toKey');
/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */


function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;
        },
        map: {"./_castPath":92,"./last":162,"./_parent":163,"./_toKey":164}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_castPath.js
      92: {
        factory: (module, exports, require) => {
          var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;
        },
        map: {"./isArray":99,"./_isKey":165,"./_stringToPath":166,"./toString":167}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_copyObject.js
      93: {
        factory: (module, exports, require) => {
          var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;
        },
        map: {"./_assignValue":144,"./_baseAssignValue":168}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_customOmitClone.js
      94: {
        factory: (module, exports, require) => {
          var isPlainObject = require('./isPlainObject');
/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */


function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;
        },
        map: {"./isPlainObject":169}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getAllKeysIn.js
      95: {
        factory: (module, exports, require) => {
          var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;
        },
        map: {"./_baseGetAllKeys":170,"./_getSymbolsIn":171,"./keysIn":161}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_arrayEach.js
      96: {
        factory: (module, exports, require) => {
          /**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseEach.js
      97: {
        factory: (module, exports, require) => {
          var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;
        },
        map: {"./_baseForOwn":172,"./_createBaseEach":173}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_castFunction.js
      98: {
        factory: (module, exports, require) => {
          var identity = require('./identity');
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */


function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;
        },
        map: {"./identity":174}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isArray.js
      99: {
        factory: (module, exports, require) => {
          /**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/qs/lib/stringify.js
      100: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var getSideChannel = require('side-channel');

var utils = require('./utils');

var formats = require('./formats');

var has = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + '[]';
  },
  comma: 'comma',
  indices: function indices(prefix, key) {
    return prefix + '[' + key + ']';
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;

var pushToArray = function pushToArray(arr, valueOrArray) {
  push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;
var defaultFormat = formats['default'];
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  charset: 'utf-8',
  charsetSentinel: false,
  delimiter: '&',
  encode: true,
  encoder: utils.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
  return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || _typeof(v) === 'symbol' || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  var obj = object;
  var tmpSc = sideChannel;
  var step = 0;
  var findFlag = false;

  while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
    // Where object last appeared in the ref tree
    var pos = tmpSc.get(object);
    step += 1;

    if (typeof pos !== 'undefined') {
      if (pos === step) {
        throw new RangeError('Cyclic object value');
      } else {
        findFlag = true; // Break while
      }
    }

    if (typeof tmpSc.get(sentinel) === 'undefined') {
      step = 0;
    }
  }

  if (typeof filter === 'function') {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate(obj);
  } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
    obj = utils.maybeMap(obj, function (value) {
      if (value instanceof Date) {
        return serializeDate(value);
      }

      return value;
    });
  }

  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
    }

    obj = '';
  }

  if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);

      if (generateArrayPrefix === 'comma' && encodeValuesOnly) {
        var valuesArray = split.call(String(obj), ',');
        var valuesJoined = '';

        for (var i = 0; i < valuesArray.length; ++i) {
          valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults.encoder, charset, 'value', format));
        }

        return [formatter(keyValue) + '=' + valuesJoined];
      }

      return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
    }

    return [formatter(prefix) + '=' + formatter(String(obj))];
  }

  var values = [];

  if (typeof obj === 'undefined') {
    return values;
  }

  var objKeys;

  if (generateArrayPrefix === 'comma' && isArray(obj)) {
    // we need to join elements in
    objKeys = [{
      value: obj.length > 0 ? obj.join(',') || null : void undefined
    }];
  } else if (isArray(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }

  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = _typeof(key) === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

    if (skipNulls && value === null) {
      continue;
    }

    var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? '.' + key : '[' + key + ']');
    sideChannel.set(object, step);
    var valueSideChannel = getSideChannel();
    valueSideChannel.set(sentinel, sideChannel);
    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
  }

  return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
  if (!opts) {
    return defaults;
  }

  if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
    throw new TypeError('Encoder has to be a function.');
  }

  var charset = opts.charset || defaults.charset;

  if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  }

  var format = formats['default'];

  if (typeof opts.format !== 'undefined') {
    if (!has.call(formats.formatters, opts.format)) {
      throw new TypeError('Unknown format option provided.');
    }

    format = opts.format;
  }

  var formatter = formats.formatters[format];
  var filter = defaults.filter;

  if (typeof opts.filter === 'function' || isArray(opts.filter)) {
    filter = opts.filter;
  }

  return {
    addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
    allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
    charset: charset,
    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
    delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
    encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter: filter,
    format: format,
    formatter: formatter,
    serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
    sort: typeof opts.sort === 'function' ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
  };
};

module.exports = function (object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;

  if (typeof options.filter === 'function') {
    filter = options.filter;
    obj = filter('', obj);
  } else if (isArray(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }

  var keys = [];

  if (_typeof(obj) !== 'object' || obj === null) {
    return '';
  }

  var arrayFormat;

  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && 'indices' in opts) {
    arrayFormat = opts.indices ? 'indices' : 'repeat';
  } else {
    arrayFormat = 'indices';
  }

  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

  if (!objKeys) {
    objKeys = Object.keys(obj);
  }

  if (options.sort) {
    objKeys.sort(options.sort);
  }

  var sideChannel = getSideChannel();

  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];

    if (options.skipNulls && obj[key] === null) {
      continue;
    }

    pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
  }

  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? '?' : '';

  if (options.charsetSentinel) {
    if (options.charset === 'iso-8859-1') {
      // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
      prefix += 'utf8=%26%2310003%3B&';
    } else {
      // encodeURIComponent('✓')
      prefix += 'utf8=%E2%9C%93&';
    }
  }

  return joined.length > 0 ? prefix + joined : '';
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"side-channel":175,"./utils":176,"./formats":102}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/qs/lib/parse.js
      101: {
        factory: (module, exports, require) => {
          'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: 'utf-8',
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: '&',
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1000,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};

var interpretNumericEntities = function interpretNumericEntities(str) {
  return str.replace(/&#(\d+);/g, function ($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};

var parseArrayValue = function parseArrayValue(val, options) {
  if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
    return val.split(',');
  }

  return val;
}; // This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.


var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.

var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
  var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1; // Keep track of where the utf8 sentinel was found

  var i;
  var charset = options.charset;

  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf('utf8=') === 0) {
        if (parts[i] === charsetSentinel) {
          charset = 'utf-8';
        } else if (parts[i] === isoSentinel) {
          charset = 'iso-8859-1';
        }

        skipIndex = i;
        i = parts.length; // The eslint settings do not allow break;
      }
    }
  }

  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }

    var part = parts[i];
    var bracketEqualsPos = part.indexOf(']=');
    var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
    var key, val;

    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, 'key');
      val = options.strictNullHandling ? null : '';
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
        return options.decoder(encodedVal, defaults.decoder, charset, 'value');
      });
    }

    if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
      val = interpretNumericEntities(val);
    }

    if (part.indexOf('[]=') > -1) {
      val = isArray(val) ? [val] : val;
    }

    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }

  return obj;
};

var parseObject = function parseObject(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);

  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root = chain[i];

    if (root === '[]' && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
      var index = parseInt(cleanRoot, 10);

      if (!options.parseArrays && cleanRoot === '') {
        obj = {
          0: leaf
        };
      } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
        obj = [];
        obj[index] = leaf;
      } else if (cleanRoot !== '__proto__') {
        obj[cleanRoot] = leaf;
      }
    }

    leaf = obj;
  }

  return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  } // Transform dot notation to bracket notation


  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey; // The regex chunks

  var brackets = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g; // Get the parent

  var segment = options.depth > 0 && brackets.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key; // Stash the parent if it exists

  var keys = [];

  if (parent) {
    // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }

    keys.push(parent);
  } // Loop through children appending to the array until we hit depth


  var i = 0;

  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;

    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }

    keys.push(segment[1]);
  } // If there's a remainder, just add whatever is left


  if (segment) {
    keys.push('[' + key.slice(segment.index) + ']');
  }

  return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
  if (!opts) {
    return defaults;
  }

  if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
    throw new TypeError('Decoder has to be a function.');
  }

  if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  }

  var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
    charset: charset,
    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
  };
};

module.exports = function (str, opts) {
  var options = normalizeParseOptions(opts);

  if (str === '' || str === null || typeof str === 'undefined') {
    return options.plainObjects ? Object.create(null) : {};
  }

  var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
  var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object

  var keys = Object.keys(tempObj);

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
    obj = utils.merge(obj, newObj, options);
  }

  if (options.allowSparse === true) {
    return obj;
  }

  return utils.compact(obj);
};
        },
        map: {"./utils":176}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/qs/lib/formats.js
      102: {
        factory: (module, exports, require) => {
          'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: 'RFC1738',
  RFC3986: 'RFC3986'
};
module.exports = {
  'default': Format.RFC3986,
  formatters: {
    RFC1738: function RFC1738(value) {
      return replace.call(value, percentTwenties, '+');
    },
    RFC3986: function RFC3986(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_basePickBy.js
      103: {
        factory: (module, exports, require) => {
          var baseGet = require('./_baseGet'),
    baseSet = require('./_baseSet'),
    castPath = require('./_castPath');
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;
        },
        map: {"./_baseGet":177,"./_baseSet":178,"./_castPath":92}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/hasIn.js
      104: {
        factory: (module, exports, require) => {
          var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;
        },
        map: {"./_baseHasIn":179,"./_hasPath":180}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/flatten.js
      105: {
        factory: (module, exports, require) => {
          var baseFlatten = require('./_baseFlatten');
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;
        },
        map: {"./_baseFlatten":181}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_overRest.js
      106: {
        factory: (module, exports, require) => {
          var apply = require('./_apply');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;
        },
        map: {"./_apply":182}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_setToString.js
      107: {
        factory: (module, exports, require) => {
          var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;
        },
        map: {"./_baseSetToString":183,"./_shortOut":184}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/mapValues.js
      108: {
        factory: (module, exports, require) => {
          var baseAssignValue = require('./_baseAssignValue'),
    baseForOwn = require('./_baseForOwn'),
    baseIteratee = require('./_baseIteratee');
/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */


function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);
  baseForOwn(object, function (value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;
        },
        map: {"./_baseAssignValue":168,"./_baseForOwn":172,"./_baseIteratee":185}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
      109: {
        factory: (module, exports, require) => {
          var arrayLikeToArray = require("./arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./arrayLikeToArray.js":186}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/iterableToArray.js
      110: {
        factory: (module, exports, require) => {
          function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
      111: {
        factory: (module, exports, require) => {
          var arrayLikeToArray = require("./arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./arrayLikeToArray.js":186}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/nonIterableSpread.js
      112: {
        factory: (module, exports, require) => {
          function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/node_modules/ansi-colors/symbols.js
      113: {
        factory: (module, exports, require) => {
          'use strict';

var isHyper = process.env.TERM_PROGRAM === 'Hyper';
var isWindows = process.platform === 'win32';
var isLinux = process.platform === 'linux';
var common = {
  ballotDisabled: '☒',
  ballotOff: '☐',
  ballotOn: '☑',
  bullet: '•',
  bulletWhite: '◦',
  fullBlock: '█',
  heart: '❤',
  identicalTo: '≡',
  line: '─',
  mark: '※',
  middot: '·',
  minus: '－',
  multiplication: '×',
  obelus: '÷',
  pencilDownRight: '✎',
  pencilRight: '✏',
  pencilUpRight: '✐',
  percent: '%',
  pilcrow2: '❡',
  pilcrow: '¶',
  plusMinus: '±',
  section: '§',
  starsOff: '☆',
  starsOn: '★',
  upDownArrow: '↕'
};
var windows = Object.assign({}, common, {
  check: '√',
  cross: '×',
  ellipsisLarge: '...',
  ellipsis: '...',
  info: 'i',
  question: '?',
  questionSmall: '?',
  pointer: '>',
  pointerSmall: '»',
  radioOff: '( )',
  radioOn: '(*)',
  warning: '‼'
});
var other = Object.assign({}, common, {
  ballotCross: '✘',
  check: '✔',
  cross: '✖',
  ellipsisLarge: '⋯',
  ellipsis: '…',
  info: 'ℹ',
  question: '?',
  questionFull: '？',
  questionSmall: '﹖',
  pointer: isLinux ? '▸' : '❯',
  pointerSmall: isLinux ? '‣' : '›',
  radioOff: '◯',
  radioOn: '◉',
  warning: '⚠'
});
module.exports = isWindows && !isHyper ? windows : other;
Reflect.defineProperty(module.exports, 'common', {
  enumerable: false,
  value: common
});
Reflect.defineProperty(module.exports, 'windows', {
  enumerable: false,
  value: windows
});
Reflect.defineProperty(module.exports, 'other', {
  enumerable: false,
  value: other
});
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/combos.js
      114: {
        factory: (module, exports, require) => {
          'use strict';
/**
 * Actions are mappings from keypress event names to method names
 * in the prompts.
 */

exports.ctrl = {
  a: 'first',
  b: 'backward',
  c: 'cancel',
  d: 'deleteForward',
  e: 'last',
  f: 'forward',
  g: 'reset',
  i: 'tab',
  k: 'cutForward',
  l: 'reset',
  n: 'newItem',
  m: 'cancel',
  j: 'submit',
  p: 'search',
  r: 'remove',
  s: 'save',
  u: 'undo',
  w: 'cutLeft',
  x: 'toggleCursor',
  v: 'paste'
};
exports.shift = {
  up: 'shiftUp',
  down: 'shiftDown',
  left: 'shiftLeft',
  right: 'shiftRight',
  tab: 'prev'
};
exports.fn = {
  up: 'pageUp',
  down: 'pageDown',
  left: 'pageLeft',
  right: 'pageRight',
  "delete": 'deleteForward'
}; // <alt> on Windows

exports.option = {
  b: 'backward',
  f: 'forward',
  d: 'cutRight',
  left: 'cutLeft',
  up: 'altUp',
  down: 'altDown'
};
exports.keys = {
  pageup: 'pageUp',
  // <fn>+<up> (mac), <Page Up> (windows)
  pagedown: 'pageDown',
  // <fn>+<down> (mac), <Page Down> (windows)
  home: 'home',
  // <fn>+<left> (mac), <home> (windows)
  end: 'end',
  // <fn>+<right> (mac), <end> (windows)
  cancel: 'cancel',
  "delete": 'deleteForward',
  backspace: 'delete',
  down: 'down',
  enter: 'submit',
  escape: 'cancel',
  left: 'left',
  space: 'space',
  number: 'number',
  "return": 'submit',
  right: 'right',
  tab: 'next',
  up: 'up'
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/styles.js
      115: {
        factory: (module, exports, require) => {
          'use strict';

var utils = require('./utils');

var colors = require('ansi-colors');

var styles = {
  "default": colors.noop,
  noop: colors.noop,

  /**
   * Modifiers
   */
  set inverse(custom) {
    this._inverse = custom;
  },

  get inverse() {
    return this._inverse || utils.inverse(this.primary);
  },

  set complement(custom) {
    this._complement = custom;
  },

  get complement() {
    return this._complement || utils.complement(this.primary);
  },

  /**
   * Main color
   */
  primary: colors.cyan,

  /**
   * Main palette
   */
  success: colors.green,
  danger: colors.magenta,
  strong: colors.bold,
  warning: colors.yellow,
  muted: colors.dim,
  disabled: colors.gray,
  dark: colors.dim.gray,
  underline: colors.underline,

  set info(custom) {
    this._info = custom;
  },

  get info() {
    return this._info || this.primary;
  },

  set em(custom) {
    this._em = custom;
  },

  get em() {
    return this._em || this.primary.underline;
  },

  set heading(custom) {
    this._heading = custom;
  },

  get heading() {
    return this._heading || this.muted.underline;
  },

  /**
   * Statuses
   */
  set pending(custom) {
    this._pending = custom;
  },

  get pending() {
    return this._pending || this.primary;
  },

  set submitted(custom) {
    this._submitted = custom;
  },

  get submitted() {
    return this._submitted || this.success;
  },

  set cancelled(custom) {
    this._cancelled = custom;
  },

  get cancelled() {
    return this._cancelled || this.danger;
  },

  /**
   * Special styling
   */
  set typing(custom) {
    this._typing = custom;
  },

  get typing() {
    return this._typing || this.dim;
  },

  set placeholder(custom) {
    this._placeholder = custom;
  },

  get placeholder() {
    return this._placeholder || this.primary.dim;
  },

  set highlight(custom) {
    this._highlight = custom;
  },

  get highlight() {
    return this._highlight || this.inverse;
  }

};

styles.merge = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (options.styles && typeof options.styles.enabled === 'boolean') {
    colors.enabled = options.styles.enabled;
  }

  if (options.styles && typeof options.styles.visible === 'boolean') {
    colors.visible = options.styles.visible;
  }

  var result = utils.merge({}, styles, options.styles);
  delete result.merge;

  var _loop = function _loop() {
    var key = _Object$keys[_i];

    if (!result.hasOwnProperty(key)) {
      Reflect.defineProperty(result, key, {
        get: function get() {
          return colors[key];
        }
      });
    }
  };

  for (var _i = 0, _Object$keys = Object.keys(colors); _i < _Object$keys.length; _i++) {
    _loop();
  }

  var _loop2 = function _loop2() {
    var key = _Object$keys2[_i2];

    if (!result.hasOwnProperty(key)) {
      Reflect.defineProperty(result, key, {
        get: function get() {
          return colors[key];
        }
      });
    }
  };

  for (var _i2 = 0, _Object$keys2 = Object.keys(colors.styles); _i2 < _Object$keys2.length; _i2++) {
    _loop2();
  }

  return result;
};

module.exports = styles;
        },
        map: {"./utils":19,"ansi-colors":42}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/symbols.js
      116: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var isWindows = process.platform === 'win32';

var colors = require('ansi-colors');

var utils = require('./utils');

var symbols = _objectSpread(_objectSpread({}, colors.symbols), {}, {
  upDownDoubleArrow: '⇕',
  upDownDoubleArrow2: '⬍',
  upDownArrow: '↕',
  asterisk: '*',
  asterism: '⁂',
  bulletWhite: '◦',
  electricArrow: '⌁',
  ellipsisLarge: '⋯',
  ellipsisSmall: '…',
  fullBlock: '█',
  identicalTo: '≡',
  indicator: colors.symbols.check,
  leftAngle: '‹',
  mark: '※',
  minus: '−',
  multiplication: '×',
  obelus: '÷',
  percent: '%',
  pilcrow: '¶',
  pilcrow2: '❡',
  pencilUpRight: '✐',
  pencilDownRight: '✎',
  pencilRight: '✏',
  plus: '+',
  plusMinus: '±',
  pointRight: '☞',
  rightAngle: '›',
  section: '§',
  hexagon: {
    off: '⬡',
    on: '⬢',
    disabled: '⬢'
  },
  ballot: {
    on: '☑',
    off: '☐',
    disabled: '☒'
  },
  stars: {
    on: '★',
    off: '☆',
    disabled: '☆'
  },
  folder: {
    on: '▼',
    off: '▶',
    disabled: '▶'
  },
  prefix: {
    pending: colors.symbols.question,
    submitted: colors.symbols.check,
    cancelled: colors.symbols.cross
  },
  separator: {
    pending: colors.symbols.pointerSmall,
    submitted: colors.symbols.middot,
    cancelled: colors.symbols.middot
  },
  radio: {
    off: isWindows ? '( )' : '◯',
    on: isWindows ? '(*)' : '◉',
    disabled: isWindows ? '(|)' : 'Ⓘ'
  },
  numbers: ['⓪', '①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱', '⑲', '⑳', '㉑', '㉒', '㉓', '㉔', '㉕', '㉖', '㉗', '㉘', '㉙', '㉚', '㉛', '㉜', '㉝', '㉞', '㉟', '㊱', '㊲', '㊳', '㊴', '㊵', '㊶', '㊷', '㊸', '㊹', '㊺', '㊻', '㊼', '㊽', '㊾', '㊿']
});

symbols.merge = function (options) {
  var result = utils.merge({}, colors.symbols, symbols, options.symbols);
  delete result.merge;
  return result;
};

module.exports = symbols;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"ansi-colors":42,"./utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/get.js
      117: {
        factory: (module, exports, require) => {
          var superPropBase = require("./superPropBase.js");

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }

  return _get.apply(this, arguments);
}

module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./superPropBase.js":187}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/placeholder.js
      118: {
        factory: (module, exports, require) => {
          'use strict';

var utils = require('./utils');
/**
 * Render a placeholder value with cursor and styling based on the
 * position of the cursor.
 *
 * @param {Object} `prompt` Prompt instance.
 * @param {String} `input` Input string.
 * @param {String} `initial` The initial user-provided value.
 * @param {Number} `pos` Current cursor position.
 * @param {Boolean} `showCursor` Render a simulated cursor using the inverse primary style.
 * @return {String} Returns the styled placeholder string.
 * @api public
 */


module.exports = function (prompt) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  prompt.cursorHide();
  var _options$input = options.input,
      input = _options$input === void 0 ? '' : _options$input,
      _options$initial = options.initial,
      initial = _options$initial === void 0 ? '' : _options$initial,
      pos = options.pos,
      _options$showCursor = options.showCursor,
      showCursor = _options$showCursor === void 0 ? true : _options$showCursor,
      color = options.color;
  var style = color || prompt.styles.placeholder;
  var inverse = utils.inverse(prompt.styles.primary);

  var blinker = function blinker(str) {
    return inverse(prompt.styles.black(str));
  };

  var output = input;
  var _char = ' ';
  var reverse = blinker(_char);

  if (prompt.blink && prompt.blink.off === true) {
    blinker = function blinker(str) {
      return str;
    };

    reverse = '';
  }

  if (showCursor && pos === 0 && initial === '' && input === '') {
    return blinker(_char);
  }

  if (showCursor && pos === 0 && (input === initial || input === '')) {
    return blinker(initial[0]) + style(initial.slice(1));
  }

  initial = utils.isPrimitive(initial) ? "".concat(initial) : '';
  input = utils.isPrimitive(input) ? "".concat(input) : '';
  var placeholder = initial && initial.startsWith(input) && initial !== input;
  var cursor = placeholder ? blinker(initial[input.length]) : reverse;

  if (pos !== input.length && showCursor === true) {
    output = input.slice(0, pos) + blinker(input[pos]) + input.slice(pos + 1);
    cursor = '';
  }

  if (showCursor === false) {
    cursor = '';
  }

  if (placeholder) {
    var raw = prompt.styles.unstyle(output + cursor);
    return output + cursor + style(initial.slice(raw.length));
  }

  return output + cursor;
};
        },
        map: {"./utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/completer.js
      119: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var unique = function unique(arr) {
  return arr.filter(function (v, i) {
    return arr.lastIndexOf(v) === i;
  });
};

var compact = function compact(arr) {
  return unique(arr).filter(Boolean);
};

module.exports = function (action) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var _data$past = data.past,
      past = _data$past === void 0 ? [] : _data$past,
      _data$present = data.present,
      present = _data$present === void 0 ? '' : _data$present;
  var rest, prev;

  switch (action) {
    case 'prev':
    case 'undo':
      rest = past.slice(0, past.length - 1);
      prev = past[past.length - 1] || '';
      return {
        past: compact([value].concat(_toConsumableArray(rest))),
        present: prev
      };

    case 'next':
    case 'redo':
      rest = past.slice(1);
      prev = past[0] || '';
      return {
        past: compact([].concat(_toConsumableArray(rest), [value])),
        present: prev
      };

    case 'save':
      return {
        past: compact([].concat(_toConsumableArray(past), [value])),
        present: ''
      };

    case 'remove':
      prev = compact(past.filter(function (v) {
        return v !== value;
      }));
      present = '';

      if (prev.length) {
        present = prev.pop();
      }

      return {
        past: prev,
        present: present
      };

    default:
      {
        throw new Error("Invalid action: \"".concat(action, "\""));
      }
  }
};
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/slicedToArray.js
      120: {
        factory: (module, exports, require) => {
          var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArrayLimit = require("./iterableToArrayLimit.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./arrayWithHoles.js":188,"./iterableToArrayLimit.js":189,"./unsupportedIterableToArray.js":111,"./nonIterableRest.js":190}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/interpolate.js
      121: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _createClass = require("@babel/runtime/helpers/createClass");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var colors = require('ansi-colors');

var clean = function clean() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return typeof str === 'string' ? str.replace(/^['"]|['"]$/g, '') : '';
};
/**
 * This file contains the interpolation and rendering logic for
 * the Snippet prompt.
 */


var Item = /*#__PURE__*/_createClass(function Item(token) {
  _classCallCheck(this, Item);

  this.name = token.key;
  this.field = token.field || {};
  this.value = clean(token.initial || this.field.initial || '');
  this.message = token.message || this.name;
  this.cursor = 0;
  this.input = '';
  this.lines = [];
});

var tokenize = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var options,
        defaults,
        fn,
        unique,
        fields,
        input,
        tabstops,
        items,
        keys,
        line,
        i,
        next,
        peek,
        push,
        value,
        _ret,
        last,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
            defaults = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            fn = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (token) {
              return token;
            };
            unique = new Set();
            fields = options.fields || [];
            input = options.template;
            tabstops = [];
            items = [];
            keys = [];
            line = 1;

            if (!(typeof input === 'function')) {
              _context.next = 14;
              break;
            }

            _context.next = 13;
            return input();

          case 13:
            input = _context.sent;

          case 14:
            i = -1;

            next = function next() {
              return input[++i];
            };

            peek = function peek() {
              return input[i + 1];
            };

            push = function push(token) {
              token.line = line;
              tabstops.push(token);
            };

            push({
              type: 'bos',
              value: ''
            });

          case 19:
            if (!(i < input.length - 1)) {
              _context.next = 40;
              break;
            }

            value = next();

            if (!/^[^\S\n ]$/.test(value)) {
              _context.next = 24;
              break;
            }

            push({
              type: 'text',
              value: value
            });
            return _context.abrupt("continue", 19);

          case 24:
            if (!(value === '\n')) {
              _context.next = 28;
              break;
            }

            push({
              type: 'newline',
              value: value
            });
            line++;
            return _context.abrupt("continue", 19);

          case 28:
            if (!(value === '\\')) {
              _context.next = 32;
              break;
            }

            value += next();
            push({
              type: 'text',
              value: value
            });
            return _context.abrupt("continue", 19);

          case 32:
            if (!((value === '$' || value === '#' || value === '{') && peek() === '{')) {
              _context.next = 36;
              break;
            }

            _ret = function () {
              var n = next();
              value += n;
              var token = {
                type: 'template',
                open: value,
                inner: '',
                close: '',
                value: value
              };
              var ch = void 0;

              while (ch = next()) {
                if (ch === '}') {
                  if (peek() === '}') ch += next();
                  token.value += ch;
                  token.close = ch;
                  break;
                }

                if (ch === ':') {
                  token.initial = '';
                  token.key = token.inner;
                } else if (token.initial !== void 0) {
                  token.initial += ch;
                }

                token.value += ch;
                token.inner += ch;
              }

              token.template = token.open + (token.initial || token.inner) + token.close;
              token.key = token.key || token.inner;

              if (defaults.hasOwnProperty(token.key)) {
                token.initial = defaults[token.key];
              }

              token = fn(token);
              push(token);
              keys.push(token.key);
              unique.add(token.key);
              var item = items.find(function (item) {
                return item.name === token.key;
              });
              token.field = fields.find(function (ch) {
                return ch.name === token.key;
              });

              if (!item) {
                item = new Item(token);
                items.push(item);
              }

              item.lines.push(token.line - 1);
              return "continue";
            }();

            if (!(_ret === "continue")) {
              _context.next = 36;
              break;
            }

            return _context.abrupt("continue", 19);

          case 36:
            last = tabstops[tabstops.length - 1];

            if (last.type === 'text' && last.line === line) {
              last.value += value;
            } else {
              push({
                type: 'text',
                value: value
              });
            }

            _context.next = 19;
            break;

          case 40:
            push({
              type: 'eos',
              value: ''
            });
            return _context.abrupt("return", {
              input: input,
              tabstops: tabstops,
              unique: unique,
              keys: keys,
              items: items
            });

          case 42:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function tokenize() {
    return _ref.apply(this, arguments);
  };
}();

module.exports = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(prompt) {
    var options, required, defaults, _yield$tokenize, tabstops, items, keys, result, format, isValid, isVal;

    return _regeneratorRuntime.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            options = prompt.options;
            required = new Set(options.required === true ? [] : options.required || []);
            defaults = _objectSpread(_objectSpread({}, options.values), options.initial);
            _context5.next = 5;
            return tokenize(options, defaults);

          case 5:
            _yield$tokenize = _context5.sent;
            tabstops = _yield$tokenize.tabstops;
            items = _yield$tokenize.items;
            keys = _yield$tokenize.keys;
            result = createFn('result', prompt, options);
            format = createFn('format', prompt, options);
            isValid = createFn('validate', prompt, options, true);
            isVal = prompt.isValue.bind(prompt);
            return _context5.abrupt("return", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
              var state,
                  submitted,
                  index,
                  validate,
                  _iterator,
                  _step,
                  _loop,
                  _ret2,
                  lines,
                  len,
                  done,
                  _iterator2,
                  _step2,
                  item,
                  _args4 = arguments;

              return _regeneratorRuntime.wrap(function _callee3$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      state = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                      submitted = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
                      index = 0;
                      state.required = required;
                      state.items = items;
                      state.keys = keys;
                      state.output = '';

                      validate = /*#__PURE__*/function () {
                        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(value, state, item, index) {
                          var error;
                          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                            while (1) {
                              switch (_context2.prev = _context2.next) {
                                case 0:
                                  _context2.next = 2;
                                  return isValid(value, state, item, index);

                                case 2:
                                  error = _context2.sent;

                                  if (!(error === false)) {
                                    _context2.next = 5;
                                    break;
                                  }

                                  return _context2.abrupt("return", 'Invalid field ' + item.name);

                                case 5:
                                  return _context2.abrupt("return", error);

                                case 6:
                                case "end":
                                  return _context2.stop();
                              }
                            }
                          }, _callee2);
                        }));

                        return function validate(_x2, _x3, _x4, _x5) {
                          return _ref4.apply(this, arguments);
                        };
                      }();

                      _iterator = _createForOfIteratorHelper(tabstops);
                      _context4.prev = 9;
                      _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
                        var token, value, key, item, val, field, message, error, res, before;
                        return _regeneratorRuntime.wrap(function _loop$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                token = _step.value;
                                value = token.value;
                                key = token.key;

                                if (!(token.type !== 'template')) {
                                  _context3.next = 6;
                                  break;
                                }

                                if (value) state.output += value;
                                return _context3.abrupt("return", "continue");

                              case 6:
                                if (!(token.type === 'template')) {
                                  _context3.next = 35;
                                  break;
                                }

                                item = items.find(function (ch) {
                                  return ch.name === key;
                                });

                                if (options.required === true) {
                                  state.required.add(item.name);
                                }

                                val = [item.input, state.values[item.value], item.value, value].find(isVal);
                                field = item.field || {};
                                message = field.message || token.inner;

                                if (!submitted) {
                                  _context3.next = 25;
                                  break;
                                }

                                _context3.next = 15;
                                return validate(state.values[key], state, item, index);

                              case 15:
                                error = _context3.sent;

                                if (!(error && typeof error === 'string' || error === false)) {
                                  _context3.next = 19;
                                  break;
                                }

                                state.invalid.set(key, error);
                                return _context3.abrupt("return", "continue");

                              case 19:
                                state.invalid["delete"](key);
                                _context3.next = 22;
                                return result(state.values[key], state, item, index);

                              case 22:
                                res = _context3.sent;
                                state.output += colors.unstyle(res);
                                return _context3.abrupt("return", "continue");

                              case 25:
                                item.placeholder = false;
                                before = value;
                                _context3.next = 29;
                                return format(value, state, item, index);

                              case 29:
                                value = _context3.sent;

                                if (val !== value) {
                                  state.values[key] = val;
                                  value = prompt.styles.typing(val);
                                  state.missing["delete"](message);
                                } else {
                                  state.values[key] = void 0;
                                  val = "<".concat(message, ">");
                                  value = prompt.styles.primary(val);
                                  item.placeholder = true;

                                  if (state.required.has(key)) {
                                    state.missing.add(message);
                                  }
                                }

                                if (state.missing.has(message) && state.validating) {
                                  value = prompt.styles.warning(val);
                                }

                                if (state.invalid.has(key) && state.validating) {
                                  value = prompt.styles.danger(val);
                                }

                                if (index === state.index) {
                                  if (before !== value) {
                                    value = prompt.styles.underline(value);
                                  } else {
                                    value = prompt.styles.heading(colors.unstyle(value));
                                  }
                                }

                                index++;

                              case 35:
                                if (value) {
                                  state.output += value;
                                }

                              case 36:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _loop);
                      });

                      _iterator.s();

                    case 12:
                      if ((_step = _iterator.n()).done) {
                        _context4.next = 19;
                        break;
                      }

                      return _context4.delegateYield(_loop(), "t0", 14);

                    case 14:
                      _ret2 = _context4.t0;

                      if (!(_ret2 === "continue")) {
                        _context4.next = 17;
                        break;
                      }

                      return _context4.abrupt("continue", 17);

                    case 17:
                      _context4.next = 12;
                      break;

                    case 19:
                      _context4.next = 24;
                      break;

                    case 21:
                      _context4.prev = 21;
                      _context4.t1 = _context4["catch"](9);

                      _iterator.e(_context4.t1);

                    case 24:
                      _context4.prev = 24;

                      _iterator.f();

                      return _context4.finish(24);

                    case 27:
                      lines = state.output.split('\n').map(function (l) {
                        return ' ' + l;
                      });
                      len = items.length;
                      done = 0;
                      _iterator2 = _createForOfIteratorHelper(items);

                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                          item = _step2.value;

                          if (state.invalid.has(item.name)) {
                            item.lines.forEach(function (i) {
                              if (lines[i][0] !== ' ') return;
                              lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);
                            });
                          }

                          if (prompt.isValue(state.values[item.name])) {
                            done++;
                          }
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }

                      state.completed = (done / len * 100).toFixed(0);
                      state.output = lines.join('\n');
                      return _context4.abrupt("return", state.output);

                    case 35:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee3, null, [[9, 21, 24, 27]]);
            })));

          case 14:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

function createFn(prop, prompt, options, fallback) {
  return function (value, state, item, index) {
    if (typeof item.field[prop] === 'function') {
      return item.field[prop].call(prompt, value, state, item, index);
    }

    return [fallback, value].find(function (v) {
      return prompt.isValue(v);
    });
  };
}
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/classCallCheck":14,"ansi-colors":42}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/set.js
      122: {
        factory: (module, exports, require) => {
          var superPropBase = require("./superPropBase.js");

var defineProperty = require("./defineProperty.js");

function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;

      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }

      desc = Object.getOwnPropertyDescriptor(receiver, property);

      if (desc) {
        if (!desc.writable) {
          return false;
        }

        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }

      return true;
    };
  }

  return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);

  if (!s && isStrict) {
    throw new Error('failed to set property');
  }

  return value;
}

module.exports = _set, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./superPropBase.js":187,"./defineProperty.js":13}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/enquirer/lib/roles.js
      123: {
        factory: (module, exports, require) => {
          'use strict';

var utils = require('./utils');

var roles = {
  "default": function _default(prompt, choice) {
    return choice;
  },
  checkbox: function checkbox(prompt, choice) {
    throw new Error('checkbox role is not implemented yet');
  },
  editable: function editable(prompt, choice) {
    throw new Error('editable role is not implemented yet');
  },
  expandable: function expandable(prompt, choice) {
    throw new Error('expandable role is not implemented yet');
  },
  heading: function heading(prompt, choice) {
    choice.disabled = '';
    choice.indicator = [choice.indicator, ' '].find(function (v) {
      return v != null;
    });
    choice.message = choice.message || '';
    return choice;
  },
  input: function input(prompt, choice) {
    throw new Error('input role is not implemented yet');
  },
  option: function option(prompt, choice) {
    return roles["default"](prompt, choice);
  },
  radio: function radio(prompt, choice) {
    throw new Error('radio role is not implemented yet');
  },
  separator: function separator(prompt, choice) {
    choice.disabled = '';
    choice.indicator = [choice.indicator, ' '].find(function (v) {
      return v != null;
    });
    choice.message = choice.message || prompt.symbols.line.repeat(5);
    return choice;
  },
  spacer: function spacer(prompt, choice) {
    return choice;
  }
};

module.exports = function (name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var role = utils.merge({}, roles, options.roles);
  return role[name] || role["default"];
};
        },
        map: {"./utils":19}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/cross-spawn/index.js
      124: {
        factory: (module, exports, require) => {
          'use strict';

var cp = require('child_process');

var parse = require('./lib/parse');

var enoent = require('./lib/enoent');

function spawn(command, args, options) {
  // Parse the arguments
  var parsed = parse(command, args, options); // Spawn the child process

  var spawned = cp.spawn(parsed.command, parsed.args, parsed.options); // Hook into child process "exit" event to emit an error if the command
  // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16

  enoent.hookChildProcess(spawned, parsed);
  return spawned;
}

function spawnSync(command, args, options) {
  // Parse the arguments
  var parsed = parse(command, args, options); // Spawn the child process

  var result = cp.spawnSync(parsed.command, parsed.args, parsed.options); // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16

  result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
  return result;
}

module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;
module.exports._parse = parse;
module.exports._enoent = enoent;
        },
        map: {"child_process":-19260817,"./lib/parse":191,"./lib/enoent":192}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/strip-eof/index.js
      125: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (x) {
  var lf = typeof x === 'string' ? '\n' : '\n'.charCodeAt();
  var cr = typeof x === 'string' ? '\r' : '\r'.charCodeAt();

  if (x[x.length - 1] === lf) {
    x = x.slice(0, x.length - 1);
  }

  if (x[x.length - 1] === cr) {
    x = x.slice(0, x.length - 1);
  }

  return x;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/npm-run-path/index.js
      126: {
        factory: (module, exports, require) => {
          'use strict';

var path = require('path');

var pathKey = require('path-key');

module.exports = function (opts) {
  opts = Object.assign({
    cwd: process.cwd(),
    path: process.env[pathKey()]
  }, opts);
  var prev;
  var pth = path.resolve(opts.cwd);
  var ret = [];

  while (prev !== pth) {
    ret.push(path.join(pth, 'node_modules/.bin'));
    prev = pth;
    pth = path.resolve(pth, '..');
  } // ensure the running `node` binary is used


  ret.push(path.dirname(process.execPath));
  return ret.concat(opts.path).join(path.delimiter);
};

module.exports.env = function (opts) {
  opts = Object.assign({
    env: process.env
  }, opts);
  var env = Object.assign({}, opts.env);
  var path = pathKey({
    env: env
  });
  opts.path = env[path];
  env[path] = module.exports(opts);
  return env;
};
        },
        map: {"path":-19260817,"path-key":193}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/is-stream/index.js
      127: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var isStream = module.exports = function (stream) {
  return stream !== null && _typeof(stream) === 'object' && typeof stream.pipe === 'function';
};

isStream.writable = function (stream) {
  return isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && _typeof(stream._writableState) === 'object';
};

isStream.readable = function (stream) {
  return isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && _typeof(stream._readableState) === 'object';
};

isStream.duplex = function (stream) {
  return isStream.writable(stream) && isStream.readable(stream);
};

isStream.transform = function (stream) {
  return isStream.duplex(stream) && typeof stream._transform === 'function' && _typeof(stream._transformState) === 'object';
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/get-stream/index.js
      128: {
        factory: (module, exports, require) => {
          'use strict';

var _createClass = require("@babel/runtime/helpers/createClass");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

var _wrapNativeSuper = require("@babel/runtime/helpers/wrapNativeSuper");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var pump = require('pump');

var bufferStream = require('./buffer-stream');

var MaxBufferError = /*#__PURE__*/function (_Error) {
  _inherits(MaxBufferError, _Error);

  var _super = _createSuper(MaxBufferError);

  function MaxBufferError() {
    var _this;

    _classCallCheck(this, MaxBufferError);

    _this = _super.call(this, 'maxBuffer exceeded');
    _this.name = 'MaxBufferError';
    return _this;
  }

  return _createClass(MaxBufferError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

function getStream(inputStream, options) {
  if (!inputStream) {
    return Promise.reject(new Error('Expected a stream'));
  }

  options = Object.assign({
    maxBuffer: Infinity
  }, options);
  var _options = options,
      maxBuffer = _options.maxBuffer;
  var stream;
  return new Promise(function (resolve, reject) {
    var rejectPromise = function rejectPromise(error) {
      if (error) {
        // A null check
        error.bufferedData = stream.getBufferedValue();
      }

      reject(error);
    };

    stream = pump(inputStream, bufferStream(options), function (error) {
      if (error) {
        rejectPromise(error);
        return;
      }

      resolve();
    });
    stream.on('data', function () {
      if (stream.getBufferedLength() > maxBuffer) {
        rejectPromise(new MaxBufferError());
      }
    });
  }).then(function () {
    return stream.getBufferedValue();
  });
}

module.exports = getStream;

module.exports.buffer = function (stream, options) {
  return getStream(stream, Object.assign({}, options, {
    encoding: 'buffer'
  }));
};

module.exports.array = function (stream, options) {
  return getStream(stream, Object.assign({}, options, {
    array: true
  }));
};

module.exports.MaxBufferError = MaxBufferError;
        },
        map: {"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"@babel/runtime/helpers/wrapNativeSuper":194,"pump":195,"./buffer-stream":196}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/p-finally/index.js
      129: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (promise, onFinally) {
  onFinally = onFinally || function () {};

  return promise.then(function (val) {
    return new Promise(function (resolve) {
      resolve(onFinally());
    }).then(function () {
      return val;
    });
  }, function (err) {
    return new Promise(function (resolve) {
      resolve(onFinally());
    }).then(function () {
      throw err;
    });
  });
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/signal-exit/index.js
      130: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var process = global.process;

var processOk = function processOk(process) {
  return process && _typeof(process) === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
}; // some kind of non-node environment, just no-op

/* istanbul ignore if */


if (!processOk(process)) {
  module.exports = function () {
    return function () {};
  };
} else {
  var assert = require('assert');

  var signals = require('./signals.js');

  var isWin = /^win/i.test(process.platform);

  var EE = require('events');
  /* istanbul ignore if */


  if (typeof EE !== 'function') {
    EE = EE.EventEmitter;
  }

  var emitter;

  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__;
  } else {
    emitter = process.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  } // Because this emitter is a global, we have to check to see if a
  // previous version of this library failed to enable infinite listeners.
  // I know what you're about to say.  But literally everything about
  // signal-exit is a compromise with evil.  Get used to it.


  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }

  module.exports = function (cb, opts) {
    /* istanbul ignore if */
    if (!processOk(global.process)) {
      return function () {};
    }

    assert.equal(_typeof(cb), 'function', 'a callback must be provided for exit handler');

    if (loaded === false) {
      load();
    }

    var ev = 'exit';

    if (opts && opts.alwaysLast) {
      ev = 'afterexit';
    }

    var remove = function remove() {
      emitter.removeListener(ev, cb);

      if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {
        unload();
      }
    };

    emitter.on(ev, cb);
    return remove;
  };

  var unload = function unload() {
    if (!loaded || !processOk(global.process)) {
      return;
    }

    loaded = false;
    signals.forEach(function (sig) {
      try {
        process.removeListener(sig, sigListeners[sig]);
      } catch (er) {}
    });
    process.emit = originalProcessEmit;
    process.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  };

  module.exports.unload = unload;

  var emit = function emit(event, code, signal) {
    /* istanbul ignore if */
    if (emitter.emitted[event]) {
      return;
    }

    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  }; // { <signal>: <listener fn>, ... }


  var sigListeners = {};
  signals.forEach(function (sig) {
    sigListeners[sig] = function listener() {
      /* istanbul ignore if */
      if (!processOk(global.process)) {
        return;
      } // If there are no other listeners, an exit is coming!
      // Simplest way: remove us and then re-send the signal.
      // We know that this will kill the process, so we can
      // safely emit now.


      var listeners = process.listeners(sig);

      if (listeners.length === emitter.count) {
        unload();
        emit('exit', null, sig);
        /* istanbul ignore next */

        emit('afterexit', null, sig);
        /* istanbul ignore next */

        if (isWin && sig === 'SIGHUP') {
          // "SIGHUP" throws an `ENOSYS` error on Windows,
          // so use a supported signal instead
          sig = 'SIGINT';
        }
        /* istanbul ignore next */


        process.kill(process.pid, sig);
      }
    };
  });

  module.exports.signals = function () {
    return signals;
  };

  var loaded = false;

  var load = function load() {
    if (loaded || !processOk(global.process)) {
      return;
    }

    loaded = true; // This is the number of onSignalExit's that are in play.
    // It's important so that we can count the correct number of
    // listeners on signals, and don't wait for the other one to
    // handle it instead of us.

    emitter.count += 1;
    signals = signals.filter(function (sig) {
      try {
        process.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process.emit = processEmit;
    process.reallyExit = processReallyExit;
  };

  module.exports.load = load;
  var originalProcessReallyExit = process.reallyExit;

  var processReallyExit = function processReallyExit(code) {
    /* istanbul ignore if */
    if (!processOk(global.process)) {
      return;
    }

    process.exitCode = code ||
    /* istanbul ignore next */
    0;
    emit('exit', process.exitCode, null);
    /* istanbul ignore next */

    emit('afterexit', process.exitCode, null);
    /* istanbul ignore next */

    originalProcessReallyExit.call(process, process.exitCode);
  };

  var originalProcessEmit = process.emit;

  var processEmit = function processEmit(ev, arg) {
    if (ev === 'exit' && processOk(global.process)) {
      /* istanbul ignore else */
      if (arg !== undefined) {
        process.exitCode = arg;
      }

      var ret = originalProcessEmit.apply(this, arguments);
      /* istanbul ignore next */

      emit('exit', process.exitCode, null);
      /* istanbul ignore next */

      emit('afterexit', process.exitCode, null);
      /* istanbul ignore next */

      return ret;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  };
}
        },
        map: {"@babel/runtime/helpers/typeof":12,"assert":-19260817,"./signals.js":197,"events":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/execa/lib/errname.js
      131: {
        factory: (module, exports, require) => {
          'use strict'; // Older verions of Node.js might not have `util.getSystemErrorName()`.
// In that case, fall back to a deprecated internal.

var util = require('util');

var uv;

if (typeof util.getSystemErrorName === 'function') {
  module.exports = util.getSystemErrorName;
} else {
  try {
    uv = process.binding('uv');

    if (typeof uv.errname !== 'function') {
      throw new TypeError('uv.errname is not a function');
    }
  } catch (err) {
    console.error('execa/lib/errname: unable to establish process.binding(\'uv\')', err);
    uv = null;
  }

  module.exports = function (code) {
    return errname(uv, code);
  };
} // Used for testing the fallback behavior


module.exports.__test__ = errname;

function errname(uv, code) {
  if (uv) {
    return uv.errname(code);
  }

  if (!(code < 0)) {
    throw new Error('err >= 0');
  }

  return "Unknown system error ".concat(code);
}
        },
        map: {"util":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/execa/lib/stdio.js
      132: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var alias = ['stdin', 'stdout', 'stderr'];

var hasAlias = function hasAlias(opts) {
  return alias.some(function (x) {
    return Boolean(opts[x]);
  });
};

module.exports = function (opts) {
  if (!opts) {
    return null;
  }

  if (opts.stdio && hasAlias(opts)) {
    throw new Error("It's not possible to provide `stdio` in combination with one of ".concat(alias.map(function (x) {
      return "`".concat(x, "`");
    }).join(', ')));
  }

  if (typeof opts.stdio === 'string') {
    return opts.stdio;
  }

  var stdio = opts.stdio || [];

  if (!Array.isArray(stdio)) {
    throw new TypeError("Expected `stdio` to be of type `string` or `Array`, got `".concat(_typeof(stdio), "`"));
  }

  var result = [];
  var len = Math.max(stdio.length, alias.length);

  for (var i = 0; i < len; i++) {
    var value = null;

    if (stdio[i] !== undefined) {
      value = stdio[i];
    } else if (opts[alias[i]] !== undefined) {
      value = opts[alias[i]];
    }

    result[i] = value;
  }

  return result;
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/util.js
      133: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var cookie = require('cookie');

var yargs = require('@curlconverter/yargs');

var URL = require('url');

var querystring = require('query-string');

var nunjucks = require('nunjucks');

var env = nunjucks.configure(['templates/'], {
  // set folders with templates
  autoescape: false
});
env.addFilter('isArr', function (something) {
  return Array.isArray(something);
});
env.addFilter('isString', function (something) {
  return typeof something === 'string';
});
env.addFilter('isNumber', function (something) {
  return typeof something === 'number';
});

var parseCurlCommand = function parseCurlCommand(curlCommand) {
  // Remove newlines (and from continuations)
  curlCommand = curlCommand.replace(/\\\r|\\\n/g, ''); // Remove extra whitespace

  curlCommand = curlCommand.replace(/\s+/g, ' '); // yargs parses -XPOST as separate arguments. just prescreen for it.

  curlCommand = curlCommand.replace(/ -XPOST/, ' -X POST');
  curlCommand = curlCommand.replace(/ -XGET/, ' -X GET');
  curlCommand = curlCommand.replace(/ -XPUT/, ' -X PUT');
  curlCommand = curlCommand.replace(/ -XPATCH/, ' -X PATCH');
  curlCommand = curlCommand.replace(/ -XDELETE/, ' -X DELETE'); // Safari adds `-Xnull` if is unable to determine the request type, it can be ignored

  curlCommand = curlCommand.replace(/ -Xnull/, ' ');
  curlCommand = curlCommand.trim(); // Parse with some understanding of the meanings of flags.  In particular,
  // boolean flags can be trouble if the URL to fetch follows immediately
  // after, since it will be taken as an argument to the flag rather than
  // interpreted as a positional argument.  Someone should add all the flags
  // likely to cause trouble here.

  var parsedArguments = yargs["boolean"](['I', 'head', 'compressed', 'L', 'k', 'silent', 's']).alias('H', 'header').alias('A', 'user-agent').parse(curlCommand);
  var cookieString;
  var cookies;
  var url = parsedArguments._[1]; // if url argument wasn't where we expected it, try to find it in the other arguments

  if (!url) {
    for (var argName in parsedArguments) {
      if (typeof parsedArguments[argName] === 'string') {
        if (parsedArguments[argName].indexOf('http') === 0 || parsedArguments[argName].indexOf('www.') === 0) {
          url = parsedArguments[argName];
        }
      }
    }
  }

  var headers;

  if (parsedArguments.header) {
    if (!headers) {
      headers = {};
    }

    if (!Array.isArray(parsedArguments.header)) {
      parsedArguments.header = [parsedArguments.header];
    }

    parsedArguments.header.forEach(function (header) {
      if (header.indexOf('Cookie') !== -1) {
        cookieString = header;
      } else {
        var components = header.split(/:(.*)/);

        if (components[1]) {
          headers[components[0]] = components[1].trim();
        }
      }
    });
  }

  if (parsedArguments['user-agent']) {
    if (!headers) {
      headers = {};
    }

    headers['User-Agent'] = parsedArguments['user-agent'];
  }

  if (parsedArguments.b) {
    cookieString = parsedArguments.b;
  }

  if (parsedArguments.cookie) {
    cookieString = parsedArguments.cookie;
  }

  var multipartUploads;

  if (parsedArguments.F) {
    multipartUploads = {};

    if (!Array.isArray(parsedArguments.F)) {
      parsedArguments.F = [parsedArguments.F];
    }

    parsedArguments.F.forEach(function (multipartArgument) {
      // input looks like key=value. value could be json or a file path prepended with an @
      var splitArguments = multipartArgument.split('=', 2);
      var key = splitArguments[0];
      var value = splitArguments[1];
      multipartUploads[key] = value;
    });
  }

  if (cookieString) {
    var cookieParseOptions = {
      decode: function decode(s) {
        return s;
      }
    }; // separate out cookie headers into separate data structure
    // note: cookie is case insensitive

    cookies = cookie.parse(cookieString.replace(/^Cookie: /gi, ''), cookieParseOptions);
  }

  var method;

  if (parsedArguments.X === 'POST') {
    method = 'post';
  } else if (parsedArguments.X === 'PUT' || parsedArguments.T) {
    method = 'put';
  } else if (parsedArguments.X === 'PATCH') {
    method = 'patch';
  } else if (parsedArguments.X === 'DELETE') {
    method = 'delete';
  } else if (parsedArguments.X === 'OPTIONS') {
    method = 'options';
  } else if ((parsedArguments.d || parsedArguments.data || parsedArguments['data-ascii'] || parsedArguments['data-binary'] || parsedArguments['data-raw'] || parsedArguments.F || parsedArguments.form) && !(parsedArguments.G || parsedArguments.get)) {
    method = 'post';
  } else if (parsedArguments.I || parsedArguments.head) {
    method = 'head';
  } else {
    method = 'get';
  }

  var compressed = !!parsedArguments.compressed;
  var urlObject = URL.parse(url); // eslint-disable-line
  // if GET request with data, convert data to query string
  // NB: the -G flag does not change the http verb. It just moves the data into the url.

  if (parsedArguments.G || parsedArguments.get) {
    urlObject.query = urlObject.query ? urlObject.query : '';
    var option = 'd' in parsedArguments ? 'd' : 'data' in parsedArguments ? 'data' : null;

    if (option) {
      var urlQueryString = '';

      if (url.indexOf('?') < 0) {
        url += '?';
      } else {
        urlQueryString += '&';
      }

      if (_typeof(parsedArguments[option]) === 'object') {
        urlQueryString += parsedArguments[option].join('&');
      } else {
        urlQueryString += parsedArguments[option];
      }

      urlObject.query += urlQueryString;
      url += urlQueryString;
      delete parsedArguments[option];
    }
  }

  if (urlObject.query && urlObject.query.endsWith('&')) {
    urlObject.query = urlObject.query.slice(0, -1);
  }

  var query = querystring.parse(urlObject.query, {
    sort: false
  });

  for (var param in query) {
    if (query[param] === null) {
      query[param] = '';
    }
  }

  urlObject.search = null; // Clean out the search/query portion.

  var request = {
    url: url,
    urlWithoutQuery: URL.format(urlObject)
  };

  if (compressed) {
    request.compressed = true;
  }

  if (Object.keys(query).length > 0) {
    request.query = query;
  }

  if (headers) {
    request.headers = headers;
  }

  request.method = method;

  if (cookies) {
    request.cookies = cookies;
    request.cookieString = cookieString.replace('Cookie: ', '');
  }

  if (multipartUploads) {
    request.multipartUploads = multipartUploads;
  }

  if (parsedArguments.data) {
    request.data = parsedArguments.data;
  } else if (parsedArguments['data-binary']) {
    request.data = parsedArguments['data-binary'];
    request.isDataBinary = true;
  } else if (parsedArguments.d) {
    request.data = parsedArguments.d;
  } else if (parsedArguments['data-ascii']) {
    request.data = parsedArguments['data-ascii'];
  } else if (parsedArguments['data-raw']) {
    request.data = parsedArguments['data-raw'];
    request.isDataRaw = true;
  }

  if (parsedArguments.u) {
    request.auth = parsedArguments.u;
  }

  if (parsedArguments.user) {
    request.auth = parsedArguments.user;
  }

  if (Array.isArray(request.data)) {
    request.dataArray = request.data;
    request.data = request.data.join('&');
  }

  if (parsedArguments.k || parsedArguments.insecure) {
    request.insecure = true;
  }

  return request;
};

var serializeCookies = function serializeCookies(cookieDict) {
  var cookieString = '';
  var i = 0;
  var cookieCount = Object.keys(cookieDict).length;

  for (var cookieName in cookieDict) {
    var cookieValue = cookieDict[cookieName];
    cookieString += cookieName + '=' + cookieValue;

    if (i < cookieCount - 1) {
      cookieString += '; ';
    }

    i++;
  }

  return cookieString;
};

module.exports = {
  parseCurlCommand: parseCurlCommand,
  serializeCookies: serializeCookies
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"cookie":198,"@curlconverter/yargs":199,"url":-19260817,"query-string":135,"nunjucks":134}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/index.js
      134: {
        factory: (module, exports, require) => {
          'use strict';

var lib = require('./src/lib');

var _require = require('./src/environment'),
    Environment = _require.Environment,
    Template = _require.Template;

var Loader = require('./src/loader');

var loaders = require('./src/loaders');

var precompile = require('./src/precompile');

var compiler = require('./src/compiler');

var parser = require('./src/parser');

var lexer = require('./src/lexer');

var runtime = require('./src/runtime');

var nodes = require('./src/nodes');

var installJinjaCompat = require('./src/jinja-compat'); // A single instance of an environment, since this is so commonly used


var e;

function configure(templatesPath, opts) {
  opts = opts || {};

  if (lib.isObject(templatesPath)) {
    opts = templatesPath;
    templatesPath = null;
  }

  var TemplateLoader;

  if (loaders.FileSystemLoader) {
    TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
      watch: opts.watch,
      noCache: opts.noCache
    });
  } else if (loaders.WebLoader) {
    TemplateLoader = new loaders.WebLoader(templatesPath, {
      useCache: opts.web && opts.web.useCache,
      async: opts.web && opts.web.async
    });
  }

  e = new Environment(TemplateLoader, opts);

  if (opts && opts.express) {
    e.express(opts.express);
  }

  return e;
}

module.exports = {
  Environment: Environment,
  Template: Template,
  Loader: Loader,
  FileSystemLoader: loaders.FileSystemLoader,
  NodeResolveLoader: loaders.NodeResolveLoader,
  PrecompiledLoader: loaders.PrecompiledLoader,
  WebLoader: loaders.WebLoader,
  compiler: compiler,
  parser: parser,
  lexer: lexer,
  runtime: runtime,
  lib: lib,
  nodes: nodes,
  installJinjaCompat: installJinjaCompat,
  configure: configure,
  reset: function reset() {
    e = undefined;
  },
  compile: function compile(src, env, path, eagerCompile) {
    if (!e) {
      configure();
    }

    return new Template(src, env, path, eagerCompile);
  },
  render: function render(name, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.render(name, ctx, cb);
  },
  renderString: function renderString(src, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.renderString(src, ctx, cb);
  },
  precompile: precompile ? precompile.precompile : undefined,
  precompileString: precompile ? precompile.precompileString : undefined
};
        },
        map: {"./src/lib":200,"./src/environment":201,"./src/loader":202,"./src/loaders":203,"./src/precompile":204,"./src/compiler":205,"./src/parser":206,"./src/lexer":207,"./src/runtime":208,"./src/nodes":209,"./src/jinja-compat":210}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/query-string/index.js
      135: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _typeof = require("@babel/runtime/helpers/typeof");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var strictUriEncode = require('strict-uri-encode');

var decodeComponent = require('decode-uri-component');

var splitOnFirst = require('split-on-first');

var filterObject = require('filter-obj');

var isNullOrUndefined = function isNullOrUndefined(value) {
  return value === null || value === undefined;
};

var encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

function encoderForArrayFormat(options) {
  switch (options.arrayFormat) {
    case 'index':
      return function (key) {
        return function (result, value) {
          var index = result.length;

          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [[encode(key, options), '[', index, ']'].join('')]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')]);
        };
      };

    case 'bracket':
      return function (key) {
        return function (result, value) {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [[encode(key, options), '[]'].join('')]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), '[]=', encode(value, options)].join('')]);
        };
      };

    case 'colon-list-separator':
      return function (key) {
        return function (result, value) {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [[encode(key, options), ':list='].join('')]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), ':list=', encode(value, options)].join('')]);
        };
      };

    case 'comma':
    case 'separator':
    case 'bracket-separator':
      {
        var keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
        return function (key) {
          return function (result, value) {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            } // Translate null to an empty string so that it doesn't serialize as 'null'


            value = value === null ? '' : value;

            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
            }

            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        };
      }

    default:
      return function (key) {
        return function (result, value) {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [encode(key, options)]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), '=', encode(value, options)].join('')]);
        };
      };
  }
}

function parserForArrayFormat(options) {
  var result;

  switch (options.arrayFormat) {
    case 'index':
      return function (key, value, accumulator) {
        result = /\[(\d*)\]$/.exec(key);
        key = key.replace(/\[\d*\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = {};
        }

        accumulator[key][result[1]] = value;
      };

    case 'bracket':
      return function (key, value, accumulator) {
        result = /(\[\])$/.exec(key);
        key = key.replace(/\[\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = [value];
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };

    case 'colon-list-separator':
      return function (key, value, accumulator) {
        result = /(:list)$/.exec(key);
        key = key.replace(/:list$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = [value];
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };

    case 'comma':
    case 'separator':
      return function (key, value, accumulator) {
        var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
        var isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
        value = isEncodedArray ? decode(value, options) : value;
        var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(function (item) {
          return decode(item, options);
        }) : value === null ? value : decode(value, options);
        accumulator[key] = newValue;
      };

    case 'bracket-separator':
      return function (key, value, accumulator) {
        var isArray = /(\[\])$/.test(key);
        key = key.replace(/\[\]$/, '');

        if (!isArray) {
          accumulator[key] = value ? decode(value, options) : value;
          return;
        }

        var arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(function (item) {
          return decode(item, options);
        });

        if (accumulator[key] === undefined) {
          accumulator[key] = arrayValue;
          return;
        }

        accumulator[key] = [].concat(accumulator[key], arrayValue);
      };

    default:
      return function (key, value, accumulator) {
        if (accumulator[key] === undefined) {
          accumulator[key] = value;
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };
  }
}

function validateArrayFormatSeparator(value) {
  if (typeof value !== 'string' || value.length !== 1) {
    throw new TypeError('arrayFormatSeparator must be single character string');
  }
}

function encode(value, options) {
  if (options.encode) {
    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
  }

  return value;
}

function decode(value, options) {
  if (options.decode) {
    return decodeComponent(value);
  }

  return value;
}

function keysSorter(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }

  if (_typeof(input) === 'object') {
    return keysSorter(Object.keys(input)).sort(function (a, b) {
      return Number(a) - Number(b);
    }).map(function (key) {
      return input[key];
    });
  }

  return input;
}

function removeHash(input) {
  var hashStart = input.indexOf('#');

  if (hashStart !== -1) {
    input = input.slice(0, hashStart);
  }

  return input;
}

function getHash(url) {
  var hash = '';
  var hashStart = url.indexOf('#');

  if (hashStart !== -1) {
    hash = url.slice(hashStart);
  }

  return hash;
}

function extract(input) {
  input = removeHash(input);
  var queryStart = input.indexOf('?');

  if (queryStart === -1) {
    return '';
  }

  return input.slice(queryStart + 1);
}

function parseValue(value, options) {
  if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
    value = Number(value);
  } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
    value = value.toLowerCase() === 'true';
  }

  return value;
}

function parse(query, options) {
  options = Object.assign({
    decode: true,
    sort: true,
    arrayFormat: 'none',
    arrayFormatSeparator: ',',
    parseNumbers: false,
    parseBooleans: false
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);
  var formatter = parserForArrayFormat(options); // Create an object with no prototype

  var ret = Object.create(null);

  if (typeof query !== 'string') {
    return ret;
  }

  query = query.trim().replace(/^[?#&]/, '');

  if (!query) {
    return ret;
  }

  var _iterator = _createForOfIteratorHelper(query.split('&')),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var param = _step.value;

      if (param === '') {
        continue;
      }

      var _splitOnFirst = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '='),
          _splitOnFirst2 = _slicedToArray(_splitOnFirst, 2),
          _key = _splitOnFirst2[0],
          _value = _splitOnFirst2[1]; // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters


      _value = _value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? _value : decode(_value, options);
      formatter(decode(_key, options), _value, ret);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  for (var _i = 0, _Object$keys = Object.keys(ret); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var value = ret[key];

    if (_typeof(value) === 'object' && value !== null) {
      for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {
        var k = _Object$keys2[_i2];
        value[k] = parseValue(value[k], options);
      }
    } else {
      ret[key] = parseValue(value, options);
    }
  }

  if (options.sort === false) {
    return ret;
  }

  return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(function (result, key) {
    var value = ret[key];

    if (Boolean(value) && _typeof(value) === 'object' && !Array.isArray(value)) {
      // Sort object keys, not values
      result[key] = keysSorter(value);
    } else {
      result[key] = value;
    }

    return result;
  }, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = function (object, options) {
  if (!object) {
    return '';
  }

  options = Object.assign({
    encode: true,
    strict: true,
    arrayFormat: 'none',
    arrayFormatSeparator: ','
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);

  var shouldFilter = function shouldFilter(key) {
    return options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
  };

  var formatter = encoderForArrayFormat(options);
  var objectCopy = {};

  for (var _i3 = 0, _Object$keys3 = Object.keys(object); _i3 < _Object$keys3.length; _i3++) {
    var key = _Object$keys3[_i3];

    if (!shouldFilter(key)) {
      objectCopy[key] = object[key];
    }
  }

  var keys = Object.keys(objectCopy);

  if (options.sort !== false) {
    keys.sort(options.sort);
  }

  return keys.map(function (key) {
    var value = object[key];

    if (value === undefined) {
      return '';
    }

    if (value === null) {
      return encode(key, options);
    }

    if (Array.isArray(value)) {
      if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
        return encode(key, options) + '[]';
      }

      return value.reduce(formatter(key), []).join('&');
    }

    return encode(key, options) + '=' + encode(value, options);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&');
};

exports.parseUrl = function (url, options) {
  options = Object.assign({
    decode: true
  }, options);

  var _splitOnFirst3 = splitOnFirst(url, '#'),
      _splitOnFirst4 = _slicedToArray(_splitOnFirst3, 2),
      url_ = _splitOnFirst4[0],
      hash = _splitOnFirst4[1];

  return Object.assign({
    url: url_.split('?')[0] || '',
    query: parse(extract(url), options)
  }, options && options.parseFragmentIdentifier && hash ? {
    fragmentIdentifier: decode(hash, options)
  } : {});
};

exports.stringifyUrl = function (object, options) {
  options = Object.assign(_defineProperty({
    encode: true,
    strict: true
  }, encodeFragmentIdentifier, true), options);
  var url = removeHash(object.url).split('?')[0] || '';
  var queryFromUrl = exports.extract(object.url);
  var parsedQueryFromUrl = exports.parse(queryFromUrl, {
    sort: false
  });
  var query = Object.assign(parsedQueryFromUrl, object.query);
  var queryString = exports.stringify(query, options);

  if (queryString) {
    queryString = "?".concat(queryString);
  }

  var hash = getHash(object.url);

  if (object.fragmentIdentifier) {
    hash = "#".concat(options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier);
  }

  return "".concat(url).concat(queryString).concat(hash);
};

exports.pick = function (input, filter, options) {
  options = Object.assign(_defineProperty({
    parseFragmentIdentifier: true
  }, encodeFragmentIdentifier, false), options);

  var _exports$parseUrl = exports.parseUrl(input, options),
      url = _exports$parseUrl.url,
      query = _exports$parseUrl.query,
      fragmentIdentifier = _exports$parseUrl.fragmentIdentifier;

  return exports.stringifyUrl({
    url: url,
    query: filterObject(query, filter),
    fragmentIdentifier: fragmentIdentifier
  }, options);
};

exports.exclude = function (input, filter, options) {
  var exclusionFilter = Array.isArray(filter) ? function (key) {
    return !filter.includes(key);
  } : function (key, value) {
    return !filter(key, value);
  };
  return exports.pick(input, exclusionFilter, options);
};
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/slicedToArray":120,"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/toConsumableArray":35,"strict-uri-encode":211,"decode-uri-component":212,"split-on-first":213,"filter-obj":214}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/templates/ansible.js
      136: {
        factory: (module, exports, require) => {
          var ansibleTemplate = "-\n  name: '{{ request.urlWithoutQuery }}'\n  uri:\n    url: '{{ request.url }}'\n    method: {{ request.method | upper }}\n{%- if (request.data | isString) or (request.data | isNumber) %}\n    body:\n      {{ data | dump }}\n    {%- if request.data | isNumber %}\n    body_format: raw\n    {%- else %}\n    body_format: json\n    {%- endif %}\n{%- endif %}\n{%- if request.headers %}\n    headers:\n    {%- for key, value in request.headers %}\n      {{ key }}: '{{ value }}'\n    {%- endfor %}\n    {%- if request.cookieString %}\n      Cookie: '{{ request.cookieString }}'\n    {%- endif %}\n{%- endif %}\n{%- if request.auth %}\n    {%- set url_username = request.auth.split(\":\")[0] %}\n    {%- set url_password = request.auth.split(\":\")[1] %}\n    {%- if url_username %}\n    url_username: {{ url_username }}\n    {%- endif %}\n    {%- if url_password %}\n    url_password: {{ url_password }}\n    {%- endif %}\n{%- endif %}\n{%- if request.insecure %}\n    validate_certs: no\n{%- endif %}\n  register: result\n";
module.exports = ansibleTemplate;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/node_modules/jsesc/jsesc.js
      137: {
        factory: (module, exports, require) => {
          'use strict';

var object = {};
var hasOwnProperty = object.hasOwnProperty;

var forOwn = function forOwn(object, callback) {
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      callback(key, object[key]);
    }
  }
};

var extend = function extend(destination, source) {
  if (!source) {
    return destination;
  }

  forOwn(source, function (key, value) {
    destination[key] = value;
  });
  return destination;
};

var forEach = function forEach(array, callback) {
  var length = array.length;
  var index = -1;

  while (++index < length) {
    callback(array[index]);
  }
};

var fourHexEscape = function fourHexEscape(hex) {
  return "\\u" + ('0000' + hex).slice(-4);
};

var hexadecimal = function hexadecimal(code, lowercase) {
  var hexadecimal = code.toString(16);
  if (lowercase) return hexadecimal;
  return hexadecimal.toUpperCase();
};

var toString = object.toString;
var isArray = Array.isArray;

var isBuffer = function isBuffer(value) {
  return typeof Buffer === 'function' && Buffer.isBuffer(value);
};

var isObject = function isObject(value) {
  // This is a very simple check, but it’s good enough for what we need.
  return toString.call(value) == '[object Object]';
};

var isString = function isString(value) {
  return typeof value == 'string' || toString.call(value) == '[object String]';
};

var isNumber = function isNumber(value) {
  return typeof value == 'number' || toString.call(value) == '[object Number]';
};

var isFunction = function isFunction(value) {
  return typeof value == 'function';
};

var isMap = function isMap(value) {
  return toString.call(value) == '[object Map]';
};

var isSet = function isSet(value) {
  return toString.call(value) == '[object Set]';
};
/*--------------------------------------------------------------------------*/
// https://mathiasbynens.be/notes/javascript-escapes#single


var singleEscapes = {
  '\\': '\\\\',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t' // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
  // '\v': '\\x0B'

};
var regexSingleEscape = /[\\\b\f\n\r\t]/;
var regexDigit = /[0-9]/;
var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;

var jsesc = function jsesc(argument, options) {
  var increaseIndentation = function increaseIndentation() {
    oldIndent = indent;
    ++options.indentLevel;
    indent = options.indent.repeat(options.indentLevel);
  }; // Handle options


  var defaults = {
    'escapeEverything': false,
    'minimal': false,
    'isScriptContext': false,
    'quotes': 'single',
    'wrap': false,
    'es6': false,
    'json': false,
    'compact': true,
    'lowercaseHex': false,
    'numbers': 'decimal',
    'indent': '\t',
    'indentLevel': 0,
    '__inline1__': false,
    '__inline2__': false
  };
  var json = options && options.json;

  if (json) {
    defaults.quotes = 'double';
    defaults.wrap = true;
  }

  options = extend(defaults, options);

  if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
    options.quotes = 'single';
  }

  var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
  var compact = options.compact;
  var lowercaseHex = options.lowercaseHex;
  var indent = options.indent.repeat(options.indentLevel);
  var oldIndent = '';
  var inline1 = options.__inline1__;
  var inline2 = options.__inline2__;
  var newLine = compact ? '' : '\n';
  var result;
  var isEmpty = true;
  var useBinNumbers = options.numbers == 'binary';
  var useOctNumbers = options.numbers == 'octal';
  var useDecNumbers = options.numbers == 'decimal';
  var useHexNumbers = options.numbers == 'hexadecimal';

  if (json && argument && isFunction(argument.toJSON)) {
    argument = argument.toJSON();
  }

  if (!isString(argument)) {
    if (isMap(argument)) {
      if (argument.size == 0) {
        return 'new Map()';
      }

      if (!compact) {
        options.__inline1__ = true;
        options.__inline2__ = false;
      }

      return 'new Map(' + jsesc(Array.from(argument), options) + ')';
    }

    if (isSet(argument)) {
      if (argument.size == 0) {
        return 'new Set()';
      }

      return 'new Set(' + jsesc(Array.from(argument), options) + ')';
    }

    if (isBuffer(argument)) {
      if (argument.length == 0) {
        return 'Buffer.from([])';
      }

      return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
    }

    if (isArray(argument)) {
      result = [];
      options.wrap = true;

      if (inline1) {
        options.__inline1__ = false;
        options.__inline2__ = true;
      }

      if (!inline2) {
        increaseIndentation();
      }

      forEach(argument, function (value) {
        isEmpty = false;

        if (inline2) {
          options.__inline2__ = false;
        }

        result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
      });

      if (isEmpty) {
        return '[]';
      }

      if (inline2) {
        return '[' + result.join(', ') + ']';
      }

      return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
    } else if (isNumber(argument)) {
      if (json) {
        // Some number values (e.g. `Infinity`) cannot be represented in JSON.
        return JSON.stringify(argument);
      }

      if (useDecNumbers) {
        return String(argument);
      }

      if (useHexNumbers) {
        var _hexadecimal = argument.toString(16);

        if (!lowercaseHex) {
          _hexadecimal = _hexadecimal.toUpperCase();
        }

        return '0x' + _hexadecimal;
      }

      if (useBinNumbers) {
        return '0b' + argument.toString(2);
      }

      if (useOctNumbers) {
        return '0o' + argument.toString(8);
      }
    } else if (!isObject(argument)) {
      if (json) {
        // For some values (e.g. `undefined`, `function` objects),
        // `JSON.stringify(value)` returns `undefined` (which isn’t valid
        // JSON) instead of `'null'`.
        return JSON.stringify(argument) || 'null';
      }

      return String(argument);
    } else {
      // it’s an object
      result = [];
      options.wrap = true;
      increaseIndentation();
      forOwn(argument, function (key, value) {
        isEmpty = false;
        result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
      });

      if (isEmpty) {
        return '{}';
      }

      return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
    }
  }

  var regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
  result = argument.replace(regex, function (_char, pair, lone, quoteChar, index, string) {
    if (pair) {
      if (options.minimal) return pair;
      var first = pair.charCodeAt(0);
      var second = pair.charCodeAt(1);

      if (options.es6) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;

        var _hex = hexadecimal(codePoint, lowercaseHex);

        return "\\u{" + _hex + '}';
      }

      return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
    }

    if (lone) {
      return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
    }

    if (_char == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
      return '\\0';
    }

    if (quoteChar) {
      if (quoteChar == quote || options.escapeEverything) {
        return '\\' + quoteChar;
      }

      return quoteChar;
    }

    if (regexSingleEscape.test(_char)) {
      // no need for a `hasOwnProperty` check here
      return singleEscapes[_char];
    }

    if (options.minimal && !regexWhitespace.test(_char)) {
      return _char;
    }

    var hex = hexadecimal(_char.charCodeAt(0), lowercaseHex);

    if (json || hex.length > 2) {
      return fourHexEscape(hex);
    }

    return '\\x' + ('00' + hex).slice(-2);
  });

  if (quote == '`') {
    result = result.replace(/\$\{/g, '\\${');
  }

  if (options.isScriptContext) {
    // https://mathiasbynens.be/notes/etago
    result = result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
  }

  if (options.wrap) {
    result = quote + result + quote;
  }

  return result;
};

jsesc.version = '3.0.2';
module.exports = jsesc;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/string.prototype.startswith/index.js
      138: {
        factory: (module, exports, require) => {
          /*! https://mths.be/startswith v1.0.0 by @mathias */
'use strict';

var callBind = require('es-abstract/helpers/callBind');

var define = require('define-properties');

var implementation = require('./implementation');

var getPolyfill = require('./polyfill');

var shim = require('./shim');

var boundStartsWith = callBind(getPolyfill());
define(boundStartsWith, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = boundStartsWith;
        },
        map: {"es-abstract/helpers/callBind":215,"define-properties":216,"./implementation":217,"./polyfill":218,"./shim":219}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/javascript/fetch.js
      139: {
        factory: (module, exports, require) => {
          var util = require('../../util');

var jsesc = require('jsesc');

var toJsFetch = function toJsFetch(curlCommand) {
  var request = util.parseCurlCommand(curlCommand);
  var jsFetchCode = '';

  if (request.data === true) {
    request.data = '';
  }

  if (request.data) {
    if (typeof request.data === 'number') {
      request.data = request.data.toString();
    } // escape single quotes if there are any in there


    if (request.data.indexOf("'") > -1) {
      request.data = jsesc(request.data);
    }

    try {
      JSON.parse(request.data);

      if (!request.headers) {
        request.headers = {};
      }

      if (!request.headers['Content-Type']) {
        request.headers['Content-Type'] = 'application/json; charset=UTF-8';
      }

      request.data = 'JSON.stringify(' + request.data + ')';
    } catch (_unused) {
      request.data = '\'' + request.data + '\'';
    }
  }

  jsFetchCode += 'fetch(\'' + request.url + '\'';

  if (request.method !== 'get' || request.headers || request.cookies || request.auth || request.body) {
    jsFetchCode += ', {\n';

    if (request.method !== 'get') {
      jsFetchCode += '    method: \'' + request.method.toUpperCase() + '\'';
    }

    if (request.headers || request.cookies || request.auth) {
      if (request.method !== 'get') {
        jsFetchCode += ',\n';
      }

      jsFetchCode += '    headers: {\n';
      var headerCount = Object.keys(request.headers || {}).length;
      var i = 0;

      for (var headerName in request.headers) {
        jsFetchCode += '        \'' + headerName + '\': \'' + request.headers[headerName] + '\'';

        if (i < headerCount - 1 || request.cookies || request.auth) {
          jsFetchCode += ',\n';
        }

        i++;
      }

      if (request.auth) {
        var splitAuth = request.auth.split(':');
        var user = splitAuth[0] || '';
        var password = splitAuth[1] || '';
        jsFetchCode += '        \'Authorization\': \'Basic \' + btoa(\'' + user + ':' + password + '\')';
      }

      if (request.cookies) {
        var cookieString = util.serializeCookies(request.cookies);
        jsFetchCode += '        \'Cookie\': \'' + cookieString + '\'';
      }

      jsFetchCode += '\n    }';
    }

    if (request.data) {
      jsFetchCode += ',\n    body: ' + request.data;
    }

    jsFetchCode += '\n}';
  }

  jsFetchCode += ');';
  return jsFetchCode + '\n';
};

module.exports = toJsFetch;
        },
        map: {"../../util":133,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Yaml.js
      140: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var Dumper, Parser, Utils, Yaml;
Parser = require('./Parser');
Dumper = require('./Dumper');
Utils = require('./Utils');

Yaml = function () {
  function Yaml() {}

  Yaml.parse = function (input, exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }

    if (objectDecoder == null) {
      objectDecoder = null;
    }

    return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
  };

  Yaml.parseFile = function (path, callback, exceptionOnInvalidType, objectDecoder) {
    var input;

    if (callback == null) {
      callback = null;
    }

    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }

    if (objectDecoder == null) {
      objectDecoder = null;
    }

    if (callback != null) {
      return Utils.getStringFromFile(path, function (_this) {
        return function (input) {
          var result;
          result = null;

          if (input != null) {
            result = _this.parse(input, exceptionOnInvalidType, objectDecoder);
          }

          callback(result);
        };
      }(this));
    } else {
      input = Utils.getStringFromFile(path);

      if (input != null) {
        return this.parse(input, exceptionOnInvalidType, objectDecoder);
      }

      return null;
    }
  };

  Yaml.dump = function (input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var yaml;

    if (inline == null) {
      inline = 2;
    }

    if (indent == null) {
      indent = 4;
    }

    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }

    if (objectEncoder == null) {
      objectEncoder = null;
    }

    yaml = new Dumper();
    yaml.indentation = indent;
    return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.stringify = function (input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
  };

  Yaml.load = function (path, callback, exceptionOnInvalidType, objectDecoder) {
    return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
  };

  return Yaml;
}();

if (typeof window !== "undefined" && window !== null) {
  window.YAML = Yaml;
}

if (typeof window === "undefined" || window === null) {
  this.YAML = Yaml;
}

module.exports = Yaml;
        },
        map: {"./Parser":220,"./Dumper":221,"./Utils":222}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/matlab/webservices.js
      141: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _require = require('./common'),
    repr = _require.repr,
    setVariableValue = _require.setVariableValue,
    callFunction = _require.callFunction,
    addCellArray = _require.addCellArray,
    structify = _require.structify,
    containsBody = _require.containsBody,
    prepareQueryString = _require.prepareQueryString,
    prepareCookies = _require.prepareCookies,
    cookieString = _require.cookieString,
    paramsString = _require.paramsString;

var isSupportedByWebServices = function isSupportedByWebServices(request) {
  if (!new Set(['get', 'post', 'put', 'delete', 'patch']).has(request.method)) {
    return false;
  }

  return !request.multipartUploads && !request.insecure;
};

var parseWebOptions = function parseWebOptions(request) {
  var options = {}; // MATLAB uses GET in `webread` and POST in `webwrite` by default
  // thus, it is necessary to set the method for other requests

  if (request.method !== 'get' && request.method !== 'post') {
    options.RequestMethod = request.method;
  }

  var headers = {};

  if (request.auth) {
    var _request$auth$split = request.auth.split(':'),
        _request$auth$split2 = _slicedToArray(_request$auth$split, 2),
        username = _request$auth$split2[0],
        password = _request$auth$split2[1];

    if (username !== '') {
      options.Username = username;
      options.Password = password;
    } else {
      headers.Authorization = "['Basic ' matlab.net.base64encode(".concat(repr(username + ':' + password), ")]");
    }
  }

  if (request.headers) {
    for (var _i = 0, _Object$entries = Object.entries(request.headers); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      switch (key) {
        case 'User-Agent':
          options.UserAgent = value;
          break;

        case 'Content-Type':
          options.MediaType = value;
          break;

        case 'Cookie':
          headers.Cookie = value;
          break;

        case 'Accept':
          switch (value) {
            case 'application/json':
              options.ContentType = 'json';
              break;

            case 'text/csv':
              options.ContentType = 'table';
              break;

            case 'text/plain':
            case 'text/html':
            case 'application/javascript':
            case 'application/x-javascript':
            case 'application/x-www-form-urlencoded':
              options.ContentType = 'text';
              break;

            case 'text/xml':
            case 'application/xml':
              options.ContentType = 'xmldom';
              break;

            case 'application/octet-stream':
              options.ContentType = 'binary';
              break;

            default:
              if (value.startsWith('image/')) {
                options.ContentType = 'image';
              } else if (value.startsWith('audio/')) {
                options.ContentType = 'audio';
              } else {
                headers[key] = value;
              }

          }

          break;

        default:
          headers[key] = value;
      }
    }
  }

  if (request.cookies) {
    headers.Cookie = cookieString;
  }

  if (Object.entries(headers).length > 0) {
    // If key is on the same line as 'weboptions', there is only one parameter
    // otherwise keys are indented by one level in the next line.
    // An extra indentation level is given to the values's new lines in cell array
    var indentLevel = 1 + (Object.keys(options).length === 0 ? 0 : 1);
    options.HeaderFields = addCellArray(headers, ['Authorization', 'Cookie'], '', indentLevel);
  }

  return options;
};

var prepareOptions = function prepareOptions(request, options) {
  var lines = [];

  if (Object.keys(options).length === 0) {
    return lines;
  }

  var pairValues = addCellArray(options, ['HeaderFields'], ',', 1, true);
  lines.push(callFunction('options', 'weboptions', pairValues));
  return lines;
};

var prepareBasicURI = function prepareBasicURI(request) {
  var response = [];

  if (request.query) {
    response.push(setVariableValue('baseURI', repr(request.urlWithoutQuery)));
    response.push(setVariableValue('uri', "[baseURI '?' ".concat(paramsString, "]")));
  } else {
    response.push(setVariableValue('uri', repr(request.url)));
  }

  return response;
};

var prepareBasicData = function prepareBasicData(request) {
  var response = [];

  if (request.data) {
    if (typeof request.data === 'boolean') {
      response = setVariableValue('body', repr());
    } else if (request.data[0] === '@') {
      response.push(callFunction('body', 'fileread', repr(request.data.slice(1))));

      if (!request.isDataBinary) {
        response.push(setVariableValue('body(body==13 | body==10)', '[]'));
      }
    } else {
      // if the data is in JSON, store it as struct in MATLAB
      // otherwise just keep it as a char vector
      try {
        var jsonData = JSON.parse(request.data);

        if (_typeof(jsonData) === 'object') {
          var jsonText = structify(jsonData);
          if (!jsonText.startsWith('struct')) jsonText = repr(jsonText);
          response = setVariableValue('body', jsonText);
        } else {
          response = setVariableValue('body', repr(request.data));
        }
      } catch (e) {
        response = setVariableValue('body', repr(request.data));
      }
    }
  }

  return response;
};

var prepareWebCall = function prepareWebCall(request, options) {
  var lines = [];
  var webFunction = containsBody(request) ? 'webwrite' : 'webread';
  var params = ['uri'];

  if (containsBody(request)) {
    params.push('body');
  }

  if (Object.keys(options).length > 0) {
    params.push('options');
  }

  lines.push(callFunction('response', webFunction, params));

  if (request.query) {
    params[0] = 'fullURI';
    lines.push('', '% As there is a query, a full URI may be necessary instead.', setVariableValue('fullURI', repr(request.url)), callFunction('response', webFunction, params));
  }

  return lines;
};

var toWebServices = function toWebServices(request) {
  var lines = ['%% Web Access using Data Import and Export API'];

  if (!isSupportedByWebServices(request)) {
    lines.push('% This is not possible with the webread/webwrite API');
    return lines;
  }

  var options = parseWebOptions(request);
  lines = lines.concat([prepareQueryString(request), prepareCookies(request), prepareBasicURI(request), prepareBasicData(request), prepareOptions(request, options), prepareWebCall(request, options)]);
  return lines;
};

module.exports = toWebServices;
        },
        map: {"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/slicedToArray":120,"./common":223}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/matlab/httpinterface.js
      142: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('./common'),
    repr = _require.repr,
    setVariableValue = _require.setVariableValue,
    callFunction = _require.callFunction,
    structify = _require.structify,
    containsBody = _require.containsBody,
    prepareQueryString = _require.prepareQueryString,
    prepareCookies = _require.prepareCookies,
    cookieString = _require.cookieString;

var prepareHeaders = function prepareHeaders(request) {
  var response = null;

  if (request.headers) {
    var headerEntries = Object.entries(request.headers); // cookies are part of headers

    var headerCount = headerEntries.length + (request.cookies ? 1 : 0);
    var headers = [];
    var header = headerCount === 1 ? '' : '[';

    for (var _i = 0, _headerEntries = headerEntries; _i < _headerEntries.length; _i++) {
      var _headerEntries$_i = _slicedToArray(_headerEntries[_i], 2),
          key = _headerEntries$_i[0],
          value = _headerEntries$_i[1];

      switch (key) {
        case 'Cookie':
          break;

        case 'Accept':
          {
            var accepts = value.split(',');

            if (accepts.length === 1) {
              headers.push("field.AcceptField(MediaType(".concat(repr(value), "))"));
            } else {
              var acceptheader = 'field.AcceptField([';

              var _iterator = _createForOfIteratorHelper(accepts),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var accept = _step.value;
                  acceptheader += "\n        MediaType(".concat(repr(accept.trim()), ")");
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }

              acceptheader += '\n    ])';
              headers.push(acceptheader);
            }

            break;
          }

        default:
          headers.push("HeaderField(".concat(repr(key), ", ").concat(repr(value), ")"));
      }
    }

    if (headerCount === 1) {
      header += headers.pop();
    } else {
      header += '\n    ' + headers.join('\n    ');

      if (request.cookies) {
        var cookieFieldParams = callFunction(null, 'cellfun', ['@(x) Cookie(x{:})', callFunction(null, 'num2cell', ['cookies', '2'], '')], '');
        header += '\n    ' + callFunction(null, 'field.CookieField', cookieFieldParams, '');
      }

      header += '\n]\'';
    }

    response = setVariableValue('header', header);
  }

  return response;
};

var prepareURI = function prepareURI(request) {
  var uriParams = [repr(request.urlWithoutQuery)];

  if (request.query) {
    uriParams.push('QueryParameter(params\')');
  }

  return callFunction('uri', 'URI', uriParams);
};

var prepareAuth = function prepareAuth(request) {
  var options = [];
  var optionsParams = [];

  if (request.auth) {
    var _request$auth$split = request.auth.split(':'),
        _request$auth$split2 = _slicedToArray(_request$auth$split, 2),
        usr = _request$auth$split2[0],
        pass = _request$auth$split2[1];

    var userfield = "'Username', ".concat(repr(usr));
    var passfield = "'Password', ".concat(repr(pass));
    var authparams = (usr ? "".concat(userfield, ", ") : '') + passfield;
    optionsParams.push(repr('Credentials'), 'cred');
    options.push(callFunction('cred', 'Credentials', authparams));
  }

  if (request.insecure) {
    optionsParams.push(repr('VerifyServerName'), 'false');
  }

  if (optionsParams.length > 0) {
    options.push(callFunction('options', 'HTTPOptions', optionsParams));
  }

  return options;
};

var prepareMultipartUploads = function prepareMultipartUploads(request) {
  var response = null;

  if (request.multipartUploads) {
    var params = [];

    for (var _i2 = 0, _Object$entries = Object.entries(request.multipartUploads); _i2 < _Object$entries.length; _i2++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      var pair = [];
      pair.push(repr(key));
      var fileProvider = prepareDataProvider(value, null, '', 1);
      pair.push(fileProvider);
      params.push(pair);
    }

    response = callFunction('body', 'MultipartFormProvider', params);
  }

  return response;
};

var isJsonString = function isJsonString(str) {
  // Source: https://stackoverflow.com/a/3710226/5625738
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }

  return true;
};

var prepareDataProvider = function prepareDataProvider(value, output, termination, indentLevel, isDataBinary, isDataRaw) {
  if (typeof indentLevel === 'undefined' || indentLevel === null) indentLevel = 0;
  if (typeof isDataBinary === 'undefined') isDataBinary = true;

  if (!isDataRaw && value[0] === '@') {
    var filename = value.slice(1); // >> imformats % for seeing MATLAB supported image formats

    var isImageProvider = new Set(['jpeg', 'jpg', 'png', 'tif', 'gif']).has(filename.split('.')[1]);
    var provider = isImageProvider ? 'ImageProvider' : 'FileProvider';

    if (!isDataBinary) {
      return [callFunction(output, 'fileread', repr(filename)), setVariableValue("".concat(output, "(").concat(output, "==13 | ").concat(output, "==10)"), '[]')];
    }

    return callFunction(output, provider, repr(filename), termination);
  }

  if (value === true) {
    return callFunction(output, 'FileProvider', '', termination);
  }

  if (typeof value !== 'number' && isJsonString(value)) {
    var obj = JSON.parse(value); // If fail to create a struct for the JSON, then return a string

    try {
      var structure = structify(obj, indentLevel);
      return callFunction(output, 'JSONProvider', structure, termination);
    } catch (e) {
      return callFunction(output, 'StringProvider', repr(value), termination);
    }
  }

  if (typeof value === 'number') {
    return callFunction(output, 'FormProvider', repr(value), termination);
  }

  var formValue = value.split('&').map(function (x) {
    return x.split('=').map(function (x) {
      return repr(x);
    });
  });
  return callFunction(output, 'FormProvider', formValue, termination);
};

var prepareData = function prepareData(request) {
  var response = null;

  if (request.dataArray) {
    var data = request.dataArray.map(function (x) {
      return x.split('=').map(function (x) {
        var ans = repr(x);

        try {
          var jsonData = JSON.parse(x);

          if (_typeof(jsonData) === 'object') {
            ans = callFunction(null, 'JSONProvider', structify(jsonData, 1), '');
          }
        } catch (e) {}

        return ans;
      });
    });
    response = callFunction('body', 'FormProvider', data);
  } else if (request.data) {
    response = prepareDataProvider(request.data, 'body', ';', 0, !!request.isDataBinary, !!request.isDataRaw);

    if (!response) {
      response = setVariableValue('body', repr(request.data));
    }
  }

  return response;
};

var prepareRequestMessage = function prepareRequestMessage(request) {
  var reqMessage = [repr(request.method)];

  if (request.cookie || request.headers) {
    reqMessage.push('header');
  } else if (request.method === 'get') {
    reqMessage = '';
  }

  if (containsBody(request)) {
    if (reqMessage.length === 1) {
      reqMessage.push('[]');
    }

    reqMessage.push('body');
  } // list as many params as necessary


  var params = ['uri.EncodedURI'];

  if (request.auth || request.insecure) {
    params.push('options');
  }

  var response = [callFunction('response', 'RequestMessage', reqMessage, callFunction(null, '.send', params))];
  return response.join('\n');
};

var toHTTPInterface = function toHTTPInterface(request) {
  return ['%% HTTP Interface', 'import matlab.net.*', 'import matlab.net.http.*', containsBody(request) ? 'import matlab.net.http.io.*' : null, '', prepareQueryString(request), prepareCookies(request), prepareHeaders(request), prepareURI(request), prepareAuth(request), prepareMultipartUploads(request), prepareData(request), prepareRequestMessage(request), ''];
};

module.exports = toHTTPInterface;
        },
        map: {"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/slicedToArray":120,"./common":223}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_Stack.js
      143: {
        factory: (module, exports, require) => {
          var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;
        },
        map: {"./_ListCache":224,"./_stackClear":225,"./_stackDelete":226,"./_stackGet":227,"./_stackHas":228,"./_stackSet":229}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_assignValue.js
      144: {
        factory: (module, exports, require) => {
          var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;
        },
        map: {"./_baseAssignValue":168,"./eq":230}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseAssign.js
      145: {
        factory: (module, exports, require) => {
          var copyObject = require('./_copyObject'),
    keys = require('./keys');
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;
        },
        map: {"./_copyObject":93,"./keys":160}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseAssignIn.js
      146: {
        factory: (module, exports, require) => {
          var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;
        },
        map: {"./_copyObject":93,"./keysIn":161}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_cloneBuffer.js
      147: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var root = require('./_root');
/** Detect free variable `exports`. */


var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_copyArray.js
      148: {
        factory: (module, exports, require) => {
          /**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_copySymbols.js
      149: {
        factory: (module, exports, require) => {
          var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;
        },
        map: {"./_copyObject":93,"./_getSymbols":232}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_copySymbolsIn.js
      150: {
        factory: (module, exports, require) => {
          var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;
        },
        map: {"./_copyObject":93,"./_getSymbolsIn":171}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getAllKeys.js
      151: {
        factory: (module, exports, require) => {
          var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;
        },
        map: {"./_baseGetAllKeys":170,"./_getSymbols":232,"./keys":160}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getTag.js
      152: {
        factory: (module, exports, require) => {
          var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;
        },
        map: {"./_DataView":233,"./_Map":234,"./_Promise":235,"./_Set":236,"./_WeakMap":237,"./_baseGetTag":238,"./_toSource":239}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_initCloneArray.js
      153: {
        factory: (module, exports, require) => {
          /** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_initCloneByTag.js
      154: {
        factory: (module, exports, require) => {
          var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;
        },
        map: {"./_cloneArrayBuffer":240,"./_cloneDataView":241,"./_cloneRegExp":242,"./_cloneSymbol":243,"./_cloneTypedArray":244}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_initCloneObject.js
      155: {
        factory: (module, exports, require) => {
          var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;
        },
        map: {"./_baseCreate":245,"./_getPrototype":246,"./_isPrototype":247}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isBuffer.js
      156: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var root = require('./_root'),
    stubFalse = require('./stubFalse');
/** Detect free variable `exports`. */


var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./_root":231,"./stubFalse":248}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isMap.js
      157: {
        factory: (module, exports, require) => {
          var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;
        },
        map: {"./_baseIsMap":249,"./_baseUnary":250,"./_nodeUtil":251}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isObject.js
      158: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isSet.js
      159: {
        factory: (module, exports, require) => {
          var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;
        },
        map: {"./_baseIsSet":252,"./_baseUnary":250,"./_nodeUtil":251}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/keys.js
      160: {
        factory: (module, exports, require) => {
          var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;
        },
        map: {"./_arrayLikeKeys":253,"./_baseKeys":254,"./isArrayLike":255}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/keysIn.js
      161: {
        factory: (module, exports, require) => {
          var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;
        },
        map: {"./_arrayLikeKeys":253,"./_baseKeysIn":256,"./isArrayLike":255}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/last.js
      162: {
        factory: (module, exports, require) => {
          /**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_parent.js
      163: {
        factory: (module, exports, require) => {
          var baseGet = require('./_baseGet'),
    baseSlice = require('./_baseSlice');
/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */


function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;
        },
        map: {"./_baseGet":177,"./_baseSlice":257}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_toKey.js
      164: {
        factory: (module, exports, require) => {
          var isSymbol = require('./isSymbol');
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;
        },
        map: {"./isSymbol":258}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_isKey.js
      165: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./isArray":99,"./isSymbol":258}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_stringToPath.js
      166: {
        factory: (module, exports, require) => {
          var memoizeCapped = require('./_memoizeCapped');
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;
        },
        map: {"./_memoizeCapped":259}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/toString.js
      167: {
        factory: (module, exports, require) => {
          var baseToString = require('./_baseToString');
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;
        },
        map: {"./_baseToString":260}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseAssignValue.js
      168: {
        factory: (module, exports, require) => {
          var defineProperty = require('./_defineProperty');
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;
        },
        map: {"./_defineProperty":261}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isPlainObject.js
      169: {
        factory: (module, exports, require) => {
          var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;
        },
        map: {"./_baseGetTag":238,"./_getPrototype":246,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseGetAllKeys.js
      170: {
        factory: (module, exports, require) => {
          var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;
        },
        map: {"./_arrayPush":263,"./isArray":99}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getSymbolsIn.js
      171: {
        factory: (module, exports, require) => {
          var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;
        },
        map: {"./_arrayPush":263,"./_getPrototype":246,"./_getSymbols":232,"./stubArray":264}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseForOwn.js
      172: {
        factory: (module, exports, require) => {
          var baseFor = require('./_baseFor'),
    keys = require('./keys');
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;
        },
        map: {"./_baseFor":265,"./keys":160}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_createBaseEach.js
      173: {
        factory: (module, exports, require) => {
          var isArrayLike = require('./isArrayLike');
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;
        },
        map: {"./isArrayLike":255}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/identity.js
      174: {
        factory: (module, exports, require) => {
          /**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/side-channel/index.js
      175: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var GetIntrinsic = require('get-intrinsic');

var callBound = require('call-bind/callBound');

var inspect = require('object-inspect');

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);
var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);
/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */

var listGetNode = function listGetNode(list, key) {
  // eslint-disable-line consistent-return
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr; // eslint-disable-line no-param-reassign

      return curr;
    }
  }
};

var listGet = function listGet(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};

var listSet = function listSet(objects, key, value) {
  var node = listGetNode(objects, key);

  if (node) {
    node.value = value;
  } else {
    // Prepend the new node to the beginning of the list
    objects.next = {
      // eslint-disable-line no-param-reassign
      key: key,
      next: objects.next,
      value: value
    };
  }
};

var listHas = function listHas(objects, key) {
  return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function assert(key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    get: function get(key) {
      // eslint-disable-line consistent-return
      if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listGet($o, key);
        }
      }
    },
    has: function has(key) {
      if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listHas($o, key);
        }
      }

      return false;
    },
    set: function set(key, value) {
      if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
        if (!$wm) {
          $wm = new $WeakMap();
        }

        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }

        $mapSet($m, key, value);
      } else {
        if (!$o) {
          /*
           * Initialize the linked list as an empty node, so that we don't have
           * to special-case handling of the first node: we can always refer to
           * it as (previous node).next, instead of something like (list).head
           */
          $o = {
            key: {},
            next: null
          };
        }

        listSet($o, key, value);
      }
    }
  };
  return channel;
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"get-intrinsic":266,"call-bind/callBound":267,"object-inspect":268}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/qs/lib/utils.js
      176: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var formats = require('./formats');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = function () {
  var array = [];

  for (var i = 0; i < 256; ++i) {
    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
  }

  return array;
}();

var compactQueue = function compactQueue(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];

    if (isArray(obj)) {
      var compacted = [];

      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== 'undefined') {
          compacted.push(obj[j]);
        }
      }

      item.obj[item.prop] = compacted;
    }
  }
};

var arrayToObject = function arrayToObject(source, options) {
  var obj = options && options.plainObjects ? Object.create(null) : {};

  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== 'undefined') {
      obj[i] = source[i];
    }
  }

  return obj;
};

var merge = function merge(target, source, options) {
  /* eslint no-param-reassign: 0 */
  if (!source) {
    return target;
  }

  if (_typeof(source) !== 'object') {
    if (isArray(target)) {
      target.push(source);
    } else if (target && _typeof(target) === 'object') {
      if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }

    return target;
  }

  if (!target || _typeof(target) !== 'object') {
    return [target].concat(source);
  }

  var mergeTarget = target;

  if (isArray(target) && !isArray(source)) {
    mergeTarget = arrayToObject(target, options);
  }

  if (isArray(target) && isArray(source)) {
    source.forEach(function (item, i) {
      if (has.call(target, i)) {
        var targetItem = target[i];

        if (targetItem && _typeof(targetItem) === 'object' && item && _typeof(item) === 'object') {
          target[i] = merge(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }

  return Object.keys(source).reduce(function (acc, key) {
    var value = source[key];

    if (has.call(acc, key)) {
      acc[key] = merge(acc[key], value, options);
    } else {
      acc[key] = value;
    }

    return acc;
  }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function (acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};

var decode = function decode(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, ' ');

  if (charset === 'iso-8859-1') {
    // unescape never throws, no try...catch needed:
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  } // utf-8


  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
  // It has been adapted here for stricter adherence to RFC 3986
  if (str.length === 0) {
    return str;
  }

  var string = str;

  if (_typeof(str) === 'symbol') {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== 'string') {
    string = String(str);
  }

  if (charset === 'iso-8859-1') {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
      return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
    });
  }

  var out = '';

  for (var i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);

    if (c === 0x2D // -
    || c === 0x2E // .
    || c === 0x5F // _
    || c === 0x7E // ~
    || c >= 0x30 && c <= 0x39 // 0-9
    || c >= 0x41 && c <= 0x5A // a-z
    || c >= 0x61 && c <= 0x7A // A-Z
    || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
    ) {
      out += string.charAt(i);
      continue;
    }

    if (c < 0x80) {
      out = out + hexTable[c];
      continue;
    }

    if (c < 0x800) {
      out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
      continue;
    }

    if (c < 0xD800 || c >= 0xE000) {
      out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
      continue;
    }

    i += 1;
    c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
    /* eslint operator-linebreak: [2, "before"] */

    out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
  }

  return out;
};

var compact = function compact(value) {
  var queue = [{
    obj: {
      o: value
    },
    prop: 'o'
  }];
  var refs = [];

  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];

      if (_typeof(val) === 'object' && val !== null && refs.indexOf(val) === -1) {
        queue.push({
          obj: obj,
          prop: key
        });
        refs.push(val);
      }
    }
  }

  compactQueue(queue);
  return value;
};

var isRegExp = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
  if (!obj || _typeof(obj) !== 'object') {
    return false;
  }

  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
  return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
  if (isArray(val)) {
    var mapped = [];

    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }

    return mapped;
  }

  return fn(val);
};

module.exports = {
  arrayToObject: arrayToObject,
  assign: assign,
  combine: combine,
  compact: compact,
  decode: decode,
  encode: encode,
  isBuffer: isBuffer,
  isRegExp: isRegExp,
  maybeMap: maybeMap,
  merge: merge
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"./formats":102}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseGet.js
      177: {
        factory: (module, exports, require) => {
          var castPath = require('./_castPath'),
    toKey = require('./_toKey');
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;
        },
        map: {"./_castPath":92,"./_toKey":164}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseSet.js
      178: {
        factory: (module, exports, require) => {
          var assignValue = require('./_assignValue'),
    castPath = require('./_castPath'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject'),
    toKey = require('./_toKey');
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;
        },
        map: {"./_assignValue":144,"./_castPath":92,"./_isIndex":269,"./isObject":158,"./_toKey":164}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseHasIn.js
      179: {
        factory: (module, exports, require) => {
          /**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_hasPath.js
      180: {
        factory: (module, exports, require) => {
          var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;
        },
        map: {"./_castPath":92,"./isArguments":270,"./isArray":99,"./_isIndex":269,"./isLength":271,"./_toKey":164}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseFlatten.js
      181: {
        factory: (module, exports, require) => {
          var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;
        },
        map: {"./_arrayPush":263,"./_isFlattenable":272}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_apply.js
      182: {
        factory: (module, exports, require) => {
          /**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseSetToString.js
      183: {
        factory: (module, exports, require) => {
          var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;
        },
        map: {"./constant":273,"./_defineProperty":261,"./identity":174}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_shortOut.js
      184: {
        factory: (module, exports, require) => {
          /** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIteratee.js
      185: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./_baseMatches":274,"./_baseMatchesProperty":275,"./identity":174,"./isArray":99,"./property":276}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/arrayLikeToArray.js
      186: {
        factory: (module, exports, require) => {
          function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/superPropBase.js
      187: {
        factory: (module, exports, require) => {
          var getPrototypeOf = require("./getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./getPrototypeOf.js":18}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/arrayWithHoles.js
      188: {
        factory: (module, exports, require) => {
          function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
      189: {
        factory: (module, exports, require) => {
          function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/nonIterableRest.js
      190: {
        factory: (module, exports, require) => {
          function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/cross-spawn/lib/parse.js
      191: {
        factory: (module, exports, require) => {
          'use strict';

var path = require('path');

var niceTry = require('nice-try');

var resolveCommand = require('./util/resolveCommand');

var escape = require('./util/escape');

var readShebang = require('./util/readShebang');

var semver = require('semver');

var isWin = process.platform === 'win32';
var isExecutableRegExp = /\.(?:com|exe)$/i;
var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i; // `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0

var supportsShellOption = niceTry(function () {
  return semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true);
}) || false;

function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  var shebang = parsed.file && readShebang(parsed.file);

  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }

  return parsed.file;
}

function parseNonShell(parsed) {
  if (!isWin) {
    return parsed;
  } // Detect & add support for shebangs


  var commandFile = detectShebang(parsed); // We don't need a shell if the command filename is an executable

  var needsShell = !isExecutableRegExp.test(commandFile); // If a shell is required, use cmd.exe and take care of escaping everything correctly
  // Note that `forceShell` is an hidden option used only in tests

  if (parsed.options.forceShell || needsShell) {
    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
    // we need to double escape them
    var needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile); // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
    // This is necessary otherwise it will always fail with ENOENT in those cases

    parsed.command = path.normalize(parsed.command); // Escape command & arguments

    parsed.command = escape.command(parsed.command);
    parsed.args = parsed.args.map(function (arg) {
      return escape.argument(arg, needsDoubleEscapeMetaChars);
    });
    var shellCommand = [parsed.command].concat(parsed.args).join(' ');
    parsed.args = ['/d', '/s', '/c', "\"".concat(shellCommand, "\"")];
    parsed.command = process.env.comspec || 'cmd.exe';
    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
  }

  return parsed;
}

function parseShell(parsed) {
  // If node supports the shell option, there's no need to mimic its behavior
  if (supportsShellOption) {
    return parsed;
  } // Mimic node shell option
  // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335


  var shellCommand = [parsed.command].concat(parsed.args).join(' ');

  if (isWin) {
    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';
    parsed.args = ['/d', '/s', '/c', "\"".concat(shellCommand, "\"")];
    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
  } else {
    if (typeof parsed.options.shell === 'string') {
      parsed.command = parsed.options.shell;
    } else if (process.platform === 'android') {
      parsed.command = '/system/bin/sh';
    } else {
      parsed.command = '/bin/sh';
    }

    parsed.args = ['-c', shellCommand];
  }

  return parsed;
}

function parse(command, args, options) {
  // Normalize arguments, similar to nodejs
  if (args && !Array.isArray(args)) {
    options = args;
    args = null;
  }

  args = args ? args.slice(0) : []; // Clone array to avoid changing the original

  options = Object.assign({}, options); // Clone object to avoid changing the original
  // Build our parsed object

  var parsed = {
    command: command,
    args: args,
    options: options,
    file: undefined,
    original: {
      command: command,
      args: args
    }
  }; // Delegate further parsing to shell or non-shell

  return options.shell ? parseShell(parsed) : parseNonShell(parsed);
}

module.exports = parse;
        },
        map: {"path":-19260817,"nice-try":277,"./util/resolveCommand":278,"./util/escape":279,"./util/readShebang":280,"semver":281}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/cross-spawn/lib/enoent.js
      192: {
        factory: (module, exports, require) => {
          'use strict';

var isWin = process.platform === 'win32';

function notFoundError(original, syscall) {
  return Object.assign(new Error("".concat(syscall, " ").concat(original.command, " ENOENT")), {
    code: 'ENOENT',
    errno: 'ENOENT',
    syscall: "".concat(syscall, " ").concat(original.command),
    path: original.command,
    spawnargs: original.args
  });
}

function hookChildProcess(cp, parsed) {
  if (!isWin) {
    return;
  }

  var originalEmit = cp.emit;

  cp.emit = function (name, arg1) {
    // If emitting "exit" event and exit code is 1, we need to check if
    // the command exists and emit an "error" instead
    // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
    if (name === 'exit') {
      var err = verifyENOENT(arg1, parsed, 'spawn');

      if (err) {
        return originalEmit.call(cp, 'error', err);
      }
    }

    return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
  };
}

function verifyENOENT(status, parsed) {
  if (isWin && status === 1 && !parsed.file) {
    return notFoundError(parsed.original, 'spawn');
  }

  return null;
}

function verifyENOENTSync(status, parsed) {
  if (isWin && status === 1 && !parsed.file) {
    return notFoundError(parsed.original, 'spawnSync');
  }

  return null;
}

module.exports = {
  hookChildProcess: hookChildProcess,
  verifyENOENT: verifyENOENT,
  verifyENOENTSync: verifyENOENTSync,
  notFoundError: notFoundError
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/npm-run-path/node_modules/path-key/index.js
      193: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (opts) {
  opts = opts || {};
  var env = opts.env || process.env;
  var platform = opts.platform || process.platform;

  if (platform !== 'win32') {
    return 'PATH';
  }

  return Object.keys(env).find(function (x) {
    return x.toUpperCase() === 'PATH';
  }) || 'Path';
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/wrapNativeSuper.js
      194: {
        factory: (module, exports, require) => {
          var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./getPrototypeOf.js":18,"./setPrototypeOf.js":36,"./isNativeFunction.js":282,"./construct.js":11}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/pump/index.js
      195: {
        factory: (module, exports, require) => {
          var once = require('once');

var eos = require('end-of-stream');

var fs = require('fs'); // we only need fs to get the ReadStream and WriteStream prototypes


var noop = function noop() {};

var ancient = /^v?\.0/.test(process.version);

var isFn = function isFn(fn) {
  return typeof fn === 'function';
};

var isFS = function isFS(stream) {
  if (!ancient) return false; // newer node version do not need to care about fs is a special way

  if (!fs) return false; // browser

  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
};

var isRequest = function isRequest(stream) {
  return stream.setHeader && isFn(stream.abort);
};

var destroyer = function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isFS(stream)) return stream.close(noop); // use close for fs streams to avoid fd leaks

    if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy();
    callback(err || new Error('stream was destroyed'));
  };
};

var call = function call(fn) {
  fn();
};

var pipe = function pipe(from, to) {
  return from.pipe(to);
};

var pump = function pump() {
  var streams = Array.prototype.slice.call(arguments);
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) throw new Error('pump requires two streams per minimum');
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
};

module.exports = pump;
        },
        map: {"once":283,"end-of-stream":284,"fs":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/get-stream/buffer-stream.js
      196: {
        factory: (module, exports, require) => {
          'use strict';

var _require = require('stream'),
    PassThrough = _require.PassThrough;

module.exports = function (options) {
  options = Object.assign({}, options);
  var _options = options,
      array = _options.array;
  var _options2 = options,
      encoding = _options2.encoding;
  var buffer = encoding === 'buffer';
  var objectMode = false;

  if (array) {
    objectMode = !(encoding || buffer);
  } else {
    encoding = encoding || 'utf8';
  }

  if (buffer) {
    encoding = null;
  }

  var len = 0;
  var ret = [];
  var stream = new PassThrough({
    objectMode: objectMode
  });

  if (encoding) {
    stream.setEncoding(encoding);
  }

  stream.on('data', function (chunk) {
    ret.push(chunk);

    if (objectMode) {
      len = ret.length;
    } else {
      len += chunk.length;
    }
  });

  stream.getBufferedValue = function () {
    if (array) {
      return ret;
    }

    return buffer ? Buffer.concat(ret, len) : ret.join('');
  };

  stream.getBufferedLength = function () {
    return len;
  };

  return stream;
};
        },
        map: {"stream":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/signal-exit/signals.js
      197: {
        factory: (module, exports, require) => {
          // This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
module.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];

if (process.platform !== 'win32') {
  module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT' // should detect profiler and enable/disable accordingly.
  // see #21
  // 'SIGPROF'
  );
}

if (process.platform === 'linux') {
  module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');
}
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/cookie/index.js
      198: {
        factory: (module, exports, require) => {
          /*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
'use strict';
/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;
/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;
/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var opt = options || {};
  var pairs = str.split(';');
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var index = pair.indexOf('='); // skip things that don't look like key=value

    if (index < 0) {
      continue;
    }

    var key = pair.substring(0, index).trim(); // only assign once

    if (undefined == obj[key]) {
      var val = pair.substring(index + 1, pair.length).trim(); // quoted values

      if (val[0] === '"') {
        val = val.slice(1, -1);
      }

      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */


function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;

    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid');
    }

    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;

      case 'lax':
        str += '; SameSite=Lax';
        break;

      case 'strict':
        str += '; SameSite=Strict';
        break;

      case 'none':
        str += '; SameSite=None';
        break;

      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}
/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */


function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@curlconverter/yargs/index.cjs
      199: {
        factory: (module, exports, require) => {
          'use strict'; // classic singleton yargs API, to use yargs
// without running as a singleton do:
// require('yargs/yargs')(process.argv.slice(2))

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _require = require('./build/index.cjs'),
    Yargs = _require.Yargs,
    processArgv = _require.processArgv;

Argv(processArgv.hideBin(process.argv));
module.exports = Argv;

function Argv(processArgs, cwd) {
  var argv = Yargs(processArgs, cwd, require);
  singletonify(argv); // TODO(bcoe): warn if argv.parse() or argv.argv is used directly.

  return argv;
}

function defineGetter(obj, key, getter) {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}

function lookupGetter(obj, key) {
  var desc = Object.getOwnPropertyDescriptor(obj, key);

  if (typeof desc !== 'undefined') {
    return desc.get;
  }
}
/*  Hack an instance of Argv with process.argv into Argv
    so people can do
    require('yargs')(['--beeble=1','-z','zizzle']).argv
    to parse a list of args and
    require('yargs').argv
    to get a parsed version of process.argv.
*/


function singletonify(inst) {
  [].concat(_toConsumableArray(Object.keys(inst)), _toConsumableArray(Object.getOwnPropertyNames(inst.constructor.prototype))).forEach(function (key) {
    if (key === 'argv') {
      defineGetter(Argv, key, lookupGetter(inst, key));
    } else if (typeof inst[key] === 'function') {
      Argv[key] = inst[key].bind(inst);
    } else {
      defineGetter(Argv, '$0', function () {
        return inst.$0;
      });
      defineGetter(Argv, 'parsed', function () {
        return inst.parsed;
      });
    }
  });
}
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"./build/index.cjs":285}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/lib.js
      200: {
        factory: (module, exports, require) => {
          'use strict';

var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var escapeMap = {
  '&': '&amp;',
  '"': '&quot;',
  '\'': '&#39;',
  '<': '&lt;',
  '>': '&gt;'
};
var escapeRegex = /[&"'<>]/g;

var _exports = module.exports = {};

function hasOwnProp(obj, k) {
  return ObjProto.hasOwnProperty.call(obj, k);
}

_exports.hasOwnProp = hasOwnProp;

function lookupEscape(ch) {
  return escapeMap[ch];
}

function _prettifyError(path, withInternals, err) {
  if (!err.Update) {
    // not one of ours, cast it
    err = new _exports.TemplateError(err);
  }

  err.Update(path); // Unless they marked the dev flag, show them a trace from here

  if (!withInternals) {
    var old = err;
    err = new Error(old.message);
    err.name = old.name;
  }

  return err;
}

_exports._prettifyError = _prettifyError;

function TemplateError(message, lineno, colno) {
  var err;
  var cause;

  if (message instanceof Error) {
    cause = message;
    message = cause.name + ": " + cause.message;
  }

  if (Object.setPrototypeOf) {
    err = new Error(message);
    Object.setPrototypeOf(err, TemplateError.prototype);
  } else {
    err = this;
    Object.defineProperty(err, 'message', {
      enumerable: false,
      writable: true,
      value: message
    });
  }

  Object.defineProperty(err, 'name', {
    value: 'Template render error'
  });

  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, this.constructor);
  }

  var getStack;

  if (cause) {
    var stackDescriptor = Object.getOwnPropertyDescriptor(cause, 'stack');

    getStack = stackDescriptor && (stackDescriptor.get || function () {
      return stackDescriptor.value;
    });

    if (!getStack) {
      getStack = function getStack() {
        return cause.stack;
      };
    }
  } else {
    var stack = new Error(message).stack;

    getStack = function getStack() {
      return stack;
    };
  }

  Object.defineProperty(err, 'stack', {
    get: function get() {
      return getStack.call(err);
    }
  });
  Object.defineProperty(err, 'cause', {
    value: cause
  });
  err.lineno = lineno;
  err.colno = colno;
  err.firstUpdate = true;

  err.Update = function Update(path) {
    var msg = '(' + (path || 'unknown path') + ')'; // only show lineno + colno next to path of template
    // where error occurred

    if (this.firstUpdate) {
      if (this.lineno && this.colno) {
        msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
      } else if (this.lineno) {
        msg += " [Line " + this.lineno + "]";
      }
    }

    msg += '\n ';

    if (this.firstUpdate) {
      msg += ' ';
    }

    this.message = msg + (this.message || '');
    this.firstUpdate = false;
    return this;
  };

  return err;
}

if (Object.setPrototypeOf) {
  Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
} else {
  TemplateError.prototype = Object.create(Error.prototype, {
    constructor: {
      value: TemplateError
    }
  });
}

_exports.TemplateError = TemplateError;

function escape(val) {
  return val.replace(escapeRegex, lookupEscape);
}

_exports.escape = escape;

function isFunction(obj) {
  return ObjProto.toString.call(obj) === '[object Function]';
}

_exports.isFunction = isFunction;

function isArray(obj) {
  return ObjProto.toString.call(obj) === '[object Array]';
}

_exports.isArray = isArray;

function isString(obj) {
  return ObjProto.toString.call(obj) === '[object String]';
}

_exports.isString = isString;

function isObject(obj) {
  return ObjProto.toString.call(obj) === '[object Object]';
}

_exports.isObject = isObject;
/**
 * @param {string|number} attr
 * @returns {(string|number)[]}
 * @private
 */

function _prepareAttributeParts(attr) {
  if (!attr) {
    return [];
  }

  if (typeof attr === 'string') {
    return attr.split('.');
  }

  return [attr];
}
/**
 * @param {string}   attribute      Attribute value. Dots allowed.
 * @returns {function(Object): *}
 */


function getAttrGetter(attribute) {
  var parts = _prepareAttributeParts(attribute);

  return function attrGetter(item) {
    var _item = item;

    for (var i = 0; i < parts.length; i++) {
      var part = parts[i]; // If item is not an object, and we still got parts to handle, it means
      // that something goes wrong. Just roll out to undefined in that case.

      if (hasOwnProp(_item, part)) {
        _item = _item[part];
      } else {
        return undefined;
      }
    }

    return _item;
  };
}

_exports.getAttrGetter = getAttrGetter;

function groupBy(obj, val, throwOnUndefined) {
  var result = {};
  var iterator = isFunction(val) ? val : getAttrGetter(val);

  for (var i = 0; i < obj.length; i++) {
    var value = obj[i];
    var key = iterator(value, i);

    if (key === undefined && throwOnUndefined === true) {
      throw new TypeError("groupby: attribute \"" + val + "\" resolved to undefined");
    }

    (result[key] || (result[key] = [])).push(value);
  }

  return result;
}

_exports.groupBy = groupBy;

function toArray(obj) {
  return Array.prototype.slice.call(obj);
}

_exports.toArray = toArray;

function without(array) {
  var result = [];

  if (!array) {
    return result;
  }

  var length = array.length;
  var contains = toArray(arguments).slice(1);
  var index = -1;

  while (++index < length) {
    if (indexOf(contains, array[index]) === -1) {
      result.push(array[index]);
    }
  }

  return result;
}

_exports.without = without;

function repeat(char_, n) {
  var str = '';

  for (var i = 0; i < n; i++) {
    str += char_;
  }

  return str;
}

_exports.repeat = repeat;

function each(obj, func, context) {
  if (obj == null) {
    return;
  }

  if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
    obj.forEach(func, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, l = obj.length; i < l; i++) {
      func.call(context, obj[i], i, obj);
    }
  }
}

_exports.each = each;

function map(obj, func) {
  var results = [];

  if (obj == null) {
    return results;
  }

  if (ArrayProto.map && obj.map === ArrayProto.map) {
    return obj.map(func);
  }

  for (var i = 0; i < obj.length; i++) {
    results[results.length] = func(obj[i], i);
  }

  if (obj.length === +obj.length) {
    results.length = obj.length;
  }

  return results;
}

_exports.map = map;

function asyncIter(arr, iter, cb) {
  var i = -1;

  function next() {
    i++;

    if (i < arr.length) {
      iter(arr[i], i, next, cb);
    } else {
      cb();
    }
  }

  next();
}

_exports.asyncIter = asyncIter;

function asyncFor(obj, iter, cb) {
  var keys = keys_(obj || {});
  var len = keys.length;
  var i = -1;

  function next() {
    i++;
    var k = keys[i];

    if (i < len) {
      iter(k, obj[k], i, len, next);
    } else {
      cb();
    }
  }

  next();
}

_exports.asyncFor = asyncFor;

function indexOf(arr, searchElement, fromIndex) {
  return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
}

_exports.indexOf = indexOf;

function keys_(obj) {
  /* eslint-disable no-restricted-syntax */
  var arr = [];

  for (var k in obj) {
    if (hasOwnProp(obj, k)) {
      arr.push(k);
    }
  }

  return arr;
}

_exports.keys = keys_;

function _entries(obj) {
  return keys_(obj).map(function (k) {
    return [k, obj[k]];
  });
}

_exports._entries = _entries;

function _values(obj) {
  return keys_(obj).map(function (k) {
    return obj[k];
  });
}

_exports._values = _values;

function extend(obj1, obj2) {
  obj1 = obj1 || {};
  keys_(obj2).forEach(function (k) {
    obj1[k] = obj2[k];
  });
  return obj1;
}

_exports._assign = _exports.extend = extend;

function inOperator(key, val) {
  if (isArray(val) || isString(val)) {
    return val.indexOf(key) !== -1;
  } else if (isObject(val)) {
    return key in val;
  }

  throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
}

_exports.inOperator = inOperator;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/environment.js
      201: {
        factory: (module, exports, require) => {
          'use strict';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var asap = require('asap');

var _waterfall = require('a-sync-waterfall');

var lib = require('./lib');

var compiler = require('./compiler');

var filters = require('./filters');

var _require = require('./loaders'),
    FileSystemLoader = _require.FileSystemLoader,
    WebLoader = _require.WebLoader,
    PrecompiledLoader = _require.PrecompiledLoader;

var tests = require('./tests');

var globals = require('./globals');

var _require2 = require('./object'),
    Obj = _require2.Obj,
    EmitterObj = _require2.EmitterObj;

var globalRuntime = require('./runtime');

var handleError = globalRuntime.handleError,
    Frame = globalRuntime.Frame;

var expressApp = require('./express-app'); // If the user is using the async API, *always* call it
// asynchronously even if the template was synchronous.


function callbackAsap(cb, err, res) {
  asap(function () {
    cb(err, res);
  });
}
/**
 * A no-op template, for use with {% include ignore missing %}
 */


var noopTmplSrc = {
  type: 'code',
  obj: {
    root: function root(env, context, frame, runtime, cb) {
      try {
        cb(null, '');
      } catch (e) {
        cb(handleError(e, null, null));
      }
    }
  }
};

var Environment = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Environment, _EmitterObj);

  function Environment() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Environment.prototype;

  _proto.init = function init(loaders, opts) {
    var _this = this; // The dev flag determines the trace that'll be shown on errors.
    // If set to true, returns the full trace from the error point,
    // otherwise will return trace starting from Template.render
    // (the full trace from within nunjucks may confuse developers using
    //  the library)
    // defaults to false


    opts = this.opts = opts || {};
    this.opts.dev = !!opts.dev; // The autoescape flag sets global autoescaping. If true,
    // every string variable will be escaped by default.
    // If false, strings can be manually escaped using the `escape` filter.
    // defaults to true

    this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true; // If true, this will make the system throw errors if trying
    // to output a null or undefined value

    this.opts.throwOnUndefined = !!opts.throwOnUndefined;
    this.opts.trimBlocks = !!opts.trimBlocks;
    this.opts.lstripBlocks = !!opts.lstripBlocks;
    this.loaders = [];

    if (!loaders) {
      // The filesystem loader is only available server-side
      if (FileSystemLoader) {
        this.loaders = [new FileSystemLoader('views')];
      } else if (WebLoader) {
        this.loaders = [new WebLoader('/views')];
      }
    } else {
      this.loaders = lib.isArray(loaders) ? loaders : [loaders];
    } // It's easy to use precompiled templates: just include them
    // before you configure nunjucks and this will automatically
    // pick it up and use it


    if (typeof window !== 'undefined' && window.nunjucksPrecompiled) {
      this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
    }

    this._initLoaders();

    this.globals = globals();
    this.filters = {};
    this.tests = {};
    this.asyncFilters = [];
    this.extensions = {};
    this.extensionsList = [];

    lib._entries(filters).forEach(function (_ref) {
      var name = _ref[0],
          filter = _ref[1];
      return _this.addFilter(name, filter);
    });

    lib._entries(tests).forEach(function (_ref2) {
      var name = _ref2[0],
          test = _ref2[1];
      return _this.addTest(name, test);
    });
  };

  _proto._initLoaders = function _initLoaders() {
    var _this2 = this;

    this.loaders.forEach(function (loader) {
      // Caching and cache busting
      loader.cache = {};

      if (typeof loader.on === 'function') {
        loader.on('update', function (name, fullname) {
          loader.cache[name] = null;

          _this2.emit('update', name, fullname, loader);
        });
        loader.on('load', function (name, source) {
          _this2.emit('load', name, source, loader);
        });
      }
    });
  };

  _proto.invalidateCache = function invalidateCache() {
    this.loaders.forEach(function (loader) {
      loader.cache = {};
    });
  };

  _proto.addExtension = function addExtension(name, extension) {
    extension.__name = name;
    this.extensions[name] = extension;
    this.extensionsList.push(extension);
    return this;
  };

  _proto.removeExtension = function removeExtension(name) {
    var extension = this.getExtension(name);

    if (!extension) {
      return;
    }

    this.extensionsList = lib.without(this.extensionsList, extension);
    delete this.extensions[name];
  };

  _proto.getExtension = function getExtension(name) {
    return this.extensions[name];
  };

  _proto.hasExtension = function hasExtension(name) {
    return !!this.extensions[name];
  };

  _proto.addGlobal = function addGlobal(name, value) {
    this.globals[name] = value;
    return this;
  };

  _proto.getGlobal = function getGlobal(name) {
    if (typeof this.globals[name] === 'undefined') {
      throw new Error('global not found: ' + name);
    }

    return this.globals[name];
  };

  _proto.addFilter = function addFilter(name, func, async) {
    var wrapped = func;

    if (async) {
      this.asyncFilters.push(name);
    }

    this.filters[name] = wrapped;
    return this;
  };

  _proto.getFilter = function getFilter(name) {
    if (!this.filters[name]) {
      throw new Error('filter not found: ' + name);
    }

    return this.filters[name];
  };

  _proto.addTest = function addTest(name, func) {
    this.tests[name] = func;
    return this;
  };

  _proto.getTest = function getTest(name) {
    if (!this.tests[name]) {
      throw new Error('test not found: ' + name);
    }

    return this.tests[name];
  };

  _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
    var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
    return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
  };

  _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
    var _this3 = this;

    var that = this;
    var tmpl = null;

    if (name && name.raw) {
      // this fixes autoescape for templates referenced in symbols
      name = name.raw;
    }

    if (lib.isFunction(parentName)) {
      cb = parentName;
      parentName = null;
      eagerCompile = eagerCompile || false;
    }

    if (lib.isFunction(eagerCompile)) {
      cb = eagerCompile;
      eagerCompile = false;
    }

    if (name instanceof Template) {
      tmpl = name;
    } else if (typeof name !== 'string') {
      throw new Error('template names must be a string: ' + name);
    } else {
      for (var i = 0; i < this.loaders.length; i++) {
        var loader = this.loaders[i];
        tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];

        if (tmpl) {
          break;
        }
      }
    }

    if (tmpl) {
      if (eagerCompile) {
        tmpl.compile();
      }

      if (cb) {
        cb(null, tmpl);
        return undefined;
      } else {
        return tmpl;
      }
    }

    var syncResult;

    var createTemplate = function createTemplate(err, info) {
      if (!info && !err && !ignoreMissing) {
        err = new Error('template not found: ' + name);
      }

      if (err) {
        if (cb) {
          cb(err);
          return;
        } else {
          throw err;
        }
      }

      var newTmpl;

      if (!info) {
        newTmpl = new Template(noopTmplSrc, _this3, '', eagerCompile);
      } else {
        newTmpl = new Template(info.src, _this3, info.path, eagerCompile);

        if (!info.noCache) {
          info.loader.cache[name] = newTmpl;
        }
      }

      if (cb) {
        cb(null, newTmpl);
      } else {
        syncResult = newTmpl;
      }
    };

    lib.asyncIter(this.loaders, function (loader, i, next, done) {
      function handle(err, src) {
        if (err) {
          done(err);
        } else if (src) {
          src.loader = loader;
          done(null, src);
        } else {
          next();
        }
      } // Resolve name relative to parentName


      name = that.resolveTemplate(loader, parentName, name);

      if (loader.async) {
        loader.getSource(name, handle);
      } else {
        handle(null, loader.getSource(name));
      }
    }, createTemplate);
    return syncResult;
  };

  _proto.express = function express(app) {
    return expressApp(this, app);
  };

  _proto.render = function render(name, ctx, cb) {
    if (lib.isFunction(ctx)) {
      cb = ctx;
      ctx = null;
    } // We support a synchronous API to make it easier to migrate
    // existing code to async. This works because if you don't do
    // anything async work, the whole thing is actually run
    // synchronously.


    var syncResult = null;
    this.getTemplate(name, function (err, tmpl) {
      if (err && cb) {
        callbackAsap(cb, err);
      } else if (err) {
        throw err;
      } else {
        syncResult = tmpl.render(ctx, cb);
      }
    });
    return syncResult;
  };

  _proto.renderString = function renderString(src, ctx, opts, cb) {
    if (lib.isFunction(opts)) {
      cb = opts;
      opts = {};
    }

    opts = opts || {};
    var tmpl = new Template(src, this, opts.path);
    return tmpl.render(ctx, cb);
  };

  _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
    return _waterfall(tasks, callback, forceAsync);
  };

  return Environment;
}(EmitterObj);

var Context = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Context, _Obj);

  function Context() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto2 = Context.prototype;

  _proto2.init = function init(ctx, blocks, env) {
    var _this4 = this; // Has to be tied to an environment so we can tap into its globals.


    this.env = env || new Environment(); // Make a duplicate of ctx

    this.ctx = lib.extend({}, ctx);
    this.blocks = {};
    this.exported = [];
    lib.keys(blocks).forEach(function (name) {
      _this4.addBlock(name, blocks[name]);
    });
  };

  _proto2.lookup = function lookup(name) {
    // This is one of the most called functions, so optimize for
    // the typical case where the name isn't in the globals
    if (name in this.env.globals && !(name in this.ctx)) {
      return this.env.globals[name];
    } else {
      return this.ctx[name];
    }
  };

  _proto2.setVariable = function setVariable(name, val) {
    this.ctx[name] = val;
  };

  _proto2.getVariables = function getVariables() {
    return this.ctx;
  };

  _proto2.addBlock = function addBlock(name, block) {
    this.blocks[name] = this.blocks[name] || [];
    this.blocks[name].push(block);
    return this;
  };

  _proto2.getBlock = function getBlock(name) {
    if (!this.blocks[name]) {
      throw new Error('unknown block "' + name + '"');
    }

    return this.blocks[name][0];
  };

  _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
    var idx = lib.indexOf(this.blocks[name] || [], block);
    var blk = this.blocks[name][idx + 1];
    var context = this;

    if (idx === -1 || !blk) {
      throw new Error('no super block available for "' + name + '"');
    }

    blk(env, context, frame, runtime, cb);
  };

  _proto2.addExport = function addExport(name) {
    this.exported.push(name);
  };

  _proto2.getExported = function getExported() {
    var _this5 = this;

    var exported = {};
    this.exported.forEach(function (name) {
      exported[name] = _this5.ctx[name];
    });
    return exported;
  };

  return Context;
}(Obj);

var Template = /*#__PURE__*/function (_Obj2) {
  _inheritsLoose(Template, _Obj2);

  function Template() {
    return _Obj2.apply(this, arguments) || this;
  }

  var _proto3 = Template.prototype;

  _proto3.init = function init(src, env, path, eagerCompile) {
    this.env = env || new Environment();

    if (lib.isObject(src)) {
      switch (src.type) {
        case 'code':
          this.tmplProps = src.obj;
          break;

        case 'string':
          this.tmplStr = src.obj;
          break;

        default:
          throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
      }
    } else if (lib.isString(src)) {
      this.tmplStr = src;
    } else {
      throw new Error('src must be a string or an object describing the source');
    }

    this.path = path;

    if (eagerCompile) {
      try {
        this._compile();
      } catch (err) {
        throw lib._prettifyError(this.path, this.env.opts.dev, err);
      }
    } else {
      this.compiled = false;
    }
  };

  _proto3.render = function render(ctx, parentFrame, cb) {
    var _this6 = this;

    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    } else if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // If there is a parent frame, we are being called from internal
    // code of another template, and the internal system
    // depends on the sync/async nature of the parent template
    // to be inherited, so force an async callback


    var forceAsync = !parentFrame; // Catch compile errors for async rendering

    try {
      this.compile();
    } catch (e) {
      var err = lib._prettifyError(this.path, this.env.opts.dev, e);

      if (cb) {
        return callbackAsap(cb, err);
      } else {
        throw err;
      }
    }

    var context = new Context(ctx || {}, this.blocks, this.env);
    var frame = parentFrame ? parentFrame.push(true) : new Frame();
    frame.topLevel = true;
    var syncResult = null;
    var didError = false;
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err, res) {
      // TODO: this is actually a bug in the compiled template (because waterfall
      // tasks are both not passing errors up the chain of callbacks AND are not
      // causing a return from the top-most render function). But fixing that
      // will require a more substantial change to the compiler.
      if (didError && cb && typeof res !== 'undefined') {
        // prevent multiple calls to cb
        return;
      }

      if (err) {
        err = lib._prettifyError(_this6.path, _this6.env.opts.dev, err);
        didError = true;
      }

      if (cb) {
        if (forceAsync) {
          callbackAsap(cb, err, res);
        } else {
          cb(err, res);
        }
      } else {
        if (err) {
          throw err;
        }

        syncResult = res;
      }
    });
    return syncResult;
  };

  _proto3.getExported = function getExported(ctx, parentFrame, cb) {
    // eslint-disable-line consistent-return
    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    }

    if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // Catch compile errors for async rendering


    try {
      this.compile();
    } catch (e) {
      if (cb) {
        return cb(e);
      } else {
        throw e;
      }
    }

    var frame = parentFrame ? parentFrame.push() : new Frame();
    frame.topLevel = true; // Run the rootRenderFunc to populate the context with exported vars

    var context = new Context(ctx || {}, this.blocks, this.env);
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err) {
      if (err) {
        cb(err, null);
      } else {
        cb(null, context.getExported());
      }
    });
  };

  _proto3.compile = function compile() {
    if (!this.compiled) {
      this._compile();
    }
  };

  _proto3._compile = function _compile() {
    var props;

    if (this.tmplProps) {
      props = this.tmplProps;
    } else {
      var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
      var func = new Function(source); // eslint-disable-line no-new-func

      props = func();
    }

    this.blocks = this._getBlocks(props);
    this.rootRenderFunc = props.root;
    this.compiled = true;
  };

  _proto3._getBlocks = function _getBlocks(props) {
    var blocks = {};
    lib.keys(props).forEach(function (k) {
      if (k.slice(0, 2) === 'b_') {
        blocks[k.slice(2)] = props[k];
      }
    });
    return blocks;
  };

  return Template;
}(Obj);

module.exports = {
  Environment: Environment,
  Template: Template
};
        },
        map: {"asap":286,"a-sync-waterfall":287,"./lib":200,"./compiler":205,"./filters":288,"./loaders":203,"./tests":289,"./globals":290,"./object":291,"./runtime":208,"./express-app":292}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/loader.js
      202: {
        factory: (module, exports, require) => {
          'use strict';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var path = require('path');

var _require = require('./object'),
    EmitterObj = _require.EmitterObj;

module.exports = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Loader, _EmitterObj);

  function Loader() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Loader.prototype;

  _proto.resolve = function resolve(from, to) {
    return path.resolve(path.dirname(from), to);
  };

  _proto.isRelative = function isRelative(filename) {
    return filename.indexOf('./') === 0 || filename.indexOf('../') === 0;
  };

  return Loader;
}(EmitterObj);
        },
        map: {"path":-19260817,"./object":291}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/loaders.js
      203: {
        factory: (module, exports, require) => {
          "use strict"; // This file will automatically be rewired to web-loader.js when
// building for the browser

module.exports = require('./node-loaders');
        },
        map: {"./node-loaders":293}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/precompile.js
      204: {
        factory: (module, exports, require) => {
          'use strict';

var fs = require('fs');

var path = require('path');

var _require = require('./lib'),
    _prettifyError = _require._prettifyError;

var compiler = require('./compiler');

var _require2 = require('./environment'),
    Environment = _require2.Environment;

var precompileGlobal = require('./precompile-global');

function match(filename, patterns) {
  if (!Array.isArray(patterns)) {
    return false;
  }

  return patterns.some(function (pattern) {
    return filename.match(pattern);
  });
}

function precompileString(str, opts) {
  opts = opts || {};
  opts.isString = true;
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (!opts.name) {
    throw new Error('the "name" option is required when compiling a string');
  }

  return wrapper([_precompile(str, opts.name, env)], opts);
}

function precompile(input, opts) {
  // The following options are available:
  //
  // * name: name of the template (auto-generated when compiling a directory)
  // * isString: input is a string, not a file path
  // * asFunction: generate a callable function
  // * force: keep compiling on error
  // * env: the Environment to use (gets extensions and async filters from it)
  // * include: which file/folders to include (folders are auto-included, files are auto-excluded)
  // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)
  // * wrapper: function(templates, opts) {...}
  //       Customize the output format to store the compiled template.
  //       By default, templates are stored in a global variable used by the runtime.
  //       A custom loader will be necessary to load your custom wrapper.
  opts = opts || {};
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (opts.isString) {
    return precompileString(input, opts);
  }

  var pathStats = fs.existsSync(input) && fs.statSync(input);
  var precompiled = [];
  var templates = [];

  function addTemplates(dir) {
    fs.readdirSync(dir).forEach(function (file) {
      var filepath = path.join(dir, file);
      var subpath = filepath.substr(path.join(input, '/').length);
      var stat = fs.statSync(filepath);

      if (stat && stat.isDirectory()) {
        subpath += '/';

        if (!match(subpath, opts.exclude)) {
          addTemplates(filepath);
        }
      } else if (match(subpath, opts.include)) {
        templates.push(filepath);
      }
    });
  }

  if (pathStats.isFile()) {
    precompiled.push(_precompile(fs.readFileSync(input, 'utf-8'), opts.name || input, env));
  } else if (pathStats.isDirectory()) {
    addTemplates(input);

    for (var i = 0; i < templates.length; i++) {
      var name = templates[i].replace(path.join(input, '/'), '');

      try {
        precompiled.push(_precompile(fs.readFileSync(templates[i], 'utf-8'), name, env));
      } catch (e) {
        if (opts.force) {
          // Don't stop generating the output if we're
          // forcing compilation.
          console.error(e); // eslint-disable-line no-console
        } else {
          throw e;
        }
      }
    }
  }

  return wrapper(precompiled, opts);
}

function _precompile(str, name, env) {
  env = env || new Environment([]);
  var asyncFilters = env.asyncFilters;
  var extensions = env.extensionsList;
  var template;
  name = name.replace(/\\/g, '/');

  try {
    template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
  } catch (err) {
    throw _prettifyError(name, false, err);
  }

  return {
    name: name,
    template: template
  };
}

module.exports = {
  precompile: precompile,
  precompileString: precompileString
};
        },
        map: {"fs":-19260817,"path":-19260817,"./lib":200,"./compiler":205,"./environment":201,"./precompile-global":294}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/compiler.js
      205: {
        factory: (module, exports, require) => {
          'use strict';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var parser = require('./parser');

var transformer = require('./transformer');

var nodes = require('./nodes');

var _require = require('./lib'),
    TemplateError = _require.TemplateError;

var _require2 = require('./runtime'),
    Frame = _require2.Frame;

var _require3 = require('./object'),
    Obj = _require3.Obj; // These are all the same for now, but shouldn't be passed straight
// through


var compareOps = {
  '==': '==',
  '===': '===',
  '!=': '!=',
  '!==': '!==',
  '<': '<',
  '>': '>',
  '<=': '<=',
  '>=': '>='
};

var Compiler = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Compiler, _Obj);

  function Compiler() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Compiler.prototype;

  _proto.init = function init(templateName, throwOnUndefined) {
    this.templateName = templateName;
    this.codebuf = [];
    this.lastId = 0;
    this.buffer = null;
    this.bufferStack = [];
    this._scopeClosers = '';
    this.inBlock = false;
    this.throwOnUndefined = throwOnUndefined;
  };

  _proto.fail = function fail(msg, lineno, colno) {
    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    throw new TemplateError(msg, lineno, colno);
  };

  _proto._pushBuffer = function _pushBuffer() {
    var id = this._tmpid();

    this.bufferStack.push(this.buffer);
    this.buffer = id;

    this._emit("var " + this.buffer + " = \"\";");

    return id;
  };

  _proto._popBuffer = function _popBuffer() {
    this.buffer = this.bufferStack.pop();
  };

  _proto._emit = function _emit(code) {
    this.codebuf.push(code);
  };

  _proto._emitLine = function _emitLine(code) {
    this._emit(code + '\n');
  };

  _proto._emitLines = function _emitLines() {
    var _this = this;

    for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
      lines[_key] = arguments[_key];
    }

    lines.forEach(function (line) {
      return _this._emitLine(line);
    });
  };

  _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
    this.buffer = 'output';
    this._scopeClosers = '';

    this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");

    this._emitLine("var lineno = " + node.lineno + ";");

    this._emitLine("var colno = " + node.colno + ";");

    this._emitLine("var " + this.buffer + " = \"\";");

    this._emitLine('try {');
  };

  _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
    if (!noReturn) {
      this._emitLine('cb(null, ' + this.buffer + ');');
    }

    this._closeScopeLevels();

    this._emitLine('} catch (e) {');

    this._emitLine('  cb(runtime.handleError(e, lineno, colno));');

    this._emitLine('}');

    this._emitLine('}');

    this.buffer = null;
  };

  _proto._addScopeLevel = function _addScopeLevel() {
    this._scopeClosers += '})';
  };

  _proto._closeScopeLevels = function _closeScopeLevels() {
    this._emitLine(this._scopeClosers + ';');

    this._scopeClosers = '';
  };

  _proto._withScopedSyntax = function _withScopedSyntax(func) {
    var _scopeClosers = this._scopeClosers;
    this._scopeClosers = '';
    func.call(this);

    this._closeScopeLevels();

    this._scopeClosers = _scopeClosers;
  };

  _proto._makeCallback = function _makeCallback(res) {
    var err = this._tmpid();

    return 'function(' + err + (res ? ',' + res : '') + ') {\n' + 'if(' + err + ') { cb(' + err + '); return; }';
  };

  _proto._tmpid = function _tmpid() {
    this.lastId++;
    return 't_' + this.lastId;
  };

  _proto._templateName = function _templateName() {
    return this.templateName == null ? 'undefined' : JSON.stringify(this.templateName);
  };

  _proto._compileChildren = function _compileChildren(node, frame) {
    var _this2 = this;

    node.children.forEach(function (child) {
      _this2.compile(child, frame);
    });
  };

  _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
    var _this3 = this;

    if (startChar) {
      this._emit(startChar);
    }

    node.children.forEach(function (child, i) {
      if (i > 0) {
        _this3._emit(',');
      }

      _this3.compile(child, frame);
    });

    if (endChar) {
      this._emit(endChar);
    }
  };

  _proto._compileExpression = function _compileExpression(node, frame) {
    // TODO: I'm not really sure if this type check is worth it or
    // not.
    this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
    this.compile(node, frame);
  };

  _proto.assertType = function assertType(node) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      types[_key2 - 1] = arguments[_key2];
    }

    if (!types.some(function (t) {
      return node instanceof t;
    })) {
      this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
    var _this4 = this;

    var args = node.args;
    var contentArgs = node.contentArgs;
    var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

    if (!async) {
      this._emit(this.buffer + " += runtime.suppressValue(");
    }

    this._emit("env.getExtension(\"" + node.extName + "\")[\"" + node.prop + "\"](");

    this._emit('context');

    if (args || contentArgs) {
      this._emit(',');
    }

    if (args) {
      if (!(args instanceof nodes.NodeList)) {
        this.fail('compileCallExtension: arguments must be a NodeList, ' + 'use `parser.parseSignature`');
      }

      args.children.forEach(function (arg, i) {
        // Tag arguments are passed normally to the call. Note
        // that keyword arguments are turned into a single js
        // object as the last argument, if they exist.
        _this4._compileExpression(arg, frame);

        if (i !== args.children.length - 1 || contentArgs.length) {
          _this4._emit(',');
        }
      });
    }

    if (contentArgs.length) {
      contentArgs.forEach(function (arg, i) {
        if (i > 0) {
          _this4._emit(',');
        }

        if (arg) {
          _this4._emitLine('function(cb) {');

          _this4._emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');

          var id = _this4._pushBuffer();

          _this4._withScopedSyntax(function () {
            _this4.compile(arg, frame);

            _this4._emitLine("cb(null, " + id + ");");
          });

          _this4._popBuffer();

          _this4._emitLine("return " + id + ";");

          _this4._emitLine('}');
        } else {
          _this4._emit('null');
        }
      });
    }

    if (async) {
      var res = this._tmpid();

      this._emitLine(', ' + this._makeCallback(res));

      this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");

      this._addScopeLevel();
    } else {
      this._emit(')');

      this._emit(", " + autoescape + " && env.opts.autoescape);\n");
    }
  };

  _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
    this.compileCallExtension(node, frame, true);
  };

  _proto.compileNodeList = function compileNodeList(node, frame) {
    this._compileChildren(node, frame);
  };

  _proto.compileLiteral = function compileLiteral(node) {
    if (typeof node.value === 'string') {
      var val = node.value.replace(/\\/g, '\\\\');
      val = val.replace(/"/g, '\\"');
      val = val.replace(/\n/g, '\\n');
      val = val.replace(/\r/g, '\\r');
      val = val.replace(/\t/g, '\\t');
      val = val.replace(/\u2028/g, "\\u2028");

      this._emit("\"" + val + "\"");
    } else if (node.value === null) {
      this._emit('null');
    } else {
      this._emit(node.value.toString());
    }
  };

  _proto.compileSymbol = function compileSymbol(node, frame) {
    var name = node.value;
    var v = frame.lookup(name);

    if (v) {
      this._emit(v);
    } else {
      this._emit('runtime.contextOrFrameLookup(' + 'context, frame, "' + name + '")');
    }
  };

  _proto.compileGroup = function compileGroup(node, frame) {
    this._compileAggregate(node, frame, '(', ')');
  };

  _proto.compileArray = function compileArray(node, frame) {
    this._compileAggregate(node, frame, '[', ']');
  };

  _proto.compileDict = function compileDict(node, frame) {
    this._compileAggregate(node, frame, '{', '}');
  };

  _proto.compilePair = function compilePair(node, frame) {
    var key = node.key;
    var val = node.value;

    if (key instanceof nodes.Symbol) {
      key = new nodes.Literal(key.lineno, key.colno, key.value);
    } else if (!(key instanceof nodes.Literal && typeof key.value === 'string')) {
      this.fail('compilePair: Dict keys must be strings or names', key.lineno, key.colno);
    }

    this.compile(key, frame);

    this._emit(': ');

    this._compileExpression(val, frame);
  };

  _proto.compileInlineIf = function compileInlineIf(node, frame) {
    this._emit('(');

    this.compile(node.cond, frame);

    this._emit('?');

    this.compile(node.body, frame);

    this._emit(':');

    if (node.else_ !== null) {
      this.compile(node.else_, frame);
    } else {
      this._emit('""');
    }

    this._emit(')');
  };

  _proto.compileIn = function compileIn(node, frame) {
    this._emit('runtime.inOperator(');

    this.compile(node.left, frame);

    this._emit(',');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileIs = function compileIs(node, frame) {
    // first, we need to try to get the name of the test function, if it's a
    // callable (i.e., has args) and not a symbol.
    var right = node.right.name ? node.right.name.value // otherwise go with the symbol value
    : node.right.value;

    this._emit('env.getTest("' + right + '").call(context, ');

    this.compile(node.left, frame); // compile the arguments for the callable if they exist

    if (node.right.args) {
      this._emit(',');

      this.compile(node.right.args, frame);
    }

    this._emit(') === true');
  };

  _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
    this.compile(node.left, frame);

    this._emit(str);

    this.compile(node.right, frame);
  } // ensure concatenation instead of addition
  // by adding empty string in between
  ;

  _proto.compileOr = function compileOr(node, frame) {
    return this._binOpEmitter(node, frame, ' || ');
  };

  _proto.compileAnd = function compileAnd(node, frame) {
    return this._binOpEmitter(node, frame, ' && ');
  };

  _proto.compileAdd = function compileAdd(node, frame) {
    return this._binOpEmitter(node, frame, ' + ');
  };

  _proto.compileConcat = function compileConcat(node, frame) {
    return this._binOpEmitter(node, frame, ' + "" + ');
  };

  _proto.compileSub = function compileSub(node, frame) {
    return this._binOpEmitter(node, frame, ' - ');
  };

  _proto.compileMul = function compileMul(node, frame) {
    return this._binOpEmitter(node, frame, ' * ');
  };

  _proto.compileDiv = function compileDiv(node, frame) {
    return this._binOpEmitter(node, frame, ' / ');
  };

  _proto.compileMod = function compileMod(node, frame) {
    return this._binOpEmitter(node, frame, ' % ');
  };

  _proto.compileNot = function compileNot(node, frame) {
    this._emit('!');

    this.compile(node.target, frame);
  };

  _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
    this._emit('Math.floor(');

    this.compile(node.left, frame);

    this._emit(' / ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compilePow = function compilePow(node, frame) {
    this._emit('Math.pow(');

    this.compile(node.left, frame);

    this._emit(', ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileNeg = function compileNeg(node, frame) {
    this._emit('-');

    this.compile(node.target, frame);
  };

  _proto.compilePos = function compilePos(node, frame) {
    this._emit('+');

    this.compile(node.target, frame);
  };

  _proto.compileCompare = function compileCompare(node, frame) {
    var _this5 = this;

    this.compile(node.expr, frame);
    node.ops.forEach(function (op) {
      _this5._emit(" " + compareOps[op.type] + " ");

      _this5.compile(op.expr, frame);
    });
  };

  _proto.compileLookupVal = function compileLookupVal(node, frame) {
    this._emit('runtime.memberLookup((');

    this._compileExpression(node.target, frame);

    this._emit('),');

    this._compileExpression(node.val, frame);

    this._emit(')');
  };

  _proto._getNodeName = function _getNodeName(node) {
    switch (node.typename) {
      case 'Symbol':
        return node.value;

      case 'FunCall':
        return 'the return value of (' + this._getNodeName(node.name) + ')';

      case 'LookupVal':
        return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';

      case 'Literal':
        return node.value.toString();

      default:
        return '--expression--';
    }
  };

  _proto.compileFunCall = function compileFunCall(node, frame) {
    // Keep track of line/col info at runtime by settings
    // variables within an expression. An expression in javascript
    // like (x, y, z) returns the last value, and x and y can be
    // anything
    this._emit('(lineno = ' + node.lineno + ', colno = ' + node.colno + ', ');

    this._emit('runtime.callWrap('); // Compile it as normal.


    this._compileExpression(node.name, frame); // Output the name of what we're calling so we can get friendly errors
    // if the lookup fails.


    this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

    this._compileAggregate(node.args, frame, '[', '])');

    this._emit(')');
  };

  _proto.compileFilter = function compileFilter(node, frame) {
    var name = node.name;
    this.assertType(name, nodes.Symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emit(')');
  };

  _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
    var name = node.name;
    var symbol = node.symbol.value;
    this.assertType(name, nodes.Symbol);
    frame.set(symbol, symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emitLine(', ' + this._makeCallback(symbol));

    this._addScopeLevel();
  };

  _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
    this._emit('runtime.makeKeywordArgs(');

    this.compileDict(node, frame);

    this._emit(')');
  };

  _proto.compileSet = function compileSet(node, frame) {
    var _this6 = this;

    var ids = []; // Lookup the variable names for each identifier and create
    // new ones if necessary

    node.targets.forEach(function (target) {
      var name = target.value;
      var id = frame.lookup(name);

      if (id === null || id === undefined) {
        id = _this6._tmpid(); // Note: This relies on js allowing scope across
        // blocks, in case this is created inside an `if`

        _this6._emitLine('var ' + id + ';');
      }

      ids.push(id);
    });

    if (node.value) {
      this._emit(ids.join(' = ') + ' = ');

      this._compileExpression(node.value, frame);

      this._emitLine(';');
    } else {
      this._emit(ids.join(' = ') + ' = ');

      this.compile(node.body, frame);

      this._emitLine(';');
    }

    node.targets.forEach(function (target, i) {
      var id = ids[i];
      var name = target.value; // We are running this for every var, but it's very
      // uncommon to assign to multiple vars anyway

      _this6._emitLine("frame.set(\"" + name + "\", " + id + ", true);");

      _this6._emitLine('if(frame.topLevel) {');

      _this6._emitLine("context.setVariable(\"" + name + "\", " + id + ");");

      _this6._emitLine('}');

      if (name.charAt(0) !== '_') {
        _this6._emitLine('if(frame.topLevel) {');

        _this6._emitLine("context.addExport(\"" + name + "\", " + id + ");");

        _this6._emitLine('}');
      }
    });
  };

  _proto.compileSwitch = function compileSwitch(node, frame) {
    var _this7 = this;

    this._emit('switch (');

    this.compile(node.expr, frame);

    this._emit(') {');

    node.cases.forEach(function (c, i) {
      _this7._emit('case ');

      _this7.compile(c.cond, frame);

      _this7._emit(': ');

      _this7.compile(c.body, frame); // preserve fall-throughs


      if (c.body.children.length) {
        _this7._emitLine('break;');
      }
    });

    if (node["default"]) {
      this._emit('default:');

      this.compile(node["default"], frame);
    }

    this._emit('}');
  };

  _proto.compileIf = function compileIf(node, frame, async) {
    var _this8 = this;

    this._emit('if(');

    this._compileExpression(node.cond, frame);

    this._emitLine(') {');

    this._withScopedSyntax(function () {
      _this8.compile(node.body, frame);

      if (async) {
        _this8._emit('cb()');
      }
    });

    if (node.else_) {
      this._emitLine('}\nelse {');

      this._withScopedSyntax(function () {
        _this8.compile(node.else_, frame);

        if (async) {
          _this8._emit('cb()');
        }
      });
    } else if (async) {
      this._emitLine('}\nelse {');

      this._emit('cb()');
    }

    this._emitLine('}');
  };

  _proto.compileIfAsync = function compileIfAsync(node, frame) {
    this._emit('(function(cb) {');

    this.compileIf(node, frame, true);

    this._emit('})(' + this._makeCallback());

    this._addScopeLevel();
  };

  _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
    var _this9 = this;

    var bindings = [{
      name: 'index',
      val: i + " + 1"
    }, {
      name: 'index0',
      val: i
    }, {
      name: 'revindex',
      val: len + " - " + i
    }, {
      name: 'revindex0',
      val: len + " - " + i + " - 1"
    }, {
      name: 'first',
      val: i + " === 0"
    }, {
      name: 'last',
      val: i + " === " + len + " - 1"
    }, {
      name: 'length',
      val: len
    }];
    bindings.forEach(function (b) {
      _this9._emitLine("frame.set(\"loop." + b.name + "\", " + b.val + ");");
    });
  };

  _proto.compileFor = function compileFor(node, frame) {
    var _this10 = this; // Some of this code is ugly, but it keeps the generated code
    // as fast as possible. ForAsync also shares some of this, but
    // not much.


    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit("var " + arr + " = ");

    this._compileExpression(node.arr, frame);

    this._emitLine(';');

    this._emit("if(" + arr + ") {");

    this._emitLine(arr + ' = runtime.fromIterator(' + arr + ');'); // If multiple names are passed, we need to bind them
    // appropriately


    if (node.name instanceof nodes.Array) {
      this._emitLine("var " + i + ";"); // The object could be an arroy or object. Note that the
      // body of the loop is duplicated for each condition, but
      // we are optimizing for speed over size.


      this._emitLine("if(runtime.isArray(" + arr + ")) {");

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {"); // Bind each declared var


      node.name.children.forEach(function (child, u) {
        var tid = _this10._tmpid();

        _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");

        _this10._emitLine("frame.set(\"" + child + "\", " + arr + "[" + i + "][" + u + "]);");

        frame.set(node.name.children[u].value, tid);
      });

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('} else {'); // Iterate over the key/values of an object


      var _node$name$children = node.name.children,
          key = _node$name$children[0],
          val = _node$name$children[1];

      var k = this._tmpid();

      var v = this._tmpid();

      frame.set(key.value, k);
      frame.set(val.value, v);

      this._emitLine(i + " = -1;");

      this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");

      this._emitLine("for(var " + k + " in " + arr + ") {");

      this._emitLine(i + "++;");

      this._emitLine("var " + v + " = " + arr + "[" + k + "];");

      this._emitLine("frame.set(\"" + key.value + "\", " + k + ");");

      this._emitLine("frame.set(\"" + val.value + "\", " + v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('}');
    } else {
      // Generate a typical array iteration
      var _v = this._tmpid();

      frame.set(node.name.value, _v);

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");

      this._emitLine("var " + _v + " = " + arr + "[" + i + "];");

      this._emitLine("frame.set(\"" + node.name.value + "\", " + _v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');
    }

    this._emitLine('}');

    if (node.else_) {
      this._emitLine('if (!' + len + ') {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
    var _this11 = this; // This shares some code with the For tag, but not enough to
    // worry about. This iterates across an object asynchronously,
    // but not in parallel.


    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit('var ' + arr + ' = runtime.fromIterator(');

    this._compileExpression(node.arr, frame);

    this._emitLine(');');

    if (node.name instanceof nodes.Array) {
      var arrayLen = node.name.children.length;

      this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");

      node.name.children.forEach(function (name) {
        _this11._emit(name.value + ",");
      });

      this._emit(i + ',' + len + ',next) {');

      node.name.children.forEach(function (name) {
        var id = name.value;
        frame.set(id, id);

        _this11._emitLine("frame.set(\"" + id + "\", " + id + ");");
      });
    } else {
      var id = node.name.value;

      this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");

      this._emitLine('frame.set("' + id + '", ' + id + ');');

      frame.set(id, id);
    }

    this._emitLoopBindings(node, arr, i, len);

    this._withScopedSyntax(function () {
      var buf;

      if (parallel) {
        buf = _this11._pushBuffer();
      }

      _this11.compile(node.body, frame);

      _this11._emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

      if (parallel) {
        _this11._popBuffer();
      }
    });

    var output = this._tmpid();

    this._emitLine('}, ' + this._makeCallback(output));

    this._addScopeLevel();

    if (parallel) {
      this._emitLine(this.buffer + ' += ' + output + ';');
    }

    if (node.else_) {
      this._emitLine('if (!' + arr + '.length) {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
    this._compileAsyncLoop(node, frame);
  };

  _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
    this._compileAsyncLoop(node, frame, true);
  };

  _proto._compileMacro = function _compileMacro(node, frame) {
    var _this12 = this;

    var args = [];
    var kwargs = null;

    var funcId = 'macro_' + this._tmpid();

    var keepFrame = frame !== undefined; // Type check the definition of the args

    node.args.children.forEach(function (arg, i) {
      if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
        kwargs = arg;
      } else {
        _this12.assertType(arg, nodes.Symbol);

        args.push(arg);
      }
    });
    var realNames = [].concat(args.map(function (n) {
      return "l_" + n.value;
    }), ['kwargs']); // Quoted argument names

    var argNames = args.map(function (n) {
      return "\"" + n.value + "\"";
    });
    var kwargNames = (kwargs && kwargs.children || []).map(function (n) {
      return "\"" + n.key.value + "\"";
    }); // We pass a function to makeMacro which destructures the
    // arguments so support setting positional args with keywords
    // args and passing keyword args as positional args
    // (essentially default values). See runtime.js.

    var currFrame;

    if (keepFrame) {
      currFrame = frame.push(true);
    } else {
      currFrame = new Frame();
    }

    this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(', ') + "], ", "[" + kwargNames.join(', ') + "], ", "function (" + realNames.join(', ') + ") {", 'var callerFrame = frame;', 'frame = ' + (keepFrame ? 'frame.push(true);' : 'new runtime.Frame();'), 'kwargs = kwargs || {};', 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }'); // Expose the arguments to the template. Don't need to use
    // random names because the function
    // will create a new run-time scope for us


    args.forEach(function (arg) {
      _this12._emitLine("frame.set(\"" + arg.value + "\", l_" + arg.value + ");");

      currFrame.set(arg.value, "l_" + arg.value);
    }); // Expose the keyword arguments

    if (kwargs) {
      kwargs.children.forEach(function (pair) {
        var name = pair.key.value;

        _this12._emit("frame.set(\"" + name + "\", ");

        _this12._emit("Object.prototype.hasOwnProperty.call(kwargs, \"" + name + "\")");

        _this12._emit(" ? kwargs[\"" + name + "\"] : ");

        _this12._compileExpression(pair.value, currFrame);

        _this12._emit(');');
      });
    }

    var bufferId = this._pushBuffer();

    this._withScopedSyntax(function () {
      _this12.compile(node.body, currFrame);
    });

    this._emitLine('frame = ' + (keepFrame ? 'frame.pop();' : 'callerFrame;'));

    this._emitLine("return new runtime.SafeString(" + bufferId + ");");

    this._emitLine('});');

    this._popBuffer();

    return funcId;
  };

  _proto.compileMacro = function compileMacro(node, frame) {
    var funcId = this._compileMacro(node); // Expose the macro to the templates


    var name = node.name.value;
    frame.set(name, funcId);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + name + "\", " + funcId + ");");
    } else {
      if (node.name.value.charAt(0) !== '_') {
        this._emitLine("context.addExport(\"" + name + "\");");
      }

      this._emitLine("context.setVariable(\"" + name + "\", " + funcId + ");");
    }
  };

  _proto.compileCaller = function compileCaller(node, frame) {
    // basically an anonymous "macro expression"
    this._emit('(function (){');

    var funcId = this._compileMacro(node, frame);

    this._emit("return " + funcId + ";})()");
  };

  _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
    var parentTemplateId = this._tmpid();

    var parentName = this._templateName();

    var cb = this._makeCallback(parentTemplateId);

    var eagerCompileArg = eagerCompile ? 'true' : 'false';
    var ignoreMissingArg = ignoreMissing ? 'true' : 'false';

    this._emit('env.getTemplate(');

    this._compileExpression(node.template, frame);

    this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);

    return parentTemplateId;
  };

  _proto.compileImport = function compileImport(node, frame) {
    var target = node.target.value;

    var id = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(id + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(id));

    this._addScopeLevel();

    frame.set(target, id);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + target + "\", " + id + ");");
    } else {
      this._emitLine("context.setVariable(\"" + target + "\", " + id + ");");
    }
  };

  _proto.compileFromImport = function compileFromImport(node, frame) {
    var _this13 = this;

    var importedId = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(importedId + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(importedId));

    this._addScopeLevel();

    node.names.children.forEach(function (nameNode) {
      var name;
      var alias;

      var id = _this13._tmpid();

      if (nameNode instanceof nodes.Pair) {
        name = nameNode.key.value;
        alias = nameNode.value.value;
      } else {
        name = nameNode.value;
        alias = name;
      }

      _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ", \"" + name + "\")) {");

      _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");

      _this13._emitLine('} else {');

      _this13._emitLine("cb(new Error(\"cannot import '" + name + "'\")); return;");

      _this13._emitLine('}');

      frame.set(alias, id);

      if (frame.parent) {
        _this13._emitLine("frame.set(\"" + alias + "\", " + id + ");");
      } else {
        _this13._emitLine("context.setVariable(\"" + alias + "\", " + id + ");");
      }
    });
  };

  _proto.compileBlock = function compileBlock(node) {
    var id = this._tmpid(); // If we are executing outside a block (creating a top-level
    // block), we really don't want to execute its code because it
    // will execute twice: once when the child template runs and
    // again when the parent template runs. Note that blocks
    // within blocks will *always* execute immediately *and*
    // wherever else they are invoked (like used in a parent
    // template). This may have behavioral differences from jinja
    // because blocks can have side effects, but it seems like a
    // waste of performance to always execute huge top-level
    // blocks twice


    if (!this.inBlock) {
      this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
    }

    this._emit("context.getBlock(\"" + node.name.value + "\")");

    if (!this.inBlock) {
      this._emit(')');
    }

    this._emitLine('(env, context, frame, runtime, ' + this._makeCallback(id));

    this._emitLine(this.buffer + " += " + id + ";");

    this._addScopeLevel();
  };

  _proto.compileSuper = function compileSuper(node, frame) {
    var name = node.blockName.value;
    var id = node.symbol.value;

    var cb = this._makeCallback(id);

    this._emitLine("context.getSuper(env, \"" + name + "\", b_" + name + ", frame, runtime, " + cb);

    this._emitLine(id + " = runtime.markSafe(" + id + ");");

    this._addScopeLevel();

    frame.set(id, id);
  };

  _proto.compileExtends = function compileExtends(node, frame) {
    var k = this._tmpid();

    var parentTemplateId = this._compileGetTemplate(node, frame, true, false); // extends is a dynamic tag and can occur within a block like
    // `if`, so if this happens we need to capture the parent
    // template in the top-level scope


    this._emitLine("parentTemplate = " + parentTemplateId);

    this._emitLine("for(var " + k + " in parentTemplate.blocks) {");

    this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");

    this._emitLine('}');

    this._addScopeLevel();
  };

  _proto.compileInclude = function compileInclude(node, frame) {
    this._emitLine('var tasks = [];');

    this._emitLine('tasks.push(');

    this._emitLine('function(callback) {');

    var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);

    this._emitLine("callback(null," + id + ");});");

    this._emitLine('});');

    var id2 = this._tmpid();

    this._emitLine('tasks.push(');

    this._emitLine('function(template, callback){');

    this._emitLine('template.render(context.getVariables(), frame, ' + this._makeCallback(id2));

    this._emitLine('callback(null,' + id2 + ');});');

    this._emitLine('});');

    this._emitLine('tasks.push(');

    this._emitLine('function(result, callback){');

    this._emitLine(this.buffer + " += result;");

    this._emitLine('callback(null);');

    this._emitLine('});');

    this._emitLine('env.waterfall(tasks, function(){');

    this._addScopeLevel();
  };

  _proto.compileTemplateData = function compileTemplateData(node, frame) {
    this.compileLiteral(node, frame);
  };

  _proto.compileCapture = function compileCapture(node, frame) {
    var _this14 = this; // we need to temporarily override the current buffer id as 'output'
    // so the set block writes to the capture output instead of the buffer


    var buffer = this.buffer;
    this.buffer = 'output';

    this._emitLine('(function() {');

    this._emitLine('var output = "";');

    this._withScopedSyntax(function () {
      _this14.compile(node.body, frame);
    });

    this._emitLine('return output;');

    this._emitLine('})()'); // and of course, revert back to the old buffer id


    this.buffer = buffer;
  };

  _proto.compileOutput = function compileOutput(node, frame) {
    var _this15 = this;

    var children = node.children;
    children.forEach(function (child) {
      // TemplateData is a special case because it is never
      // autoescaped, so simply output it for optimization
      if (child instanceof nodes.TemplateData) {
        if (child.value) {
          _this15._emit(_this15.buffer + " += ");

          _this15.compileLiteral(child, frame);

          _this15._emitLine(';');
        }
      } else {
        _this15._emit(_this15.buffer + " += runtime.suppressValue(");

        if (_this15.throwOnUndefined) {
          _this15._emit('runtime.ensureDefined(');
        }

        _this15.compile(child, frame);

        if (_this15.throwOnUndefined) {
          _this15._emit("," + node.lineno + "," + node.colno + ")");
        }

        _this15._emit(', env.opts.autoescape);\n');
      }
    });
  };

  _proto.compileRoot = function compileRoot(node, frame) {
    var _this16 = this;

    if (frame) {
      this.fail('compileRoot: root node can\'t have frame');
    }

    frame = new Frame();

    this._emitFuncBegin(node, 'root');

    this._emitLine('var parentTemplate = null;');

    this._compileChildren(node, frame);

    this._emitLine('if(parentTemplate) {');

    this._emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');

    this._emitLine('} else {');

    this._emitLine("cb(null, " + this.buffer + ");");

    this._emitLine('}');

    this._emitFuncEnd(true);

    this.inBlock = true;
    var blockNames = [];
    var blocks = node.findAll(nodes.Block);
    blocks.forEach(function (block, i) {
      var name = block.name.value;

      if (blockNames.indexOf(name) !== -1) {
        throw new Error("Block \"" + name + "\" defined more than once.");
      }

      blockNames.push(name);

      _this16._emitFuncBegin(block, "b_" + name);

      var tmpFrame = new Frame();

      _this16._emitLine('var frame = frame.push(true);');

      _this16.compile(block.body, tmpFrame);

      _this16._emitFuncEnd();
    });

    this._emitLine('return {');

    blocks.forEach(function (block, i) {
      var blockName = "b_" + block.name.value;

      _this16._emitLine(blockName + ": " + blockName + ",");
    });

    this._emitLine('root: root\n};');
  };

  _proto.compile = function compile(node, frame) {
    var _compile = this['compile' + node.typename];

    if (_compile) {
      _compile.call(this, node, frame);
    } else {
      this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.getCode = function getCode() {
    return this.codebuf.join('');
  };

  return Compiler;
}(Obj);

module.exports = {
  compile: function compile(src, asyncFilters, extensions, name, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var c = new Compiler(name, opts.throwOnUndefined); // Run the extension preprocessors against the source.

    var preprocessors = (extensions || []).map(function (ext) {
      return ext.preprocess;
    }).filter(function (f) {
      return !!f;
    });
    var processedSrc = preprocessors.reduce(function (s, processor) {
      return processor(s);
    }, src);
    c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
    return c.getCode();
  },
  Compiler: Compiler
};
        },
        map: {"./parser":206,"./transformer":295,"./nodes":209,"./lib":200,"./runtime":208,"./object":291}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/parser.js
      206: {
        factory: (module, exports, require) => {
          'use strict';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var lexer = require('./lexer');

var nodes = require('./nodes');

var Obj = require('./object').Obj;

var lib = require('./lib');

var Parser = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Parser, _Obj);

  function Parser() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Parser.prototype;

  _proto.init = function init(tokens) {
    this.tokens = tokens;
    this.peeked = null;
    this.breakOnBlocks = null;
    this.dropLeadingWhitespace = false;
    this.extensions = [];
  };

  _proto.nextToken = function nextToken(withWhitespace) {
    var tok;

    if (this.peeked) {
      if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
        this.peeked = null;
      } else {
        tok = this.peeked;
        this.peeked = null;
        return tok;
      }
    }

    tok = this.tokens.nextToken();

    if (!withWhitespace) {
      while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
        tok = this.tokens.nextToken();
      }
    }

    return tok;
  };

  _proto.peekToken = function peekToken() {
    this.peeked = this.peeked || this.nextToken();
    return this.peeked;
  };

  _proto.pushToken = function pushToken(tok) {
    if (this.peeked) {
      throw new Error('pushToken: can only push one token on between reads');
    }

    this.peeked = tok;
  };

  _proto.error = function error(msg, lineno, colno) {
    if (lineno === undefined || colno === undefined) {
      var tok = this.peekToken() || {};
      lineno = tok.lineno;
      colno = tok.colno;
    }

    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    return new lib.TemplateError(msg, lineno, colno);
  };

  _proto.fail = function fail(msg, lineno, colno) {
    throw this.error(msg, lineno, colno);
  };

  _proto.skip = function skip(type) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.expect = function expect(type) {
    var tok = this.nextToken();

    if (tok.type !== type) {
      this.fail('expected ' + type + ', got ' + tok.type, tok.lineno, tok.colno);
    }

    return tok;
  };

  _proto.skipValue = function skipValue(type, val) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type || tok.value !== val) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.skipSymbol = function skipSymbol(val) {
    return this.skipValue(lexer.TOKEN_SYMBOL, val);
  };

  _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
    var tok;

    if (!name) {
      tok = this.peekToken();

      if (!tok) {
        this.fail('unexpected end of file');
      }

      if (tok.type !== lexer.TOKEN_SYMBOL) {
        this.fail('advanceAfterBlockEnd: expected symbol token or ' + 'explicit name to be passed');
      }

      name = this.nextToken().value;
    }

    tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
      if (tok.value.charAt(0) === '-') {
        this.dropLeadingWhitespace = true;
      }
    } else {
      this.fail('expected block end in ' + name + ' statement');
    }

    return tok;
  };

  _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
    var tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
      this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === '-';
    } else {
      this.pushToken(tok);
      this.fail('expected variable end');
    }
  };

  _proto.parseFor = function parseFor() {
    var forTok = this.peekToken();
    var node;
    var endBlock;

    if (this.skipSymbol('for')) {
      node = new nodes.For(forTok.lineno, forTok.colno);
      endBlock = 'endfor';
    } else if (this.skipSymbol('asyncEach')) {
      node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
      endBlock = 'endeach';
    } else if (this.skipSymbol('asyncAll')) {
      node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
      endBlock = 'endall';
    } else {
      this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
    }

    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseFor: variable name expected for loop');
    }

    var type = this.peekToken().type;

    if (type === lexer.TOKEN_COMMA) {
      // key/value iteration
      var key = node.name;
      node.name = new nodes.Array(key.lineno, key.colno);
      node.name.addChild(key);

      while (this.skip(lexer.TOKEN_COMMA)) {
        var prim = this.parsePrimary();
        node.name.addChild(prim);
      }
    }

    if (!this.skipSymbol('in')) {
      this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
    }

    node.arr = this.parseExpression();
    this.advanceAfterBlockEnd(forTok.value);
    node.body = this.parseUntilBlocks(endBlock, 'else');

    if (this.skipSymbol('else')) {
      this.advanceAfterBlockEnd('else');
      node.else_ = this.parseUntilBlocks(endBlock);
    }

    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseMacro = function parseMacro() {
    var macroTok = this.peekToken();

    if (!this.skipSymbol('macro')) {
      this.fail('expected macro');
    }

    var name = this.parsePrimary(true);
    var args = this.parseSignature();
    var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
    this.advanceAfterBlockEnd(macroTok.value);
    node.body = this.parseUntilBlocks('endmacro');
    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseCall = function parseCall() {
    // a call block is parsed as a normal FunCall, but with an added
    // 'caller' kwarg which is a Caller node.
    var callTok = this.peekToken();

    if (!this.skipSymbol('call')) {
      this.fail('expected call');
    }

    var callerArgs = this.parseSignature(true) || new nodes.NodeList();
    var macroCall = this.parsePrimary();
    this.advanceAfterBlockEnd(callTok.value);
    var body = this.parseUntilBlocks('endcall');
    this.advanceAfterBlockEnd();
    var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, 'caller');
    var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body); // add the additional caller kwarg, adding kwargs if necessary

    var args = macroCall.args.children;

    if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
      args.push(new nodes.KeywordArgs());
    }

    var kwargs = args[args.length - 1];
    kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
    return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
  };

  _proto.parseWithContext = function parseWithContext() {
    var tok = this.peekToken();
    var withContext = null;

    if (this.skipSymbol('with')) {
      withContext = true;
    } else if (this.skipSymbol('without')) {
      withContext = false;
    }

    if (withContext !== null) {
      if (!this.skipSymbol('context')) {
        this.fail('parseFrom: expected context after with/without', tok.lineno, tok.colno);
      }
    }

    return withContext;
  };

  _proto.parseImport = function parseImport() {
    var importTok = this.peekToken();

    if (!this.skipSymbol('import')) {
      this.fail('parseImport: expected import', importTok.lineno, importTok.colno);
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('as')) {
      this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
    }

    var target = this.parseExpression();
    var withContext = this.parseWithContext();
    var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
    this.advanceAfterBlockEnd(importTok.value);
    return node;
  };

  _proto.parseFrom = function parseFrom() {
    var fromTok = this.peekToken();

    if (!this.skipSymbol('from')) {
      this.fail('parseFrom: expected from');
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('import')) {
      this.fail('parseFrom: expected import', fromTok.lineno, fromTok.colno);
    }

    var names = new nodes.NodeList();
    var withContext;

    while (1) {
      // eslint-disable-line no-constant-condition
      var nextTok = this.peekToken();

      if (nextTok.type === lexer.TOKEN_BLOCK_END) {
        if (!names.children.length) {
          this.fail('parseFrom: Expected at least one import name', fromTok.lineno, fromTok.colno);
        } // Since we are manually advancing past the block end,
        // need to keep track of whitespace control (normally
        // this is done in `advanceAfterBlockEnd`


        if (nextTok.value.charAt(0) === '-') {
          this.dropLeadingWhitespace = true;
        }

        this.nextToken();
        break;
      }

      if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseFrom: expected comma', fromTok.lineno, fromTok.colno);
      }

      var name = this.parsePrimary();

      if (name.value.charAt(0) === '_') {
        this.fail('parseFrom: names starting with an underscore cannot be imported', name.lineno, name.colno);
      }

      if (this.skipSymbol('as')) {
        var alias = this.parsePrimary();
        names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
      } else {
        names.addChild(name);
      }

      withContext = this.parseWithContext();
    }

    return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
  };

  _proto.parseBlock = function parseBlock() {
    var tag = this.peekToken();

    if (!this.skipSymbol('block')) {
      this.fail('parseBlock: expected block', tag.lineno, tag.colno);
    }

    var node = new nodes.Block(tag.lineno, tag.colno);
    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseBlock: variable name expected', tag.lineno, tag.colno);
    }

    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('endblock');
    this.skipSymbol('endblock');
    this.skipSymbol(node.name.value);
    var tok = this.peekToken();

    if (!tok) {
      this.fail('parseBlock: expected endblock, got end of file');
    }

    this.advanceAfterBlockEnd(tok.value);
    return node;
  };

  _proto.parseExtends = function parseExtends() {
    var tagName = 'extends';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseTemplateRef: expected ' + tagName);
    }

    var node = new nodes.Extends(tag.lineno, tag.colno);
    node.template = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseInclude = function parseInclude() {
    var tagName = 'include';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseInclude: expected ' + tagName);
    }

    var node = new nodes.Include(tag.lineno, tag.colno);
    node.template = this.parseExpression();

    if (this.skipSymbol('ignore') && this.skipSymbol('missing')) {
      node.ignoreMissing = true;
    }

    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseIf = function parseIf() {
    var tag = this.peekToken();
    var node;

    if (this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
      node = new nodes.If(tag.lineno, tag.colno);
    } else if (this.skipSymbol('ifAsync')) {
      node = new nodes.IfAsync(tag.lineno, tag.colno);
    } else {
      this.fail('parseIf: expected if, elif, or elseif', tag.lineno, tag.colno);
    }

    node.cond = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
    var tok = this.peekToken();

    switch (tok && tok.value) {
      case 'elseif':
      case 'elif':
        node.else_ = this.parseIf();
        break;

      case 'else':
        this.advanceAfterBlockEnd();
        node.else_ = this.parseUntilBlocks('endif');
        this.advanceAfterBlockEnd();
        break;

      case 'endif':
        node.else_ = null;
        this.advanceAfterBlockEnd();
        break;

      default:
        this.fail('parseIf: expected elif, else, or endif, got end of file');
    }

    return node;
  };

  _proto.parseSet = function parseSet() {
    var tag = this.peekToken();

    if (!this.skipSymbol('set')) {
      this.fail('parseSet: expected set', tag.lineno, tag.colno);
    }

    var node = new nodes.Set(tag.lineno, tag.colno, []);
    var target;

    while (target = this.parsePrimary()) {
      node.targets.push(target);

      if (!this.skip(lexer.TOKEN_COMMA)) {
        break;
      }
    }

    if (!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
      if (!this.skip(lexer.TOKEN_BLOCK_END)) {
        this.fail('parseSet: expected = or block end in set tag', tag.lineno, tag.colno);
      } else {
        node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks('endset'));
        node.value = null;
        this.advanceAfterBlockEnd();
      }
    } else {
      node.value = this.parseExpression();
      this.advanceAfterBlockEnd(tag.value);
    }

    return node;
  };

  _proto.parseSwitch = function parseSwitch() {
    /*
     * Store the tag names in variables in case someone ever wants to
     * customize this.
     */
    var switchStart = 'switch';
    var switchEnd = 'endswitch';
    var caseStart = 'case';
    var caseDefault = 'default'; // Get the switch tag.

    var tag = this.peekToken(); // fail early if we get some unexpected tag.

    if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
      this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
    } // parse the switch expression


    var expr = this.parseExpression(); // advance until a start of a case, a default case or an endswitch.

    this.advanceAfterBlockEnd(switchStart);
    this.parseUntilBlocks(caseStart, caseDefault, switchEnd); // this is the first case. it could also be an endswitch, we'll check.

    var tok = this.peekToken(); // create new variables for our cases and default case.

    var cases = [];
    var defaultCase; // while we're dealing with new cases nodes...

    do {
      // skip the start symbol and get the case expression
      this.skipSymbol(caseStart);
      var cond = this.parseExpression();
      this.advanceAfterBlockEnd(switchStart); // get the body of the case node and add it to the array of cases.

      var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
      cases.push(new nodes.Case(tok.line, tok.col, cond, body)); // get our next case

      tok = this.peekToken();
    } while (tok && tok.value === caseStart); // we either have a default case or a switch end.


    switch (tok.value) {
      case caseDefault:
        this.advanceAfterBlockEnd();
        defaultCase = this.parseUntilBlocks(switchEnd);
        this.advanceAfterBlockEnd();
        break;

      case switchEnd:
        this.advanceAfterBlockEnd();
        break;

      default:
        // otherwise bail because EOF
        this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
    } // and return the switch node.


    return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
  };

  _proto.parseStatement = function parseStatement() {
    var tok = this.peekToken();
    var node;

    if (tok.type !== lexer.TOKEN_SYMBOL) {
      this.fail('tag name expected', tok.lineno, tok.colno);
    }

    if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
      return null;
    }

    switch (tok.value) {
      case 'raw':
        return this.parseRaw();

      case 'verbatim':
        return this.parseRaw('verbatim');

      case 'if':
      case 'ifAsync':
        return this.parseIf();

      case 'for':
      case 'asyncEach':
      case 'asyncAll':
        return this.parseFor();

      case 'block':
        return this.parseBlock();

      case 'extends':
        return this.parseExtends();

      case 'include':
        return this.parseInclude();

      case 'set':
        return this.parseSet();

      case 'macro':
        return this.parseMacro();

      case 'call':
        return this.parseCall();

      case 'import':
        return this.parseImport();

      case 'from':
        return this.parseFrom();

      case 'filter':
        return this.parseFilterStatement();

      case 'switch':
        return this.parseSwitch();

      default:
        if (this.extensions.length) {
          for (var i = 0; i < this.extensions.length; i++) {
            var ext = this.extensions[i];

            if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
              return ext.parse(this, nodes, lexer);
            }
          }
        }

        this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
    }

    return node;
  };

  _proto.parseRaw = function parseRaw(tagName) {
    tagName = tagName || 'raw';
    var endTagName = 'end' + tagName; // Look for upcoming raw blocks (ignore all other kinds of blocks)

    var rawBlockRegex = new RegExp('([\\s\\S]*?){%\\s*(' + tagName + '|' + endTagName + ')\\s*(?=%})%}');
    var rawLevel = 1;
    var str = '';
    var matches = null; // Skip opening raw token
    // Keep this token to track line and column numbers

    var begun = this.advanceAfterBlockEnd(); // Exit when there's nothing to match
    // or when we've found the matching "endraw" block

    while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
      var all = matches[0];
      var pre = matches[1];
      var blockName = matches[2]; // Adjust rawlevel

      if (blockName === tagName) {
        rawLevel += 1;
      } else if (blockName === endTagName) {
        rawLevel -= 1;
      } // Add to str


      if (rawLevel === 0) {
        // We want to exclude the last "endraw"
        str += pre; // Move tokenizer to beginning of endraw block

        this.tokens.backN(all.length - pre.length);
      } else {
        str += all;
      }
    }

    return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
  };

  _proto.parsePostfix = function parsePostfix(node) {
    var lookup;
    var tok = this.peekToken();

    while (tok) {
      if (tok.type === lexer.TOKEN_LEFT_PAREN) {
        // Function call
        node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
      } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
        // Reference
        lookup = this.parseAggregate();

        if (lookup.children.length > 1) {
          this.fail('invalid index');
        }

        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
      } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
        // Reference
        this.nextToken();
        var val = this.nextToken();

        if (val.type !== lexer.TOKEN_SYMBOL) {
          this.fail('expected name as lookup value, got ' + val.value, val.lineno, val.colno);
        } // Make a literal string because it's not a variable
        // reference


        lookup = new nodes.Literal(val.lineno, val.colno, val.value);
        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
      } else {
        break;
      }

      tok = this.peekToken();
    }

    return node;
  };

  _proto.parseExpression = function parseExpression() {
    var node = this.parseInlineIf();
    return node;
  };

  _proto.parseInlineIf = function parseInlineIf() {
    var node = this.parseOr();

    if (this.skipSymbol('if')) {
      var condNode = this.parseOr();
      var bodyNode = node;
      node = new nodes.InlineIf(node.lineno, node.colno);
      node.body = bodyNode;
      node.cond = condNode;

      if (this.skipSymbol('else')) {
        node.else_ = this.parseOr();
      } else {
        node.else_ = null;
      }
    }

    return node;
  };

  _proto.parseOr = function parseOr() {
    var node = this.parseAnd();

    while (this.skipSymbol('or')) {
      var node2 = this.parseAnd();
      node = new nodes.Or(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAnd = function parseAnd() {
    var node = this.parseNot();

    while (this.skipSymbol('and')) {
      var node2 = this.parseNot();
      node = new nodes.And(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseNot = function parseNot() {
    var tok = this.peekToken();

    if (this.skipSymbol('not')) {
      return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
    }

    return this.parseIn();
  };

  _proto.parseIn = function parseIn() {
    var node = this.parseIs();

    while (1) {
      // eslint-disable-line no-constant-condition
      // check if the next token is 'not'
      var tok = this.nextToken();

      if (!tok) {
        break;
      }

      var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not'; // if it wasn't 'not', put it back

      if (!invert) {
        this.pushToken(tok);
      }

      if (this.skipSymbol('in')) {
        var node2 = this.parseIs();
        node = new nodes.In(node.lineno, node.colno, node, node2);

        if (invert) {
          node = new nodes.Not(node.lineno, node.colno, node);
        }
      } else {
        // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
        if (invert) {
          this.pushToken(tok);
        }

        break;
      }
    }

    return node;
  } // I put this right after "in" in the operator precedence stack. That can
  // obviously be changed to be closer to Jinja.
  ;

  _proto.parseIs = function parseIs() {
    var node = this.parseCompare(); // look for an is

    if (this.skipSymbol('is')) {
      // look for a not
      var not = this.skipSymbol('not'); // get the next node

      var node2 = this.parseCompare(); // create an Is node using the next node and the info from our Is node.

      node = new nodes.Is(node.lineno, node.colno, node, node2); // if we have a Not, create a Not node from our Is node.

      if (not) {
        node = new nodes.Not(node.lineno, node.colno, node);
      }
    } // return the node.


    return node;
  };

  _proto.parseCompare = function parseCompare() {
    var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
    var expr = this.parseConcat();
    var ops = [];

    while (1) {
      // eslint-disable-line no-constant-condition
      var tok = this.nextToken();

      if (!tok) {
        break;
      } else if (compareOps.indexOf(tok.value) !== -1) {
        ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
      } else {
        this.pushToken(tok);
        break;
      }
    }

    if (ops.length) {
      return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
    } else {
      return expr;
    }
  } // finds the '~' for string concatenation
  ;

  _proto.parseConcat = function parseConcat() {
    var node = this.parseAdd();

    while (this.skipValue(lexer.TOKEN_TILDE, '~')) {
      var node2 = this.parseAdd();
      node = new nodes.Concat(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAdd = function parseAdd() {
    var node = this.parseSub();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      var node2 = this.parseSub();
      node = new nodes.Add(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseSub = function parseSub() {
    var node = this.parseMul();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      var node2 = this.parseMul();
      node = new nodes.Sub(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMul = function parseMul() {
    var node = this.parseDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
      var node2 = this.parseDiv();
      node = new nodes.Mul(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseDiv = function parseDiv() {
    var node = this.parseFloorDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
      var node2 = this.parseFloorDiv();
      node = new nodes.Div(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseFloorDiv = function parseFloorDiv() {
    var node = this.parseMod();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
      var node2 = this.parseMod();
      node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMod = function parseMod() {
    var node = this.parsePow();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
      var node2 = this.parsePow();
      node = new nodes.Mod(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parsePow = function parsePow() {
    var node = this.parseUnary();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
      var node2 = this.parseUnary();
      node = new nodes.Pow(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseUnary = function parseUnary(noFilters) {
    var tok = this.peekToken();
    var node;

    if (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
    } else if (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
    } else {
      node = this.parsePrimary();
    }

    if (!noFilters) {
      node = this.parseFilter(node);
    }

    return node;
  };

  _proto.parsePrimary = function parsePrimary(noPostfix) {
    var tok = this.nextToken();
    var val;
    var node = null;

    if (!tok) {
      this.fail('expected expression, got end of file');
    } else if (tok.type === lexer.TOKEN_STRING) {
      val = tok.value;
    } else if (tok.type === lexer.TOKEN_INT) {
      val = parseInt(tok.value, 10);
    } else if (tok.type === lexer.TOKEN_FLOAT) {
      val = parseFloat(tok.value);
    } else if (tok.type === lexer.TOKEN_BOOLEAN) {
      if (tok.value === 'true') {
        val = true;
      } else if (tok.value === 'false') {
        val = false;
      } else {
        this.fail('invalid boolean: ' + tok.value, tok.lineno, tok.colno);
      }
    } else if (tok.type === lexer.TOKEN_NONE) {
      val = null;
    } else if (tok.type === lexer.TOKEN_REGEX) {
      val = new RegExp(tok.value.body, tok.value.flags);
    }

    if (val !== undefined) {
      node = new nodes.Literal(tok.lineno, tok.colno, val);
    } else if (tok.type === lexer.TOKEN_SYMBOL) {
      node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
    } else {
      // See if it's an aggregate type, we need to push the
      // current delimiter token back on
      this.pushToken(tok);
      node = this.parseAggregate();
    }

    if (!noPostfix) {
      node = this.parsePostfix(node);
    }

    if (node) {
      return node;
    } else {
      throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
    }
  };

  _proto.parseFilterName = function parseFilterName() {
    var tok = this.expect(lexer.TOKEN_SYMBOL);
    var name = tok.value;

    while (this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
      name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
    }

    return new nodes.Symbol(tok.lineno, tok.colno, name);
  };

  _proto.parseFilterArgs = function parseFilterArgs(node) {
    if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
      // Get a FunCall node and add the parameters to the
      // filter
      var call = this.parsePostfix(node);
      return call.args.children;
    }

    return [];
  };

  _proto.parseFilter = function parseFilter(node) {
    while (this.skip(lexer.TOKEN_PIPE)) {
      var name = this.parseFilterName();
      node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
    }

    return node;
  };

  _proto.parseFilterStatement = function parseFilterStatement() {
    var filterTok = this.peekToken();

    if (!this.skipSymbol('filter')) {
      this.fail('parseFilterStatement: expected filter');
    }

    var name = this.parseFilterName();
    var args = this.parseFilterArgs(name);
    this.advanceAfterBlockEnd(filterTok.value);
    var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks('endfilter'));
    this.advanceAfterBlockEnd();
    var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
    return new nodes.Output(name.lineno, name.colno, [node]);
  };

  _proto.parseAggregate = function parseAggregate() {
    var tok = this.nextToken();
    var node;

    switch (tok.type) {
      case lexer.TOKEN_LEFT_PAREN:
        node = new nodes.Group(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_BRACKET:
        node = new nodes.Array(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_CURLY:
        node = new nodes.Dict(tok.lineno, tok.colno);
        break;

      default:
        return null;
    }

    while (1) {
      // eslint-disable-line no-constant-condition
      var type = this.peekToken().type;

      if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
        this.nextToken();
        break;
      }

      if (node.children.length > 0) {
        if (!this.skip(lexer.TOKEN_COMMA)) {
          this.fail('parseAggregate: expected comma after expression', tok.lineno, tok.colno);
        }
      }

      if (node instanceof nodes.Dict) {
        // TODO: check for errors
        var key = this.parsePrimary(); // We expect a key/value pair for dicts, separated by a
        // colon

        if (!this.skip(lexer.TOKEN_COLON)) {
          this.fail('parseAggregate: expected colon after dict key', tok.lineno, tok.colno);
        } // TODO: check for errors


        var value = this.parseExpression();
        node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
      } else {
        // TODO: check for errors
        var expr = this.parseExpression();
        node.addChild(expr);
      }
    }

    return node;
  };

  _proto.parseSignature = function parseSignature(tolerant, noParens) {
    var tok = this.peekToken();

    if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
      if (tolerant) {
        return null;
      } else {
        this.fail('expected arguments', tok.lineno, tok.colno);
      }
    }

    if (tok.type === lexer.TOKEN_LEFT_PAREN) {
      tok = this.nextToken();
    }

    var args = new nodes.NodeList(tok.lineno, tok.colno);
    var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
    var checkComma = false;

    while (1) {
      // eslint-disable-line no-constant-condition
      tok = this.peekToken();

      if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
        this.nextToken();
        break;
      } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
        break;
      }

      if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseSignature: expected comma after expression', tok.lineno, tok.colno);
      } else {
        var arg = this.parseExpression();

        if (this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
          kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
        } else {
          args.addChild(arg);
        }
      }

      checkComma = true;
    }

    if (kwargs.children.length) {
      args.addChild(kwargs);
    }

    return args;
  };

  _proto.parseUntilBlocks = function parseUntilBlocks() {
    var prev = this.breakOnBlocks;

    for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
      blockNames[_key] = arguments[_key];
    }

    this.breakOnBlocks = blockNames;
    var ret = this.parse();
    this.breakOnBlocks = prev;
    return ret;
  };

  _proto.parseNodes = function parseNodes() {
    var tok;
    var buf = [];

    while (tok = this.nextToken()) {
      if (tok.type === lexer.TOKEN_DATA) {
        var data = tok.value;
        var nextToken = this.peekToken();
        var nextVal = nextToken && nextToken.value; // If the last token has "-" we need to trim the
        // leading whitespace of the data. This is marked with
        // the `dropLeadingWhitespace` variable.

        if (this.dropLeadingWhitespace) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/^\s*/, '');
          this.dropLeadingWhitespace = false;
        } // Same for the succeeding block start token


        if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === '-' || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === '-' || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === '-')) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/\s*$/, '');
        }

        buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
      } else if (tok.type === lexer.TOKEN_BLOCK_START) {
        this.dropLeadingWhitespace = false;
        var n = this.parseStatement();

        if (!n) {
          break;
        }

        buf.push(n);
      } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
        var e = this.parseExpression();
        this.dropLeadingWhitespace = false;
        this.advanceAfterVariableEnd();
        buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
      } else if (tok.type === lexer.TOKEN_COMMENT) {
        this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === '-';
      } else {
        // Ignore comments, otherwise this should be an error
        this.fail('Unexpected token at top-level: ' + tok.type, tok.lineno, tok.colno);
      }
    }

    return buf;
  };

  _proto.parse = function parse() {
    return new nodes.NodeList(0, 0, this.parseNodes());
  };

  _proto.parseAsRoot = function parseAsRoot() {
    return new nodes.Root(0, 0, this.parseNodes());
  };

  return Parser;
}(Obj); // var util = require('util');
// var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
// var t;
// while((t = l.nextToken())) {
//     console.log(util.inspect(t));
// }
// var p = new Parser(lexer.lex('hello {% filter title %}' +
//                              'Hello madam how are you' +
//                              '{% endfilter %}'));
// var n = p.parseAsRoot();
// nodes.printNodes(n);


module.exports = {
  parse: function parse(src, extensions, opts) {
    var p = new Parser(lexer.lex(src, opts));

    if (extensions !== undefined) {
      p.extensions = extensions;
    }

    return p.parseAsRoot();
  },
  Parser: Parser
};
        },
        map: {"./lexer":207,"./nodes":209,"./object":291,"./lib":200}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/lexer.js
      207: {
        factory: (module, exports, require) => {
          'use strict';

var lib = require('./lib');

var whitespaceChars = " \n\t\r\xA0";
var delimChars = '()[]{}%*-+~/#,:|.<>=!';
var intChars = '0123456789';
var BLOCK_START = '{%';
var BLOCK_END = '%}';
var VARIABLE_START = '{{';
var VARIABLE_END = '}}';
var COMMENT_START = '{#';
var COMMENT_END = '#}';
var TOKEN_STRING = 'string';
var TOKEN_WHITESPACE = 'whitespace';
var TOKEN_DATA = 'data';
var TOKEN_BLOCK_START = 'block-start';
var TOKEN_BLOCK_END = 'block-end';
var TOKEN_VARIABLE_START = 'variable-start';
var TOKEN_VARIABLE_END = 'variable-end';
var TOKEN_COMMENT = 'comment';
var TOKEN_LEFT_PAREN = 'left-paren';
var TOKEN_RIGHT_PAREN = 'right-paren';
var TOKEN_LEFT_BRACKET = 'left-bracket';
var TOKEN_RIGHT_BRACKET = 'right-bracket';
var TOKEN_LEFT_CURLY = 'left-curly';
var TOKEN_RIGHT_CURLY = 'right-curly';
var TOKEN_OPERATOR = 'operator';
var TOKEN_COMMA = 'comma';
var TOKEN_COLON = 'colon';
var TOKEN_TILDE = 'tilde';
var TOKEN_PIPE = 'pipe';
var TOKEN_INT = 'int';
var TOKEN_FLOAT = 'float';
var TOKEN_BOOLEAN = 'boolean';
var TOKEN_NONE = 'none';
var TOKEN_SYMBOL = 'symbol';
var TOKEN_SPECIAL = 'special';
var TOKEN_REGEX = 'regex';

function token(type, value, lineno, colno) {
  return {
    type: type,
    value: value,
    lineno: lineno,
    colno: colno
  };
}

var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(str, opts) {
    this.str = str;
    this.index = 0;
    this.len = str.length;
    this.lineno = 0;
    this.colno = 0;
    this.in_code = false;
    opts = opts || {};
    var tags = opts.tags || {};
    this.tags = {
      BLOCK_START: tags.blockStart || BLOCK_START,
      BLOCK_END: tags.blockEnd || BLOCK_END,
      VARIABLE_START: tags.variableStart || VARIABLE_START,
      VARIABLE_END: tags.variableEnd || VARIABLE_END,
      COMMENT_START: tags.commentStart || COMMENT_START,
      COMMENT_END: tags.commentEnd || COMMENT_END
    };
    this.trimBlocks = !!opts.trimBlocks;
    this.lstripBlocks = !!opts.lstripBlocks;
  }

  var _proto = Tokenizer.prototype;

  _proto.nextToken = function nextToken() {
    var lineno = this.lineno;
    var colno = this.colno;
    var tok;

    if (this.in_code) {
      // Otherwise, if we are in a block parse it as code
      var cur = this.current();

      if (this.isFinished()) {
        // We have nothing else to parse
        return null;
      } else if (cur === '"' || cur === '\'') {
        // We've hit a string
        return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
      } else if (tok = this._extract(whitespaceChars)) {
        // We hit some whitespace
        return token(TOKEN_WHITESPACE, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString('-' + this.tags.BLOCK_END))) {
        // Special check for the block end tag
        //
        // It is a requirement that start and end tags are composed of
        // delimiter characters (%{}[] etc), and our code always
        // breaks on delimiters so we can assume the token parsing
        // doesn't consume these elsewhere
        this.in_code = false;

        if (this.trimBlocks) {
          cur = this.current();

          if (cur === '\n') {
            // Skip newline
            this.forward();
          } else if (cur === '\r') {
            // Skip CRLF newline
            this.forward();
            cur = this.current();

            if (cur === '\n') {
              this.forward();
            } else {
              // Was not a CRLF, so go back
              this.back();
            }
          }
        }

        return token(TOKEN_BLOCK_END, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString('-' + this.tags.VARIABLE_END))) {
        // Special check for variable end tag (see above)
        this.in_code = false;
        return token(TOKEN_VARIABLE_END, tok, lineno, colno);
      } else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
        // Skip past 'r/'.
        this.forwardN(2); // Extract until the end of the regex -- / ends it, \/ does not.

        var regexBody = '';

        while (!this.isFinished()) {
          if (this.current() === '/' && this.previous() !== '\\') {
            this.forward();
            break;
          } else {
            regexBody += this.current();
            this.forward();
          }
        } // Check for flags.
        // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)


        var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
        var regexFlags = '';

        while (!this.isFinished()) {
          var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;

          if (isCurrentAFlag) {
            regexFlags += this.current();
            this.forward();
          } else {
            break;
          }
        }

        return token(TOKEN_REGEX, {
          body: regexBody,
          flags: regexFlags
        }, lineno, colno);
      } else if (delimChars.indexOf(cur) !== -1) {
        // We've hit a delimiter (a special char like a bracket)
        this.forward();
        var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
        var curComplex = cur + this.current();
        var type;

        if (lib.indexOf(complexOps, curComplex) !== -1) {
          this.forward();
          cur = curComplex; // See if this is a strict equality/inequality comparator

          if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
            cur = curComplex + this.current();
            this.forward();
          }
        }

        switch (cur) {
          case '(':
            type = TOKEN_LEFT_PAREN;
            break;

          case ')':
            type = TOKEN_RIGHT_PAREN;
            break;

          case '[':
            type = TOKEN_LEFT_BRACKET;
            break;

          case ']':
            type = TOKEN_RIGHT_BRACKET;
            break;

          case '{':
            type = TOKEN_LEFT_CURLY;
            break;

          case '}':
            type = TOKEN_RIGHT_CURLY;
            break;

          case ',':
            type = TOKEN_COMMA;
            break;

          case ':':
            type = TOKEN_COLON;
            break;

          case '~':
            type = TOKEN_TILDE;
            break;

          case '|':
            type = TOKEN_PIPE;
            break;

          default:
            type = TOKEN_OPERATOR;
        }

        return token(type, cur, lineno, colno);
      } else {
        // We are not at whitespace or a delimiter, so extract the
        // text and parse it
        tok = this._extractUntil(whitespaceChars + delimChars);

        if (tok.match(/^[-+]?[0-9]+$/)) {
          if (this.current() === '.') {
            this.forward();

            var dec = this._extract(intChars);

            return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
          } else {
            return token(TOKEN_INT, tok, lineno, colno);
          }
        } else if (tok.match(/^(true|false)$/)) {
          return token(TOKEN_BOOLEAN, tok, lineno, colno);
        } else if (tok === 'none') {
          return token(TOKEN_NONE, tok, lineno, colno);
          /*
           * Added to make the test `null is null` evaluate truthily.
           * Otherwise, Nunjucks will look up null in the context and
           * return `undefined`, which is not what we want. This *may* have
           * consequences is someone is using null in their templates as a
           * variable.
           */
        } else if (tok === 'null') {
          return token(TOKEN_NONE, tok, lineno, colno);
        } else if (tok) {
          return token(TOKEN_SYMBOL, tok, lineno, colno);
        } else {
          throw new Error('Unexpected value while parsing: ' + tok);
        }
      }
    } else {
      // Parse out the template text, breaking on tag
      // delimiters because we need to look for block/variable start
      // tags (don't use the full delimChars for optimization)
      var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);

      if (this.isFinished()) {
        return null;
      } else if ((tok = this._extractString(this.tags.BLOCK_START + '-')) || (tok = this._extractString(this.tags.BLOCK_START))) {
        this.in_code = true;
        return token(TOKEN_BLOCK_START, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_START + '-')) || (tok = this._extractString(this.tags.VARIABLE_START))) {
        this.in_code = true;
        return token(TOKEN_VARIABLE_START, tok, lineno, colno);
      } else {
        tok = '';
        var data;
        var inComment = false;

        if (this._matches(this.tags.COMMENT_START)) {
          inComment = true;
          tok = this._extractString(this.tags.COMMENT_START);
        } // Continually consume text, breaking on the tag delimiter
        // characters and checking to see if it's a start tag.
        //
        // We could hit the end of the template in the middle of
        // our looping, so check for the null return value from
        // _extractUntil


        while ((data = this._extractUntil(beginChars)) !== null) {
          tok += data;

          if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
            if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
              var lastLine = tok.slice(-this.colno);

              if (/^\s+$/.test(lastLine)) {
                // Remove block leading whitespace from beginning of the string
                tok = tok.slice(0, -this.colno);

                if (!tok.length) {
                  // All data removed, collapse to avoid unnecessary nodes
                  // by returning next token (block start)
                  return this.nextToken();
                }
              }
            } // If it is a start tag, stop looping


            break;
          } else if (this._matches(this.tags.COMMENT_END)) {
            if (!inComment) {
              throw new Error('unexpected end of comment');
            }

            tok += this._extractString(this.tags.COMMENT_END);
            break;
          } else {
            // It does not match any tag, so add the character and
            // carry on
            tok += this.current();
            this.forward();
          }
        }

        if (data === null && inComment) {
          throw new Error('expected end of comment, got end of file');
        }

        return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
      }
    }
  };

  _proto._parseString = function _parseString(delimiter) {
    this.forward();
    var str = '';

    while (!this.isFinished() && this.current() !== delimiter) {
      var cur = this.current();

      if (cur === '\\') {
        this.forward();

        switch (this.current()) {
          case 'n':
            str += '\n';
            break;

          case 't':
            str += '\t';
            break;

          case 'r':
            str += '\r';
            break;

          default:
            str += this.current();
        }

        this.forward();
      } else {
        str += cur;
        this.forward();
      }
    }

    this.forward();
    return str;
  };

  _proto._matches = function _matches(str) {
    if (this.index + str.length > this.len) {
      return null;
    }

    var m = this.str.slice(this.index, this.index + str.length);
    return m === str;
  };

  _proto._extractString = function _extractString(str) {
    if (this._matches(str)) {
      this.forwardN(str.length);
      return str;
    }

    return null;
  };

  _proto._extractUntil = function _extractUntil(charString) {
    // Extract all non-matching chars, with the default matching set
    // to everything
    return this._extractMatching(true, charString || '');
  };

  _proto._extract = function _extract(charString) {
    // Extract all matching chars (no default, so charString must be
    // explicit)
    return this._extractMatching(false, charString);
  };

  _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
    // Pull out characters until a breaking char is hit.
    // If breakOnMatch is false, a non-matching char stops it.
    // If breakOnMatch is true, a matching char stops it.
    if (this.isFinished()) {
      return null;
    }

    var first = charString.indexOf(this.current()); // Only proceed if the first character doesn't meet our condition

    if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
      var t = this.current();
      this.forward(); // And pull out all the chars one at a time until we hit a
      // breaking char

      var idx = charString.indexOf(this.current());

      while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
        t += this.current();
        this.forward();
        idx = charString.indexOf(this.current());
      }

      return t;
    }

    return '';
  };

  _proto._extractRegex = function _extractRegex(regex) {
    var matches = this.currentStr().match(regex);

    if (!matches) {
      return null;
    } // Move forward whatever was matched


    this.forwardN(matches[0].length);
    return matches;
  };

  _proto.isFinished = function isFinished() {
    return this.index >= this.len;
  };

  _proto.forwardN = function forwardN(n) {
    for (var i = 0; i < n; i++) {
      this.forward();
    }
  };

  _proto.forward = function forward() {
    this.index++;

    if (this.previous() === '\n') {
      this.lineno++;
      this.colno = 0;
    } else {
      this.colno++;
    }
  };

  _proto.backN = function backN(n) {
    for (var i = 0; i < n; i++) {
      this.back();
    }
  };

  _proto.back = function back() {
    this.index--;

    if (this.current() === '\n') {
      this.lineno--;
      var idx = this.src.lastIndexOf('\n', this.index - 1);

      if (idx === -1) {
        this.colno = this.index;
      } else {
        this.colno = this.index - idx;
      }
    } else {
      this.colno--;
    }
  } // current returns current character
  ;

  _proto.current = function current() {
    if (!this.isFinished()) {
      return this.str.charAt(this.index);
    }

    return '';
  } // currentStr returns what's left of the unparsed string
  ;

  _proto.currentStr = function currentStr() {
    if (!this.isFinished()) {
      return this.str.substr(this.index);
    }

    return '';
  };

  _proto.previous = function previous() {
    return this.str.charAt(this.index - 1);
  };

  return Tokenizer;
}();

module.exports = {
  lex: function lex(src, opts) {
    return new Tokenizer(src, opts);
  },
  TOKEN_STRING: TOKEN_STRING,
  TOKEN_WHITESPACE: TOKEN_WHITESPACE,
  TOKEN_DATA: TOKEN_DATA,
  TOKEN_BLOCK_START: TOKEN_BLOCK_START,
  TOKEN_BLOCK_END: TOKEN_BLOCK_END,
  TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
  TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
  TOKEN_COMMENT: TOKEN_COMMENT,
  TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
  TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
  TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
  TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
  TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
  TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
  TOKEN_OPERATOR: TOKEN_OPERATOR,
  TOKEN_COMMA: TOKEN_COMMA,
  TOKEN_COLON: TOKEN_COLON,
  TOKEN_TILDE: TOKEN_TILDE,
  TOKEN_PIPE: TOKEN_PIPE,
  TOKEN_INT: TOKEN_INT,
  TOKEN_FLOAT: TOKEN_FLOAT,
  TOKEN_BOOLEAN: TOKEN_BOOLEAN,
  TOKEN_NONE: TOKEN_NONE,
  TOKEN_SYMBOL: TOKEN_SYMBOL,
  TOKEN_SPECIAL: TOKEN_SPECIAL,
  TOKEN_REGEX: TOKEN_REGEX
};
        },
        map: {"./lib":200}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/runtime.js
      208: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var lib = require('./lib');

var arrayFrom = Array.from;
var supportsIterators = typeof Symbol === 'function' && Symbol.iterator && typeof arrayFrom === 'function'; // Frames keep track of scoping both at compile-time and run-time so
// we know how to access variables. Block tags can introduce special
// variables, for example.

var Frame = /*#__PURE__*/function () {
  function Frame(parent, isolateWrites) {
    this.variables = Object.create(null);
    this.parent = parent;
    this.topLevel = false; // if this is true, writes (set) should never propagate upwards past
    // this frame to its parent (though reads may).

    this.isolateWrites = isolateWrites;
  }

  var _proto = Frame.prototype;

  _proto.set = function set(name, val, resolveUp) {
    // Allow variables with dots by automatically creating the
    // nested structure
    var parts = name.split('.');
    var obj = this.variables;
    var frame = this;

    if (resolveUp) {
      if (frame = this.resolve(parts[0], true)) {
        frame.set(name, val);
        return;
      }
    }

    for (var i = 0; i < parts.length - 1; i++) {
      var id = parts[i];

      if (!obj[id]) {
        obj[id] = {};
      }

      obj = obj[id];
    }

    obj[parts[parts.length - 1]] = val;
  };

  _proto.get = function get(name) {
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return null;
  };

  _proto.lookup = function lookup(name) {
    var p = this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return p && p.lookup(name);
  };

  _proto.resolve = function resolve(name, forWrite) {
    var p = forWrite && this.isolateWrites ? undefined : this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return this;
    }

    return p && p.resolve(name);
  };

  _proto.push = function push(isolateWrites) {
    return new Frame(this, isolateWrites);
  };

  _proto.pop = function pop() {
    return this.parent;
  };

  return Frame;
}();

function makeMacro(argNames, kwargNames, func) {
  return function macro() {
    for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      macroArgs[_key] = arguments[_key];
    }

    var argCount = numArgs(macroArgs);
    var args;
    var kwargs = getKeywordArgs(macroArgs);

    if (argCount > argNames.length) {
      args = macroArgs.slice(0, argNames.length); // Positional arguments that should be passed in as
      // keyword arguments (essentially default values)

      macroArgs.slice(args.length, argCount).forEach(function (val, i) {
        if (i < kwargNames.length) {
          kwargs[kwargNames[i]] = val;
        }
      });
      args.push(kwargs);
    } else if (argCount < argNames.length) {
      args = macroArgs.slice(0, argCount);

      for (var i = argCount; i < argNames.length; i++) {
        var arg = argNames[i]; // Keyword arguments that should be passed as
        // positional arguments, i.e. the caller explicitly
        // used the name of a positional arg

        args.push(kwargs[arg]);
        delete kwargs[arg];
      }

      args.push(kwargs);
    } else {
      args = macroArgs;
    }

    return func.apply(this, args);
  };
}

function makeKeywordArgs(obj) {
  obj.__keywords = true;
  return obj;
}

function isKeywordArgs(obj) {
  return obj && Object.prototype.hasOwnProperty.call(obj, '__keywords');
}

function getKeywordArgs(args) {
  var len = args.length;

  if (len) {
    var lastArg = args[len - 1];

    if (isKeywordArgs(lastArg)) {
      return lastArg;
    }
  }

  return {};
}

function numArgs(args) {
  var len = args.length;

  if (len === 0) {
    return 0;
  }

  var lastArg = args[len - 1];

  if (isKeywordArgs(lastArg)) {
    return len - 1;
  } else {
    return len;
  }
} // A SafeString object indicates that the string should not be
// autoescaped. This happens magically because autoescaping only
// occurs on primitive string objects.


function SafeString(val) {
  if (typeof val !== 'string') {
    return val;
  }

  this.val = val;
  this.length = val.length;
}

SafeString.prototype = Object.create(String.prototype, {
  length: {
    writable: true,
    configurable: true,
    value: 0
  }
});

SafeString.prototype.valueOf = function valueOf() {
  return this.val;
};

SafeString.prototype.toString = function toString() {
  return this.val;
};

function copySafeness(dest, target) {
  if (dest instanceof SafeString) {
    return new SafeString(target);
  }

  return target.toString();
}

function markSafe(val) {
  var type = _typeof(val);

  if (type === 'string') {
    return new SafeString(val);
  } else if (type !== 'function') {
    return val;
  } else {
    return function wrapSafe(args) {
      var ret = val.apply(this, arguments);

      if (typeof ret === 'string') {
        return new SafeString(ret);
      }

      return ret;
    };
  }
}

function suppressValue(val, autoescape) {
  val = val !== undefined && val !== null ? val : '';

  if (autoescape && !(val instanceof SafeString)) {
    val = lib.escape(val.toString());
  }

  return val;
}

function ensureDefined(val, lineno, colno) {
  if (val === null || val === undefined) {
    throw new lib.TemplateError('attempted to output null or undefined value', lineno + 1, colno + 1);
  }

  return val;
}

function memberLookup(obj, val) {
  if (obj === undefined || obj === null) {
    return undefined;
  }

  if (typeof obj[val] === 'function') {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return obj[val].apply(obj, args);
    };
  }

  return obj[val];
}

function callWrap(obj, name, context, args) {
  if (!obj) {
    throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
  } else if (typeof obj !== 'function') {
    throw new Error('Unable to call `' + name + '`, which is not a function');
  }

  return obj.apply(context, args);
}

function contextOrFrameLookup(context, frame, name) {
  var val = frame.lookup(name);
  return val !== undefined ? val : context.lookup(name);
}

function handleError(error, lineno, colno) {
  if (error.lineno) {
    return error;
  } else {
    return new lib.TemplateError(error, lineno, colno);
  }
}

function asyncEach(arr, dimen, iter, cb) {
  if (lib.isArray(arr)) {
    var len = arr.length;
    lib.asyncIter(arr, function iterCallback(item, i, next) {
      switch (dimen) {
        case 1:
          iter(item, i, len, next);
          break;

        case 2:
          iter(item[0], item[1], i, len, next);
          break;

        case 3:
          iter(item[0], item[1], item[2], i, len, next);
          break;

        default:
          item.push(i, len, next);
          iter.apply(this, item);
      }
    }, cb);
  } else {
    lib.asyncFor(arr, function iterCallback(key, val, i, len, next) {
      iter(key, val, i, len, next);
    }, cb);
  }
}

function asyncAll(arr, dimen, func, cb) {
  var finished = 0;
  var len;
  var outputArr;

  function done(i, output) {
    finished++;
    outputArr[i] = output;

    if (finished === len) {
      cb(null, outputArr.join(''));
    }
  }

  if (lib.isArray(arr)) {
    len = arr.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        switch (dimen) {
          case 1:
            func(item, i, len, done);
            break;

          case 2:
            func(item[0], item[1], i, len, done);
            break;

          case 3:
            func(item[0], item[1], item[2], i, len, done);
            break;

          default:
            item.push(i, len, done);
            func.apply(this, item);
        }
      }
    }
  } else {
    var keys = lib.keys(arr || {});
    len = keys.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var _i = 0; _i < keys.length; _i++) {
        var k = keys[_i];
        func(k, arr[k], _i, len, done);
      }
    }
  }
}

function fromIterator(arr) {
  if (_typeof(arr) !== 'object' || arr === null || lib.isArray(arr)) {
    return arr;
  } else if (supportsIterators && Symbol.iterator in arr) {
    return arrayFrom(arr);
  } else {
    return arr;
  }
}

module.exports = {
  Frame: Frame,
  makeMacro: makeMacro,
  makeKeywordArgs: makeKeywordArgs,
  numArgs: numArgs,
  suppressValue: suppressValue,
  ensureDefined: ensureDefined,
  memberLookup: memberLookup,
  contextOrFrameLookup: contextOrFrameLookup,
  callWrap: callWrap,
  handleError: handleError,
  isArray: lib.isArray,
  keys: lib.keys,
  SafeString: SafeString,
  copySafeness: copySafeness,
  markSafe: markSafe,
  asyncEach: asyncEach,
  asyncAll: asyncAll,
  inOperator: lib.inOperator,
  fromIterator: fromIterator
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"./lib":200}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/nodes.js
      209: {
        factory: (module, exports, require) => {
          'use strict';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var _require = require('./object'),
    Obj = _require.Obj;

function traverseAndCheck(obj, type, results) {
  if (obj instanceof type) {
    results.push(obj);
  }

  if (obj instanceof Node) {
    obj.findAll(type, results);
  }
}

var Node = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Node, _Obj);

  function Node() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Node.prototype;

  _proto.init = function init(lineno, colno) {
    var _arguments = arguments,
        _this = this;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.lineno = lineno;
    this.colno = colno;
    this.fields.forEach(function (field, i) {
      // The first two args are line/col numbers, so offset by 2
      var val = _arguments[i + 2]; // Fields should never be undefined, but null. It makes
      // testing easier to normalize values.

      if (val === undefined) {
        val = null;
      }

      _this[field] = val;
    });
  };

  _proto.findAll = function findAll(type, results) {
    var _this2 = this;

    results = results || [];

    if (this instanceof NodeList) {
      this.children.forEach(function (child) {
        return traverseAndCheck(child, type, results);
      });
    } else {
      this.fields.forEach(function (field) {
        return traverseAndCheck(_this2[field], type, results);
      });
    }

    return results;
  };

  _proto.iterFields = function iterFields(func) {
    var _this3 = this;

    this.fields.forEach(function (field) {
      func(_this3[field], field);
    });
  };

  return Node;
}(Obj); // Abstract nodes


var Value = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Value, _Node);

  function Value() {
    return _Node.apply(this, arguments) || this;
  }

  _createClass(Value, [{
    key: "typename",
    get: function get() {
      return 'Value';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['value'];
    }
  }]);

  return Value;
}(Node); // Concrete nodes


var NodeList = /*#__PURE__*/function (_Node2) {
  _inheritsLoose(NodeList, _Node2);

  function NodeList() {
    return _Node2.apply(this, arguments) || this;
  }

  var _proto2 = NodeList.prototype;

  _proto2.init = function init(lineno, colno, nodes) {
    _Node2.prototype.init.call(this, lineno, colno, nodes || []);
  };

  _proto2.addChild = function addChild(node) {
    this.children.push(node);
  };

  _createClass(NodeList, [{
    key: "typename",
    get: function get() {
      return 'NodeList';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['children'];
    }
  }]);

  return NodeList;
}(Node);

var Root = NodeList.extend('Root');
var Literal = Value.extend('Literal');

var _Symbol = Value.extend('Symbol');

var Group = NodeList.extend('Group');
var ArrayNode = NodeList.extend('Array');
var Pair = Node.extend('Pair', {
  fields: ['key', 'value']
});
var Dict = NodeList.extend('Dict');
var LookupVal = Node.extend('LookupVal', {
  fields: ['target', 'val']
});
var If = Node.extend('If', {
  fields: ['cond', 'body', 'else_']
});
var IfAsync = If.extend('IfAsync');
var InlineIf = Node.extend('InlineIf', {
  fields: ['cond', 'body', 'else_']
});
var For = Node.extend('For', {
  fields: ['arr', 'name', 'body', 'else_']
});
var AsyncEach = For.extend('AsyncEach');
var AsyncAll = For.extend('AsyncAll');
var Macro = Node.extend('Macro', {
  fields: ['name', 'args', 'body']
});
var Caller = Macro.extend('Caller');
var Import = Node.extend('Import', {
  fields: ['template', 'target', 'withContext']
});

var FromImport = /*#__PURE__*/function (_Node3) {
  _inheritsLoose(FromImport, _Node3);

  function FromImport() {
    return _Node3.apply(this, arguments) || this;
  }

  var _proto3 = FromImport.prototype;

  _proto3.init = function init(lineno, colno, template, names, withContext) {
    _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
  };

  _createClass(FromImport, [{
    key: "typename",
    get: function get() {
      return 'FromImport';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['template', 'names', 'withContext'];
    }
  }]);

  return FromImport;
}(Node);

var FunCall = Node.extend('FunCall', {
  fields: ['name', 'args']
});
var Filter = FunCall.extend('Filter');
var FilterAsync = Filter.extend('FilterAsync', {
  fields: ['name', 'args', 'symbol']
});
var KeywordArgs = Dict.extend('KeywordArgs');
var Block = Node.extend('Block', {
  fields: ['name', 'body']
});
var Super = Node.extend('Super', {
  fields: ['blockName', 'symbol']
});
var TemplateRef = Node.extend('TemplateRef', {
  fields: ['template']
});
var Extends = TemplateRef.extend('Extends');
var Include = Node.extend('Include', {
  fields: ['template', 'ignoreMissing']
});
var Set = Node.extend('Set', {
  fields: ['targets', 'value']
});
var Switch = Node.extend('Switch', {
  fields: ['expr', 'cases', 'default']
});
var Case = Node.extend('Case', {
  fields: ['cond', 'body']
});
var Output = NodeList.extend('Output');
var Capture = Node.extend('Capture', {
  fields: ['body']
});
var TemplateData = Literal.extend('TemplateData');
var UnaryOp = Node.extend('UnaryOp', {
  fields: ['target']
});
var BinOp = Node.extend('BinOp', {
  fields: ['left', 'right']
});
var In = BinOp.extend('In');
var Is = BinOp.extend('Is');
var Or = BinOp.extend('Or');
var And = BinOp.extend('And');
var Not = UnaryOp.extend('Not');
var Add = BinOp.extend('Add');
var Concat = BinOp.extend('Concat');
var Sub = BinOp.extend('Sub');
var Mul = BinOp.extend('Mul');
var Div = BinOp.extend('Div');
var FloorDiv = BinOp.extend('FloorDiv');
var Mod = BinOp.extend('Mod');
var Pow = BinOp.extend('Pow');
var Neg = UnaryOp.extend('Neg');
var Pos = UnaryOp.extend('Pos');
var Compare = Node.extend('Compare', {
  fields: ['expr', 'ops']
});
var CompareOperand = Node.extend('CompareOperand', {
  fields: ['expr', 'type']
});
var CallExtension = Node.extend('CallExtension', {
  init: function init(ext, prop, args, contentArgs) {
    this.parent();
    this.extName = ext.__name || ext;
    this.prop = prop;
    this.args = args || new NodeList();
    this.contentArgs = contentArgs || [];
    this.autoescape = ext.autoescape;
  },
  fields: ['extName', 'prop', 'args', 'contentArgs']
});
var CallExtensionAsync = CallExtension.extend('CallExtensionAsync'); // This is hacky, but this is just a debugging function anyway

function print(str, indent, inline) {
  var lines = str.split('\n');
  lines.forEach(function (line, i) {
    if (line && (inline && i > 0 || !inline)) {
      process.stdout.write(' '.repeat(indent));
    }

    var nl = i === lines.length - 1 ? '' : '\n';
    process.stdout.write("" + line + nl);
  });
} // Print the AST in a nicely formatted tree format for debuggin


function printNodes(node, indent) {
  indent = indent || 0;
  print(node.typename + ': ', indent);

  if (node instanceof NodeList) {
    print('\n');
    node.children.forEach(function (n) {
      printNodes(n, indent + 2);
    });
  } else if (node instanceof CallExtension) {
    print(node.extName + "." + node.prop + "\n");

    if (node.args) {
      printNodes(node.args, indent + 2);
    }

    if (node.contentArgs) {
      node.contentArgs.forEach(function (n) {
        printNodes(n, indent + 2);
      });
    }
  } else {
    var nodes = [];
    var props = null;
    node.iterFields(function (val, fieldName) {
      if (val instanceof Node) {
        nodes.push([fieldName, val]);
      } else {
        props = props || {};
        props[fieldName] = val;
      }
    });

    if (props) {
      print(JSON.stringify(props, null, 2) + '\n', null, true);
    } else {
      print('\n');
    }

    nodes.forEach(function (_ref) {
      var fieldName = _ref[0],
          n = _ref[1];
      print("[" + fieldName + "] =>", indent + 2);
      printNodes(n, indent + 4);
    });
  }
}

module.exports = {
  Node: Node,
  Root: Root,
  NodeList: NodeList,
  Value: Value,
  Literal: Literal,
  Symbol: _Symbol,
  Group: Group,
  Array: ArrayNode,
  Pair: Pair,
  Dict: Dict,
  Output: Output,
  Capture: Capture,
  TemplateData: TemplateData,
  If: If,
  IfAsync: IfAsync,
  InlineIf: InlineIf,
  For: For,
  AsyncEach: AsyncEach,
  AsyncAll: AsyncAll,
  Macro: Macro,
  Caller: Caller,
  Import: Import,
  FromImport: FromImport,
  FunCall: FunCall,
  Filter: Filter,
  FilterAsync: FilterAsync,
  KeywordArgs: KeywordArgs,
  Block: Block,
  Super: Super,
  Extends: Extends,
  Include: Include,
  Set: Set,
  Switch: Switch,
  Case: Case,
  LookupVal: LookupVal,
  BinOp: BinOp,
  In: In,
  Is: Is,
  Or: Or,
  And: And,
  Not: Not,
  Add: Add,
  Concat: Concat,
  Sub: Sub,
  Mul: Mul,
  Div: Div,
  FloorDiv: FloorDiv,
  Mod: Mod,
  Pow: Pow,
  Neg: Neg,
  Pos: Pos,
  Compare: Compare,
  CompareOperand: CompareOperand,
  CallExtension: CallExtension,
  CallExtensionAsync: CallExtensionAsync,
  printNodes: printNodes
};
        },
        map: {"./object":291}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/jinja-compat.js
      210: {
        factory: (module, exports, require) => {
          "use strict";

function installCompat() {
  'use strict';
  /* eslint-disable camelcase */
  // This must be called like `nunjucks.installCompat` so that `this`
  // references the nunjucks instance

  var runtime = this.runtime;
  var lib = this.lib; // Handle slim case where these 'modules' are excluded from the built source

  var Compiler = this.compiler.Compiler;
  var Parser = this.parser.Parser;
  var nodes = this.nodes;
  var lexer = this.lexer;
  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
  var orig_memberLookup = runtime.memberLookup;
  var orig_Compiler_assertType;
  var orig_Parser_parseAggregate;

  if (Compiler) {
    orig_Compiler_assertType = Compiler.prototype.assertType;
  }

  if (Parser) {
    orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
  }

  function uninstall() {
    runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
    runtime.memberLookup = orig_memberLookup;

    if (Compiler) {
      Compiler.prototype.assertType = orig_Compiler_assertType;
    }

    if (Parser) {
      Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
    }
  }

  runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
    var val = orig_contextOrFrameLookup.apply(this, arguments);

    if (val !== undefined) {
      return val;
    }

    switch (key) {
      case 'True':
        return true;

      case 'False':
        return false;

      case 'None':
        return null;

      default:
        return undefined;
    }
  };

  function getTokensState(tokens) {
    return {
      index: tokens.index,
      lineno: tokens.lineno,
      colno: tokens.colno
    };
  }

  if (process.env.BUILD_TYPE !== 'SLIM' && nodes && Compiler && Parser) {
    // i.e., not slim mode
    var Slice = nodes.Node.extend('Slice', {
      fields: ['start', 'stop', 'step'],
      init: function init(lineno, colno, start, stop, step) {
        start = start || new nodes.Literal(lineno, colno, null);
        stop = stop || new nodes.Literal(lineno, colno, null);
        step = step || new nodes.Literal(lineno, colno, 1);
        this.parent(lineno, colno, start, stop, step);
      }
    });

    Compiler.prototype.assertType = function assertType(node) {
      if (node instanceof Slice) {
        return;
      }

      orig_Compiler_assertType.apply(this, arguments);
    };

    Compiler.prototype.compileSlice = function compileSlice(node, frame) {
      this._emit('(');

      this._compileExpression(node.start, frame);

      this._emit('),(');

      this._compileExpression(node.stop, frame);

      this._emit('),(');

      this._compileExpression(node.step, frame);

      this._emit(')');
    };

    Parser.prototype.parseAggregate = function parseAggregate() {
      var _this = this;

      var origState = getTokensState(this.tokens); // Set back one accounting for opening bracket/parens

      origState.colno--;
      origState.index--;

      try {
        return orig_Parser_parseAggregate.apply(this);
      } catch (e) {
        var errState = getTokensState(this.tokens);

        var rethrow = function rethrow() {
          lib._assign(_this.tokens, errState);

          return e;
        }; // Reset to state before original parseAggregate called


        lib._assign(this.tokens, origState);

        this.peeked = false;
        var tok = this.peekToken();

        if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
          throw rethrow();
        } else {
          this.nextToken();
        }

        var node = new Slice(tok.lineno, tok.colno); // If we don't encounter a colon while parsing, this is not a slice,
        // so re-raise the original exception.

        var isSlice = false;

        for (var i = 0; i <= node.fields.length; i++) {
          if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
            break;
          }

          if (i === node.fields.length) {
            if (isSlice) {
              this.fail('parseSlice: too many slice components', tok.lineno, tok.colno);
            } else {
              break;
            }
          }

          if (this.skip(lexer.TOKEN_COLON)) {
            isSlice = true;
          } else {
            var field = node.fields[i];
            node[field] = this.parseExpression();
            isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
          }
        }

        if (!isSlice) {
          throw rethrow();
        }

        return new nodes.Array(tok.lineno, tok.colno, [node]);
      }
    };
  }

  function sliceLookup(obj, start, stop, step) {
    obj = obj || [];

    if (start === null) {
      start = step < 0 ? obj.length - 1 : 0;
    }

    if (stop === null) {
      stop = step < 0 ? -1 : obj.length;
    } else if (stop < 0) {
      stop += obj.length;
    }

    if (start < 0) {
      start += obj.length;
    }

    var results = [];

    for (var i = start;; i += step) {
      if (i < 0 || i > obj.length) {
        break;
      }

      if (step > 0 && i >= stop) {
        break;
      }

      if (step < 0 && i <= stop) {
        break;
      }

      results.push(runtime.memberLookup(obj, i));
    }

    return results;
  }

  function hasOwnProp(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  var ARRAY_MEMBERS = {
    pop: function pop(index) {
      if (index === undefined) {
        return this.pop();
      }

      if (index >= this.length || index < 0) {
        throw new Error('KeyError');
      }

      return this.splice(index, 1);
    },
    append: function append(element) {
      return this.push(element);
    },
    remove: function remove(element) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          return this.splice(i, 1);
        }
      }

      throw new Error('ValueError');
    },
    count: function count(element) {
      var count = 0;

      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          count++;
        }
      }

      return count;
    },
    index: function index(element) {
      var i;

      if ((i = this.indexOf(element)) === -1) {
        throw new Error('ValueError');
      }

      return i;
    },
    find: function find(element) {
      return this.indexOf(element);
    },
    insert: function insert(index, elem) {
      return this.splice(index, 0, elem);
    }
  };
  var OBJECT_MEMBERS = {
    items: function items() {
      return lib._entries(this);
    },
    values: function values() {
      return lib._values(this);
    },
    keys: function keys() {
      return lib.keys(this);
    },
    get: function get(key, def) {
      var output = this[key];

      if (output === undefined) {
        output = def;
      }

      return output;
    },
    has_key: function has_key(key) {
      return hasOwnProp(this, key);
    },
    pop: function pop(key, def) {
      var output = this[key];

      if (output === undefined && def !== undefined) {
        output = def;
      } else if (output === undefined) {
        throw new Error('KeyError');
      } else {
        delete this[key];
      }

      return output;
    },
    popitem: function popitem() {
      var keys = lib.keys(this);

      if (!keys.length) {
        throw new Error('KeyError');
      }

      var k = keys[0];
      var val = this[k];
      delete this[k];
      return [k, val];
    },
    setdefault: function setdefault(key, def) {
      if (def === void 0) {
        def = null;
      }

      if (!(key in this)) {
        this[key] = def;
      }

      return this[key];
    },
    update: function update(kwargs) {
      lib._assign(this, kwargs);

      return null; // Always returns None
    }
  };
  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;

  runtime.memberLookup = function memberLookup(obj, val, autoescape) {
    if (arguments.length === 4) {
      return sliceLookup.apply(this, arguments);
    }

    obj = obj || {}; // If the object is an object, return any of the methods that Python would
    // otherwise provide.

    if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
      return ARRAY_MEMBERS[val].bind(obj);
    }

    if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
      return OBJECT_MEMBERS[val].bind(obj);
    }

    return orig_memberLookup.apply(this, arguments);
  };

  return uninstall;
}

module.exports = installCompat;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/strict-uri-encode/index.js
      211: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (x) {
    return "%".concat(x.charCodeAt(0).toString(16).toUpperCase());
  });
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/decode-uri-component/index.js
      212: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
  try {
    // Try to decode the entire string first
    return decodeURIComponent(components.join(''));
  } catch (err) {// Do nothing
  }

  if (components.length === 1) {
    return components;
  }

  split = split || 1; // Split the array in 2 parts

  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher);

    for (var i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join('');
      tokens = input.match(singleMatcher);
    }

    return input;
  }
}

function customDecodeURIComponent(input) {
  // Keep track of all the replacements and prefill the map with the `BOM`
  var replaceMap = {
    '%FE%FF': "\uFFFD\uFFFD",
    '%FF%FE': "\uFFFD\uFFFD"
  };
  var match = multiMatcher.exec(input);

  while (match) {
    try {
      // Decode as big chunks as possible
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode(match[0]);

      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }

    match = multiMatcher.exec(input);
  } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else


  replaceMap['%C2'] = "\uFFFD";
  var entries = Object.keys(replaceMap);

  for (var i = 0; i < entries.length; i++) {
    // Replace all decoded components
    var key = entries[i];
    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
  }

  return input;
}

module.exports = function (encodedURI) {
  if (typeof encodedURI !== 'string') {
    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + _typeof(encodedURI) + '`');
  }

  try {
    encodedURI = encodedURI.replace(/\+/g, ' '); // Try the built in decoder first

    return decodeURIComponent(encodedURI);
  } catch (err) {
    // Fallback to a more advanced decoder
    return customDecodeURIComponent(encodedURI);
  }
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/split-on-first/index.js
      213: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (string, separator) {
  if (!(typeof string === 'string' && typeof separator === 'string')) {
    throw new TypeError('Expected the arguments to be of type `string`');
  }

  if (separator === '') {
    return [string];
  }

  var separatorIndex = string.indexOf(separator);

  if (separatorIndex === -1) {
    return [string];
  }

  return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/filter-obj/index.js
      214: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];

    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret[key] = val;
    }
  }

  return ret;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/helpers/callBind.js
      215: {
        factory: (module, exports, require) => {
          'use strict'; // TODO; semver-major: remove

module.exports = require('call-bind');
        },
        map: {"call-bind":296}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/define-properties/index.js
      216: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var keys = require('object-keys');

var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol('foo')) === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function isFunction(fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported() {
  var obj = {};

  try {
    origDefineProperty(obj, 'x', {
      enumerable: false,
      value: obj
    }); // eslint-disable-next-line no-unused-vars, no-restricted-syntax

    for (var _ in obj) {
      // jscs:ignore disallowUnusedVariables
      return false;
    }

    return obj.x === obj;
  } catch (e) {
    /* this is IE 8. */
    return false;
  }
};

var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function defineProperty(object, name, value, predicate) {
  if (name in object && (!isFunction(predicate) || !predicate())) {
    return;
  }

  if (supportsDescriptors) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    });
  } else {
    object[name] = value;
  }
};

var defineProperties = function defineProperties(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);

  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }

  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};

defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;
        },
        map: {"@babel/runtime/helpers/typeof":12,"object-keys":297}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/string.prototype.startswith/implementation.js
      217: {
        factory: (module, exports, require) => {
          /*! https://mths.be/startswith v1.0.0 by @mathias */
'use strict';

var callBound = require('es-abstract/helpers/callBound');

var RequireObjectCoercible = require('es-abstract/2019/RequireObjectCoercible');

var ToString = require('es-abstract/2019/ToString');

var IsRegExp = require('es-abstract/2019/IsRegExp');

var ToInteger = require('es-abstract/2019/ToInteger');

var StringCharCodeAt = callBound('String.prototype.charCodeAt');
var max = Math.max;
var min = Math.min; // https://tc39.es/ecma262/#sec-string.prototype.startswith

module.exports = function startsWith(searchString) {
  var O = RequireObjectCoercible(this);
  var S = ToString(O);

  if (IsRegExp(searchString)) {
    throw TypeError('Argument to String.prototype.startsWith cannot be a RegExp');
  }

  var searchStr = ToString(searchString);
  var pos = ToInteger(arguments.length > 1 ? arguments[1] : undefined);
  var len = S.length;
  var start = min(max(pos, 0), len);
  var searchLength = searchStr.length; // Avoid the `indexOf` call if no match is possible

  if (searchLength + start > len) return false;
  var index = -1;

  while (++index < searchLength) {
    if (StringCharCodeAt(S, start + index) != StringCharCodeAt(searchStr, index)) {
      return false;
    }
  }

  return true;
};
        },
        map: {"es-abstract/helpers/callBound":298,"es-abstract/2019/RequireObjectCoercible":299,"es-abstract/2019/ToString":300,"es-abstract/2019/IsRegExp":301,"es-abstract/2019/ToInteger":302}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/string.prototype.startswith/polyfill.js
      218: {
        factory: (module, exports, require) => {
          /*! https://mths.be/startswith v1.0.0 by @mathias */
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
  return String.prototype.startsWith || implementation;
};
        },
        map: {"./implementation":217}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/string.prototype.startswith/shim.js
      219: {
        factory: (module, exports, require) => {
          /*! https://mths.be/startswith v1.0.0 by @mathias */
'use strict';

var define = require('define-properties');

var getPolyfill = require('./polyfill');

module.exports = function shimStartsWith() {
  var polyfill = getPolyfill();

  if (String.prototype.startsWith !== polyfill) {
    define(String.prototype, {
      startsWith: polyfill
    });
  }

  return polyfill;
};
        },
        map: {"define-properties":216,"./polyfill":218}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Parser.js
      220: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

// Generated by CoffeeScript 1.12.4
var Inline, ParseException, ParseMore, Parser, Pattern, Utils;
Inline = require('./Inline');
Pattern = require('./Pattern');
Utils = require('./Utils');
ParseException = require('./Exception/ParseException');
ParseMore = require('./Exception/ParseMore');

Parser = function () {
  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');
  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$');
  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$');
  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');
  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$');
  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \'"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$');
  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\d+');
  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');
  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\n*)$');
  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\%YAML[: ][\\d\\.]+.*\n', 'm');
  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\#.*?\n)+', 'm');
  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\-\\-\\-.*?\n', 'm');
  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\.\\.\\.\\s*$', 'm');
  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};
  Parser.prototype.CONTEXT_NONE = 0;
  Parser.prototype.CONTEXT_SEQUENCE = 1;
  Parser.prototype.CONTEXT_MAPPING = 2;

  function Parser(offset) {
    this.offset = offset != null ? offset : 0;
    this.lines = [];
    this.currentLineNb = -1;
    this.currentLine = '';
    this.refs = {};
  }

  Parser.prototype.parse = function (value, exceptionOnInvalidType, objectDecoder) {
    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;

    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }

    if (objectDecoder == null) {
      objectDecoder = null;
    }

    this.currentLineNb = -1;
    this.currentLine = '';
    this.lines = this.cleanup(value).split("\n");
    data = null;
    context = this.CONTEXT_NONE;
    allowOverwrite = false;

    while (this.moveToNextLine()) {
      if (this.isCurrentLineEmpty()) {
        continue;
      }

      if ("\t" === this.currentLine[0]) {
        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }

      isRef = mergeNode = false;

      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
        if (this.CONTEXT_MAPPING === context) {
          throw new ParseException('You cannot define a sequence item when in a mapping');
        }

        context = this.CONTEXT_SEQUENCE;

        if (data == null) {
          data = [];
        }

        if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }

        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(null);
          }
        } else {
          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
            c = this.getRealCurrentLineNb();
            parser = new Parser(c);
            parser.refs = this.refs;
            block = values.value;
            indent = this.getCurrentLineIndentation();

            if (this.isNextLineIndented(false)) {
              block += "\n" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
            }

            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
          } else {
            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
          }
        }
      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {
        if (this.CONTEXT_SEQUENCE === context) {
          throw new ParseException('You cannot define a mapping item when in a sequence');
        }

        context = this.CONTEXT_MAPPING;

        if (data == null) {
          data = {};
        }

        Inline.configure(exceptionOnInvalidType, objectDecoder);

        try {
          key = Inline.parseScalar(values.key);
        } catch (error) {
          e = error;
          e.parsedLine = this.getRealCurrentLineNb() + 1;
          e.snippet = this.currentLine;
          throw e;
        }

        if ('<<' === key) {
          mergeNode = true;
          allowOverwrite = true;

          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {
            refName = values.value.slice(1);

            if (this.refs[refName] == null) {
              throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }

            refValue = this.refs[refName];

            if (_typeof(refValue) !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }

            if (refValue instanceof Array) {
              for (i = j = 0, len = refValue.length; j < len; i = ++j) {
                value = refValue[i];

                if (data[name = String(i)] == null) {
                  data[name] = value;
                }
              }
            } else {
              for (key in refValue) {
                value = refValue[key];

                if (data[key] == null) {
                  data[key] = value;
                }
              }
            }
          } else {
            if (values.value != null && values.value !== '') {
              value = values.value;
            } else {
              value = this.getNextEmbedBlock();
            }

            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            parsed = parser.parse(value, exceptionOnInvalidType);

            if (_typeof(parsed) !== 'object') {
              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);
            }

            if (parsed instanceof Array) {
              for (l = 0, len1 = parsed.length; l < len1; l++) {
                parsedItem = parsed[l];

                if (_typeof(parsedItem) !== 'object') {
                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);
                }

                if (parsedItem instanceof Array) {
                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {
                    value = parsedItem[i];
                    k = String(i);

                    if (!data.hasOwnProperty(k)) {
                      data[k] = value;
                    }
                  }
                } else {
                  for (key in parsedItem) {
                    value = parsedItem[key];

                    if (!data.hasOwnProperty(key)) {
                      data[key] = value;
                    }
                  }
                }
              }
            } else {
              for (key in parsed) {
                value = parsed[key];

                if (!data.hasOwnProperty(key)) {
                  data[key] = value;
                }
              }
            }
          }
        } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
          isRef = matches.ref;
          values.value = matches.value;
        }

        if (mergeNode) {} else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {
          if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {
            if (allowOverwrite || data[key] === void 0) {
              data[key] = null;
            }
          } else {
            c = this.getRealCurrentLineNb() + 1;
            parser = new Parser(c);
            parser.refs = this.refs;
            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);

            if (allowOverwrite || data[key] === void 0) {
              data[key] = val;
            }
          }
        } else {
          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);

          if (allowOverwrite || data[key] === void 0) {
            data[key] = val;
          }
        }
      } else {
        lineCount = this.lines.length;

        if (1 === lineCount || 2 === lineCount && Utils.isEmpty(this.lines[1])) {
          try {
            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
          } catch (error) {
            e = error;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }

          if (_typeof(value) === 'object') {
            if (value instanceof Array) {
              first = value[0];
            } else {
              for (key in value) {
                first = value[key];
                break;
              }
            }

            if (typeof first === 'string' && first.indexOf('*') === 0) {
              data = [];

              for (n = 0, len3 = value.length; n < len3; n++) {
                alias = value[n];
                data.push(this.refs[alias.slice(1)]);
              }

              value = data;
            }
          }

          return value;
        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {
          try {
            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
          } catch (error) {
            e = error;
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
        }

        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }

      if (isRef) {
        if (data instanceof Array) {
          this.refs[isRef] = data[data.length - 1];
        } else {
          lastKey = null;

          for (key in data) {
            lastKey = key;
          }

          this.refs[isRef] = data[lastKey];
        }
      }
    }

    if (Utils.isEmpty(data)) {
      return null;
    } else {
      return data;
    }
  };

  Parser.prototype.getRealCurrentLineNb = function () {
    return this.currentLineNb + this.offset;
  };

  Parser.prototype.getCurrentLineIndentation = function () {
    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;
  };

  Parser.prototype.getNextEmbedBlock = function (indentation, includeUnindentedCollection) {
    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;

    if (indentation == null) {
      indentation = null;
    }

    if (includeUnindentedCollection == null) {
      includeUnindentedCollection = false;
    }

    this.moveToNextLine();

    if (indentation == null) {
      newIndent = this.getCurrentLineIndentation();
      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);

      if (!this.isCurrentLineEmpty() && 0 === newIndent && !unindentedEmbedBlock) {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    } else {
      newIndent = indentation;
    }

    data = [this.currentLine.slice(newIndent)];

    if (!includeUnindentedCollection) {
      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
    }

    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
    removeComments = !removeCommentsPattern.test(this.currentLine);

    while (this.moveToNextLine()) {
      indent = this.getCurrentLineIndentation();

      if (indent === newIndent) {
        removeComments = !removeCommentsPattern.test(this.currentLine);
      }

      if (removeComments && this.isCurrentLineComment()) {
        continue;
      }

      if (this.isCurrentLineBlank()) {
        data.push(this.currentLine.slice(newIndent));
        continue;
      }

      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {
        this.moveToPreviousLine();
        break;
      }

      if (indent >= newIndent) {
        data.push(this.currentLine.slice(newIndent));
      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {} else if (0 === indent) {
        this.moveToPreviousLine();
        break;
      } else {
        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);
      }
    }

    return data.join("\n");
  };

  Parser.prototype.moveToNextLine = function () {
    if (this.currentLineNb >= this.lines.length - 1) {
      return false;
    }

    this.currentLine = this.lines[++this.currentLineNb];
    return true;
  };

  Parser.prototype.moveToPreviousLine = function () {
    this.currentLine = this.lines[--this.currentLineNb];
  };

  Parser.prototype.parseValue = function (value, exceptionOnInvalidType, objectDecoder) {
    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;

    if (0 === value.indexOf('*')) {
      pos = value.indexOf('#');

      if (pos !== -1) {
        value = value.substr(1, pos - 2);
      } else {
        value = value.slice(1);
      }

      if (this.refs[value] === void 0) {
        throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
      }

      return this.refs[value];
    }

    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
      modifiers = (ref = matches.modifiers) != null ? ref : '';
      foldedIndent = Math.abs(parseInt(modifiers));

      if (isNaN(foldedIndent)) {
        foldedIndent = 0;
      }

      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);

      if (matches.type != null) {
        Inline.configure(exceptionOnInvalidType, objectDecoder);
        return Inline.parseScalar(matches.type + ' ' + val);
      } else {
        return val;
      }
    }

    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '"' || ref1 === "'") {
      while (true) {
        try {
          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
        } catch (error) {
          e = error;

          if (e instanceof ParseMore && this.moveToNextLine()) {
            value += "\n" + Utils.trim(this.currentLine, ' ');
          } else {
            e.parsedLine = this.getRealCurrentLineNb() + 1;
            e.snippet = this.currentLine;
            throw e;
          }
        }
      }
    } else {
      if (this.isNextLineIndented()) {
        value += "\n" + this.getNextEmbedBlock();
      }

      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
    }
  };

  Parser.prototype.parseFoldedScalar = function (separator, indicator, indentation) {
    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;

    if (indicator == null) {
      indicator = '';
    }

    if (indentation == null) {
      indentation = 0;
    }

    notEOF = this.moveToNextLine();

    if (!notEOF) {
      return '';
    }

    isCurrentLineBlank = this.isCurrentLineBlank();
    text = '';

    while (notEOF && isCurrentLineBlank) {
      if (notEOF = this.moveToNextLine()) {
        text += "\n";
        isCurrentLineBlank = this.isCurrentLineBlank();
      }
    }

    if (0 === indentation) {
      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
        indentation = matches[0].length;
      }
    }

    if (indentation > 0) {
      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];

      if (pattern == null) {
        pattern = new Pattern('^ {' + indentation + '}(.*)$');
        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
      }

      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
        if (isCurrentLineBlank) {
          text += this.currentLine.slice(indentation);
        } else {
          text += matches[1];
        }

        if (notEOF = this.moveToNextLine()) {
          text += "\n";
          isCurrentLineBlank = this.isCurrentLineBlank();
        }
      }
    } else if (notEOF) {
      text += "\n";
    }

    if (notEOF) {
      this.moveToPreviousLine();
    }

    if ('>' === separator) {
      newText = '';
      ref = text.split("\n");

      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];

        if (line.length === 0 || line.charAt(0) === ' ') {
          newText = Utils.rtrim(newText, ' ') + line + "\n";
        } else {
          newText += line + ' ';
        }
      }

      text = newText;
    }

    if ('+' !== indicator) {
      text = Utils.rtrim(text);
    }

    if ('' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
    } else if ('-' === indicator) {
      text = this.PATTERN_TRAILING_LINES.replace(text, '');
    }

    return text;
  };

  Parser.prototype.isNextLineIndented = function (ignoreComments) {
    var EOF, currentIndentation, ret;

    if (ignoreComments == null) {
      ignoreComments = true;
    }

    currentIndentation = this.getCurrentLineIndentation();
    EOF = !this.moveToNextLine();

    if (ignoreComments) {
      while (!EOF && this.isCurrentLineEmpty()) {
        EOF = !this.moveToNextLine();
      }
    } else {
      while (!EOF && this.isCurrentLineBlank()) {
        EOF = !this.moveToNextLine();
      }
    }

    if (EOF) {
      return false;
    }

    ret = false;

    if (this.getCurrentLineIndentation() > currentIndentation) {
      ret = true;
    }

    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isCurrentLineEmpty = function () {
    var trimmedLine;
    trimmedLine = Utils.trim(this.currentLine, ' ');
    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';
  };

  Parser.prototype.isCurrentLineBlank = function () {
    return '' === Utils.trim(this.currentLine, ' ');
  };

  Parser.prototype.isCurrentLineComment = function () {
    var ltrimmedLine;
    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');
    return ltrimmedLine.charAt(0) === '#';
  };

  Parser.prototype.cleanup = function (value) {
    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;

    if (value.indexOf("\r") !== -1) {
      value = value.split("\r\n").join("\n").split("\r").join("\n");
    }

    count = 0;
    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];
    this.offset += count;
    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];

    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
    }

    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];

    if (count === 1) {
      this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
      value = trimmedValue;
      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');
    }

    lines = value.split("\n");
    smallestIndent = -1;

    for (j = 0, len = lines.length; j < len; j++) {
      line = lines[j];

      if (Utils.trim(line, ' ').length === 0) {
        continue;
      }

      indent = line.length - Utils.ltrim(line).length;

      if (smallestIndent === -1 || indent < smallestIndent) {
        smallestIndent = indent;
      }
    }

    if (smallestIndent > 0) {
      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {
        line = lines[i];
        lines[i] = line.slice(smallestIndent);
      }

      value = lines.join("\n");
    }

    return value;
  };

  Parser.prototype.isNextLineUnIndentedCollection = function (currentIndentation) {
    var notEOF, ret;

    if (currentIndentation == null) {
      currentIndentation = null;
    }

    if (currentIndentation == null) {
      currentIndentation = this.getCurrentLineIndentation();
    }

    notEOF = this.moveToNextLine();

    while (notEOF && this.isCurrentLineEmpty()) {
      notEOF = this.moveToNextLine();
    }

    if (false === notEOF) {
      return false;
    }

    ret = false;

    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
      ret = true;
    }

    this.moveToPreviousLine();
    return ret;
  };

  Parser.prototype.isStringUnIndentedCollectionItem = function () {
    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';
  };

  return Parser;
}();

module.exports = Parser;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./Inline":303,"./Pattern":304,"./Utils":222,"./Exception/ParseException":305,"./Exception/ParseMore":306}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Dumper.js
      221: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

// Generated by CoffeeScript 1.12.4
var Dumper, Inline, Utils;
Utils = require('./Utils');
Inline = require('./Inline');

Dumper = function () {
  function Dumper() {}

  Dumper.indentation = 4;

  Dumper.prototype.dump = function (input, inline, indent, exceptionOnInvalidType, objectEncoder) {
    var i, key, len, output, prefix, value, willBeInlined;

    if (inline == null) {
      inline = 0;
    }

    if (indent == null) {
      indent = 0;
    }

    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }

    if (objectEncoder == null) {
      objectEncoder = null;
    }

    output = '';
    prefix = indent ? Utils.strRepeat(' ', indent) : '';

    if (inline <= 0 || _typeof(input) !== 'object' || input instanceof Date || Utils.isEmpty(input)) {
      output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
    } else {
      if (input instanceof Array) {
        for (i = 0, len = input.length; i < len; i++) {
          value = input[i];
          willBeInlined = inline - 1 <= 0 || _typeof(value) !== 'object' || Utils.isEmpty(value);
          output += prefix + '-' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      } else {
        for (key in input) {
          value = input[key];
          willBeInlined = inline - 1 <= 0 || _typeof(value) !== 'object' || Utils.isEmpty(value);
          output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ':' + (willBeInlined ? ' ' : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : '');
        }
      }
    }

    return output;
  };

  return Dumper;
}();

module.exports = Dumper;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./Utils":222,"./Inline":303}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Utils.js
      222: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var Pattern,
    Utils,
    hasProp = {}.hasOwnProperty;
Pattern = require('./Pattern');

Utils = function () {
  function Utils() {}

  Utils.REGEX_LEFT_TRIM_BY_CHAR = {};
  Utils.REGEX_RIGHT_TRIM_BY_CHAR = {};
  Utils.REGEX_SPACES = /\s+/g;
  Utils.REGEX_DIGITS = /^\d+$/;
  Utils.REGEX_OCTAL = /[^0-7]/gi;
  Utils.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;
  Utils.PATTERN_DATE = new Pattern('^' + '(?<year>[0-9][0-9][0-9][0-9])' + '-(?<month>[0-9][0-9]?)' + '-(?<day>[0-9][0-9]?)' + '(?:(?:[Tt]|[ \t]+)' + '(?<hour>[0-9][0-9]?)' + ':(?<minute>[0-9][0-9])' + ':(?<second>[0-9][0-9])' + '(?:\.(?<fraction>[0-9]*))?' + '(?:[ \t]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)' + '(?::(?<tz_minute>[0-9][0-9]))?))?)?' + '$', 'i');
  Utils.LOCAL_TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;

  Utils.trim = function (str, _char) {
    var regexLeft, regexRight;

    if (_char == null) {
      _char = '\\s';
    }

    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];

    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp('^' + _char + '' + _char + '*');
    }

    regexLeft.lastIndex = 0;
    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];

    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + '' + _char + '*$');
    }

    regexRight.lastIndex = 0;
    return str.replace(regexLeft, '').replace(regexRight, '');
  };

  Utils.ltrim = function (str, _char) {
    var regexLeft;

    if (_char == null) {
      _char = '\\s';
    }

    regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];

    if (regexLeft == null) {
      this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp('^' + _char + '' + _char + '*');
    }

    regexLeft.lastIndex = 0;
    return str.replace(regexLeft, '');
  };

  Utils.rtrim = function (str, _char) {
    var regexRight;

    if (_char == null) {
      _char = '\\s';
    }

    regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];

    if (regexRight == null) {
      this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + '' + _char + '*$');
    }

    regexRight.lastIndex = 0;
    return str.replace(regexRight, '');
  };

  Utils.isEmpty = function (value) {
    return !value || value === '' || value === '0' || value instanceof Array && value.length === 0 || this.isEmptyObject(value);
  };

  Utils.isEmptyObject = function (value) {
    var k;
    return value instanceof Object && function () {
      var results;
      results = [];

      for (k in value) {
        if (!hasProp.call(value, k)) continue;
        results.push(k);
      }

      return results;
    }().length === 0;
  };

  Utils.subStrCount = function (string, subString, start, length) {
    var c, i, j, len, ref, sublen;
    c = 0;
    string = '' + string;
    subString = '' + subString;

    if (start != null) {
      string = string.slice(start);
    }

    if (length != null) {
      string = string.slice(0, length);
    }

    len = string.length;
    sublen = subString.length;

    for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (subString === string.slice(i, sublen)) {
        c++;
        i += sublen - 1;
      }
    }

    return c;
  };

  Utils.isDigits = function (input) {
    this.REGEX_DIGITS.lastIndex = 0;
    return this.REGEX_DIGITS.test(input);
  };

  Utils.octDec = function (input) {
    this.REGEX_OCTAL.lastIndex = 0;
    return parseInt((input + '').replace(this.REGEX_OCTAL, ''), 8);
  };

  Utils.hexDec = function (input) {
    this.REGEX_HEXADECIMAL.lastIndex = 0;
    input = this.trim(input);

    if ((input + '').slice(0, 2) === '0x') {
      input = (input + '').slice(2);
    }

    return parseInt((input + '').replace(this.REGEX_HEXADECIMAL, ''), 16);
  };

  Utils.utf8chr = function (c) {
    var ch;
    ch = String.fromCharCode;

    if (0x80 > (c %= 0x200000)) {
      return ch(c);
    }

    if (0x800 > c) {
      return ch(0xC0 | c >> 6) + ch(0x80 | c & 0x3F);
    }

    if (0x10000 > c) {
      return ch(0xE0 | c >> 12) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
    }

    return ch(0xF0 | c >> 18) + ch(0x80 | c >> 12 & 0x3F) + ch(0x80 | c >> 6 & 0x3F) + ch(0x80 | c & 0x3F);
  };

  Utils.parseBoolean = function (input, strict) {
    var lowerInput;

    if (strict == null) {
      strict = true;
    }

    if (typeof input === 'string') {
      lowerInput = input.toLowerCase();

      if (!strict) {
        if (lowerInput === 'no') {
          return false;
        }
      }

      if (lowerInput === '0') {
        return false;
      }

      if (lowerInput === 'false') {
        return false;
      }

      if (lowerInput === '') {
        return false;
      }

      return true;
    }

    return !!input;
  };

  Utils.isNumeric = function (input) {
    this.REGEX_SPACES.lastIndex = 0;
    return typeof input === 'number' || typeof input === 'string' && !isNaN(input) && input.replace(this.REGEX_SPACES, '') !== '';
  };

  Utils.stringToDate = function (str) {
    var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;

    if (!(str != null ? str.length : void 0)) {
      return null;
    }

    info = this.PATTERN_DATE.exec(str);

    if (!info) {
      return null;
    }

    year = parseInt(info.year, 10);
    month = parseInt(info.month, 10) - 1;
    day = parseInt(info.day, 10);

    if (info.hour == null) {
      date = new Date(Date.UTC(year, month, day));
      return date;
    }

    hour = parseInt(info.hour, 10);
    minute = parseInt(info.minute, 10);
    second = parseInt(info.second, 10);

    if (info.fraction != null) {
      fraction = info.fraction.slice(0, 3);

      while (fraction.length < 3) {
        fraction += '0';
      }

      fraction = parseInt(fraction, 10);
    } else {
      fraction = 0;
    }

    if (info.tz != null) {
      tz_hour = parseInt(info.tz_hour, 10);

      if (info.tz_minute != null) {
        tz_minute = parseInt(info.tz_minute, 10);
      } else {
        tz_minute = 0;
      }

      tz_offset = (tz_hour * 60 + tz_minute) * 60000;

      if ('-' === info.tz_sign) {
        tz_offset *= -1;
      }
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

    if (tz_offset) {
      date.setTime(date.getTime() - tz_offset);
    }

    return date;
  };

  Utils.strRepeat = function (str, number) {
    var i, res;
    res = '';
    i = 0;

    while (i < number) {
      res += str;
      i++;
    }

    return res;
  };

  Utils.getStringFromFile = function (path, callback) {
    var data, fs, j, len1, name, ref, req, xhr;

    if (callback == null) {
      callback = null;
    }

    xhr = null;

    if (typeof window !== "undefined" && window !== null) {
      if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
      } else if (window.ActiveXObject) {
        ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];

        for (j = 0, len1 = ref.length; j < len1; j++) {
          name = ref[j];

          try {
            xhr = new ActiveXObject(name);
          } catch (error) {}
        }
      }
    }

    if (xhr != null) {
      if (callback != null) {
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            if (xhr.status === 200 || xhr.status === 0) {
              return callback(xhr.responseText);
            } else {
              return callback(null);
            }
          }
        };

        xhr.open('GET', path, true);
        return xhr.send(null);
      } else {
        xhr.open('GET', path, false);
        xhr.send(null);

        if (xhr.status === 200 || xhr.status === 0) {
          return xhr.responseText;
        }

        return null;
      }
    } else {
      req = require;
      fs = req('fs');

      if (callback != null) {
        return fs.readFile(path, function (err, data) {
          if (err) {
            return callback(null);
          } else {
            return callback(String(data));
          }
        });
      } else {
        data = fs.readFileSync(path);

        if (data != null) {
          return String(data);
        }

        return null;
      }
    }
  };

  return Utils;
}();

module.exports = Utils;
        },
        map: {"./Pattern":304}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/curlconverter/generators/matlab/common.js
      223: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var jsesc = require('jsesc');

var repr = function repr(value) {
  // In context of url parameters, don't accept nulls and such.
  if (!value) {
    return "''";
  }

  return "'" + jsesc(value, {
    quotes: 'single'
  }).replace(/\\'/g, "''") + "'";
};

var setVariableValue = function setVariableValue(outputVariable, value, termination) {
  var result = '';

  if (outputVariable) {
    result += outputVariable + ' = ';
  }

  result += value;
  result += typeof termination === 'undefined' || termination === null ? ';' : termination;
  return result;
};

var callFunction = function callFunction(outputVariable, functionName, params, termination) {
  var functionCall = functionName + '(';

  if (Array.isArray(params)) {
    var singleLine = params.map(function (x) {
      return Array.isArray(x) ? x.join(', ') : x;
    }).join(', ');
    var indentLevel = 1;
    var indent = ' '.repeat(4 * indentLevel);
    var skipToNextLine = '...\n' + indent;
    var multiLine = skipToNextLine;
    multiLine += params.map(function (x) {
      return Array.isArray(x) ? x.join(', ') : x;
    }).join(',' + skipToNextLine);
    multiLine += '...\n'; // Split the params in multiple lines - if one line is not enough

    var combinedSingleLineLength = [outputVariable, functionName, singleLine].map(function (x) {
      return x ? x.length : 0;
    }).reduce(function (x, y) {
      return x + y;
    }) + (outputVariable ? 3 : 0) + 2 + (termination ? termination.length : 1);
    functionCall += combinedSingleLineLength < 120 ? singleLine : multiLine;
  } else {
    functionCall += params;
  }

  functionCall += ')';
  return setVariableValue(outputVariable, functionCall, termination);
};

var addCellArray = function addCellArray(mapping, keysNotToQuote, keyValSeparator, indentLevel, pairs) {
  var indentUnit = ' '.repeat(4);
  var indent = indentUnit.repeat(indentLevel);
  var indentPrevLevel = indentUnit.repeat(indentLevel - 1);
  var entries = Object.entries(mapping);
  if (entries.length === 0) return '';
  var response = pairs ? '' : '{';

  if (entries.length === 1) {
    var _entries$pop = entries.pop(),
        _entries$pop2 = _slicedToArray(_entries$pop, 2),
        key = _entries$pop2[0],
        value = _entries$pop2[1];

    if (keysNotToQuote && !keysNotToQuote.includes(key)) value = "".concat(repr(value));
    response += "".concat(repr(key)).concat(keyValSeparator, " ").concat(value);
  } else {
    if (pairs) response += '...';
    var counter = entries.length;

    var _iterator = _createForOfIteratorHelper(entries),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            _key = _step$value[0],
            _value = _step$value[1];

        --counter;

        if (keysNotToQuote && !keysNotToQuote.includes(_key)) {
          if (_typeof(_value) === 'object') {
            _value = "[".concat(_value.map(repr).join(), "]");
          } else {
            _value = "".concat(repr(_value));
          }
        }

        response += "\n".concat(indent).concat(repr(_key)).concat(keyValSeparator, " ").concat(_value);

        if (pairs) {
          if (counter !== 0) response += ',';
          response += '...';
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    response += "\n".concat(indentPrevLevel);
  }

  response += pairs ? '' : '}';
  return response;
};

var structify = function structify(obj, indentLevel) {
  var response = '';
  indentLevel = !indentLevel ? 1 : ++indentLevel;
  var indent = ' '.repeat(4 * indentLevel);
  var prevIndent = ' '.repeat(4 * (indentLevel - 1));

  if (obj instanceof Array) {
    var list = [];
    var listContainsNumbers = true;

    for (var k in obj) {
      if (listContainsNumbers && typeof obj[k] !== 'number') {
        listContainsNumbers = false;
      }

      var value = structify(obj[k], indentLevel);
      list.push("".concat(value));
    }

    if (listContainsNumbers) {
      var listString = list.join(' ');
      response += "[".concat(listString, "]");
    } else {
      list.unshift('{{');

      var _listString = list.join("\n".concat(indent));

      response += "".concat(_listString, "\n").concat(prevIndent, "}}");
    }
  } else if (obj instanceof Object) {
    response += 'struct(...';
    var first = true;

    for (var _k in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, _k)) {
        if (!_k[0].match(/[a-z]/i)) {
          throw Error('MATLAB structs do not support keys starting with non-alphabet symbols');
        } // recursive call to scan property


        if (first) {
          first = false;
        } else {
          response += ',...';
        }

        response += "\n".concat(indent);
        response += "'".concat(_k, "', ");
        response += structify(obj[_k], indentLevel);
      }
    }

    response += '...';
    response += "\n".concat(prevIndent, ")");
  } else if (typeof obj === 'number') {
    // not an Object so obj[k] here is a value
    response += "".concat(obj);
  } else {
    response += "".concat(repr(obj));
  }

  return response;
};

var containsBody = function containsBody(request) {
  return request.data || request.multipartUploads;
};

var prepareQueryString = function prepareQueryString(request) {
  var response = null;

  if (request.query) {
    var params = addCellArray(request.query, [], '', 1);
    response = setVariableValue('params', params);
  }

  return response;
};

var prepareCookies = function prepareCookies(request) {
  var response = null;

  if (request.cookies) {
    var cookies = addCellArray(request.cookies, [], '', 1);
    response = setVariableValue('cookies', cookies);
  }

  return response;
};

var cookieString = 'char(join(join(cookies, \'=\'), \'; \'))';
var paramsString = 'char(join(join(params, \'=\'), \'&\'))';
module.exports = {
  repr: repr,
  setVariableValue: setVariableValue,
  callFunction: callFunction,
  addCellArray: addCellArray,
  structify: structify,
  containsBody: containsBody,
  prepareQueryString: prepareQueryString,
  prepareCookies: prepareCookies,
  cookieString: cookieString,
  paramsString: paramsString
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/slicedToArray":120,"jsesc":137}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_ListCache.js
      224: {
        factory: (module, exports, require) => {
          var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;
        },
        map: {"./_listCacheClear":307,"./_listCacheDelete":308,"./_listCacheGet":309,"./_listCacheHas":310,"./_listCacheSet":311}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_stackClear.js
      225: {
        factory: (module, exports, require) => {
          var ListCache = require('./_ListCache');
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;
        },
        map: {"./_ListCache":224}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_stackDelete.js
      226: {
        factory: (module, exports, require) => {
          /**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_stackGet.js
      227: {
        factory: (module, exports, require) => {
          /**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_stackHas.js
      228: {
        factory: (module, exports, require) => {
          /**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_stackSet.js
      229: {
        factory: (module, exports, require) => {
          var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;
        },
        map: {"./_ListCache":224,"./_Map":234,"./_MapCache":312}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/eq.js
      230: {
        factory: (module, exports, require) => {
          /**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_root.js
      231: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var freeGlobal = require('./_freeGlobal');
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./_freeGlobal":313}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getSymbols.js
      232: {
        factory: (module, exports, require) => {
          var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;
        },
        map: {"./_arrayFilter":314,"./stubArray":264}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_DataView.js
      233: {
        factory: (module, exports, require) => {
          var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;
        },
        map: {"./_getNative":315,"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_Map.js
      234: {
        factory: (module, exports, require) => {
          var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;
        },
        map: {"./_getNative":315,"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_Promise.js
      235: {
        factory: (module, exports, require) => {
          var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;
        },
        map: {"./_getNative":315,"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_Set.js
      236: {
        factory: (module, exports, require) => {
          var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;
        },
        map: {"./_getNative":315,"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_WeakMap.js
      237: {
        factory: (module, exports, require) => {
          var getNative = require('./_getNative'),
    root = require('./_root');
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;
        },
        map: {"./_getNative":315,"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseGetTag.js
      238: {
        factory: (module, exports, require) => {
          var _Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;
        },
        map: {"./_Symbol":316,"./_getRawTag":317,"./_objectToString":318}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_toSource.js
      239: {
        factory: (module, exports, require) => {
          /** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_cloneArrayBuffer.js
      240: {
        factory: (module, exports, require) => {
          var Uint8Array = require('./_Uint8Array');
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;
        },
        map: {"./_Uint8Array":319}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_cloneDataView.js
      241: {
        factory: (module, exports, require) => {
          var cloneArrayBuffer = require('./_cloneArrayBuffer');
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;
        },
        map: {"./_cloneArrayBuffer":240}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_cloneRegExp.js
      242: {
        factory: (module, exports, require) => {
          /** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_cloneSymbol.js
      243: {
        factory: (module, exports, require) => {
          var _Symbol = require('./_Symbol');
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;
        },
        map: {"./_Symbol":316}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_cloneTypedArray.js
      244: {
        factory: (module, exports, require) => {
          var cloneArrayBuffer = require('./_cloneArrayBuffer');
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;
        },
        map: {"./_cloneArrayBuffer":240}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseCreate.js
      245: {
        factory: (module, exports, require) => {
          var isObject = require('./isObject');
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;
        },
        map: {"./isObject":158}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getPrototype.js
      246: {
        factory: (module, exports, require) => {
          var overArg = require('./_overArg');
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;
        },
        map: {"./_overArg":320}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_isPrototype.js
      247: {
        factory: (module, exports, require) => {
          /** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/stubFalse.js
      248: {
        factory: (module, exports, require) => {
          /**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsMap.js
      249: {
        factory: (module, exports, require) => {
          var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;
        },
        map: {"./_getTag":152,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseUnary.js
      250: {
        factory: (module, exports, require) => {
          /**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_nodeUtil.js
      251: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var freeGlobal = require('./_freeGlobal');
/** Detect free variable `exports`. */


var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./_freeGlobal":313}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsSet.js
      252: {
        factory: (module, exports, require) => {
          var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;
        },
        map: {"./_getTag":152,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_arrayLikeKeys.js
      253: {
        factory: (module, exports, require) => {
          var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;
        },
        map: {"./_baseTimes":321,"./isArguments":270,"./isArray":99,"./isBuffer":156,"./_isIndex":269,"./isTypedArray":322}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseKeys.js
      254: {
        factory: (module, exports, require) => {
          var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;
        },
        map: {"./_isPrototype":247,"./_nativeKeys":323}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isArrayLike.js
      255: {
        factory: (module, exports, require) => {
          var isFunction = require('./isFunction'),
    isLength = require('./isLength');
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;
        },
        map: {"./isFunction":324,"./isLength":271}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseKeysIn.js
      256: {
        factory: (module, exports, require) => {
          var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;
        },
        map: {"./isObject":158,"./_isPrototype":247,"./_nativeKeysIn":325}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseSlice.js
      257: {
        factory: (module, exports, require) => {
          /**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

module.exports = baseSlice;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isSymbol.js
      258: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./_baseGetTag":238,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_memoizeCapped.js
      259: {
        factory: (module, exports, require) => {
          var memoize = require('./memoize');
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;
        },
        map: {"./memoize":326}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseToString.js
      260: {
        factory: (module, exports, require) => {
          var _Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;
        },
        map: {"./_Symbol":316,"./_arrayMap":89,"./isArray":99,"./isSymbol":258}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_defineProperty.js
      261: {
        factory: (module, exports, require) => {
          var getNative = require('./_getNative');

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;
        },
        map: {"./_getNative":315}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isObjectLike.js
      262: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_arrayPush.js
      263: {
        factory: (module, exports, require) => {
          /**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/stubArray.js
      264: {
        factory: (module, exports, require) => {
          /**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseFor.js
      265: {
        factory: (module, exports, require) => {
          var createBaseFor = require('./_createBaseFor');
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;
        },
        map: {"./_createBaseFor":327}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/get-intrinsic/index.js
      266: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError; // eslint-disable-next-line consistent-return

var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
  var value;

  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');

    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');

    if (gen) {
      value = getProto(gen.prototype);
    }
  }

  INTRINSICS[name] = value;
  return value;
};

var LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');

var hasOwn = require('has');

var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);

  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }

  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];

    if (value === needsEval) {
      value = doEval(intrinsicName);
    }

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);

    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        return void undefined;
      }

      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc; // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.

        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"has-symbols":328,"function-bind":329,"has":330}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/call-bind/callBound.js
      267: {
        factory: (module, exports, require) => {
          'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }

  return intrinsic;
};
        },
        map: {"get-intrinsic":266,"./":296}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/object-inspect/index.js
      268: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'object'; // ie, `has-tostringtag/shams

var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (_typeof(Symbol.toStringTag) === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
? function (O) {
  return O.__proto__; // eslint-disable-line no-proto
} : null);

function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
    return str;
  }

  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;

  if (typeof num === 'number') {
    var _int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)


    if (_int !== num) {
      var intStr = String(_int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
    }
  }

  return $replace.call(str, sepRegex, '$&_');
}

var inspectCustom = require('./util.inspect').custom;

var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
  var opts = options || {};

  if (has(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }

  if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }

  var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;

  if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
    throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
  }

  if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }

  if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }

  var numericSeparator = opts.numericSeparator;

  if (typeof obj === 'undefined') {
    return 'undefined';
  }

  if (obj === null) {
    return 'null';
  }

  if (typeof obj === 'boolean') {
    return obj ? 'true' : 'false';
  }

  if (typeof obj === 'string') {
    return inspectString(obj, opts);
  }

  if (typeof obj === 'number') {
    if (obj === 0) {
      return Infinity / obj > 0 ? '0' : '-0';
    }

    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }

  if (typeof obj === 'bigint') {
    var bigIntStr = String(obj) + 'n';
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }

  var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;

  if (typeof depth === 'undefined') {
    depth = 0;
  }

  if (depth >= maxDepth && maxDepth > 0 && _typeof(obj) === 'object') {
    return isArray(obj) ? '[Array]' : '[Object]';
  }

  var indent = getIndent(opts, depth);

  if (typeof seen === 'undefined') {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return '[Circular]';
  }

  function inspect(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }

    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };

      if (has(opts, 'quoteStyle')) {
        newOpts.quoteStyle = opts.quoteStyle;
      }

      return inspect_(value, newOpts, depth + 1, seen);
    }

    return inspect_(value, opts, depth + 1, seen);
  }

  if (typeof obj === 'function') {
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect);
    return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
  }

  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
    return _typeof(obj) === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
  }

  if (isElement(obj)) {
    var s = '<' + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];

    for (var i = 0; i < attrs.length; i++) {
      s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
    }

    s += '>';

    if (obj.childNodes && obj.childNodes.length) {
      s += '...';
    }

    s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
    return s;
  }

  if (isArray(obj)) {
    if (obj.length === 0) {
      return '[]';
    }

    var xs = arrObjKeys(obj, inspect);

    if (indent && !singleLineValues(xs)) {
      return '[' + indentedJoin(xs, indent) + ']';
    }

    return '[ ' + $join.call(xs, ', ') + ' ]';
  }

  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect);

    if ('cause' in obj && !isEnumerable.call(obj, 'cause')) {
      return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
    }

    if (parts.length === 0) {
      return '[' + String(obj) + ']';
    }

    return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
  }

  if (_typeof(obj) === 'object' && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
      return obj[inspectSymbol]();
    } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
      return obj.inspect();
    }
  }

  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function (value, key) {
      mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
    });
    return collectionOf('Map', mapSize.call(obj), mapParts, indent);
  }

  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function (value) {
      setParts.push(inspect(value, obj));
    });
    return collectionOf('Set', setSize.call(obj), setParts, indent);
  }

  if (isWeakMap(obj)) {
    return weakCollectionOf('WeakMap');
  }

  if (isWeakSet(obj)) {
    return weakCollectionOf('WeakSet');
  }

  if (isWeakRef(obj)) {
    return weakCollectionOf('WeakRef');
  }

  if (isNumber(obj)) {
    return markBoxed(inspect(Number(obj)));
  }

  if (isBigInt(obj)) {
    return markBoxed(inspect(bigIntValueOf.call(obj)));
  }

  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }

  if (isString(obj)) {
    return markBoxed(inspect(String(obj)));
  }

  if (!isDate(obj) && !isRegExp(obj)) {
    var ys = arrObjKeys(obj, inspect);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? '' : 'null prototype';
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
    var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
    var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');

    if (ys.length === 0) {
      return tag + '{}';
    }

    if (indent) {
      return tag + '{' + indentedJoin(ys, indent) + '}';
    }

    return tag + '{ ' + $join.call(ys, ', ') + ' }';
  }

  return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
  return quoteChar + s + quoteChar;
}

function quote(s) {
  return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) {
  return toStr(obj) === '[object Array]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isDate(obj) {
  return toStr(obj) === '[object Date]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isRegExp(obj) {
  return toStr(obj) === '[object RegExp]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isError(obj) {
  return toStr(obj) === '[object Error]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isString(obj) {
  return toStr(obj) === '[object String]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isNumber(obj) {
  return toStr(obj) === '[object Number]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
}

function isBoolean(obj) {
  return toStr(obj) === '[object Boolean]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
} // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives


function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && _typeof(obj) === 'object' && obj instanceof Symbol;
  }

  if (_typeof(obj) === 'symbol') {
    return true;
  }

  if (!obj || _typeof(obj) !== 'object' || !symToString) {
    return false;
  }

  try {
    symToString.call(obj);
    return true;
  } catch (e) {}

  return false;
}

function isBigInt(obj) {
  if (!obj || _typeof(obj) !== 'object' || !bigIntValueOf) {
    return false;
  }

  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {}

  return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) {
  return key in this;
};

function has(obj, key) {
  return hasOwn.call(obj, key);
}

function toStr(obj) {
  return objectToString.call(obj);
}

function nameOf(f) {
  if (f.name) {
    return f.name;
  }

  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);

  if (m) {
    return m[1];
  }

  return null;
}

function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }

  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }

  return -1;
}

function isMap(x) {
  if (!mapSize || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    mapSize.call(x);

    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }

    return x instanceof Map; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakMap(x) {
  if (!weakMapHas || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    weakMapHas.call(x, weakMapHas);

    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }

    return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakRef(x) {
  if (!weakRefDeref || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {}

  return false;
}

function isSet(x) {
  if (!setSize || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    setSize.call(x);

    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }

    return x instanceof Set; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakSet(x) {
  if (!weakSetHas || !x || _typeof(x) !== 'object') {
    return false;
  }

  try {
    weakSetHas.call(x, weakSetHas);

    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }

    return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isElement(x) {
  if (!x || _typeof(x) !== 'object') {
    return false;
  }

  if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
    return true;
  }

  return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  } // eslint-disable-next-line no-control-regex


  var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: 'b',
    9: 't',
    10: 'n',
    12: 'f',
    13: 'r'
  }[n];

  if (x) {
    return '\\' + x;
  }

  return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
  return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
  return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
  return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], '\n') >= 0) {
      return false;
    }
  }

  return true;
}

function getIndent(opts, depth) {
  var baseIndent;

  if (opts.indent === '\t') {
    baseIndent = '\t';
  } else if (typeof opts.indent === 'number' && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), ' ');
  } else {
    return null;
  }

  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}

function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return '';
  }

  var lineJoiner = '\n' + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
  var isArr = isArray(obj);
  var xs = [];

  if (isArr) {
    xs.length = obj.length;

    for (var i = 0; i < obj.length; i++) {
      xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
    }
  }

  var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
  var symMap;

  if (hasShammedSymbols) {
    symMap = {};

    for (var k = 0; k < syms.length; k++) {
      symMap['$' + syms[k]] = syms[k];
    }
  }

  for (var key in obj) {
    // eslint-disable-line no-restricted-syntax
    if (!has(obj, key)) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue


    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue


    if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
      // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
      continue; // eslint-disable-line no-restricted-syntax, no-continue
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
    } else {
      xs.push(key + ': ' + inspect(obj[key], obj));
    }
  }

  if (typeof gOPS === 'function') {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
      }
    }
  }

  return xs;
}
        },
        map: {"@babel/runtime/helpers/typeof":12,"./util.inspect":331}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_isIndex.js
      269: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isArguments.js
      270: {
        factory: (module, exports, require) => {
          var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;
        },
        map: {"./_baseIsArguments":332,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isLength.js
      271: {
        factory: (module, exports, require) => {
          /** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_isFlattenable.js
      272: {
        factory: (module, exports, require) => {
          var _Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');
/** Built-in value references. */


var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;
        },
        map: {"./_Symbol":316,"./isArguments":270,"./isArray":99}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/constant.js
      273: {
        factory: (module, exports, require) => {
          /**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseMatches.js
      274: {
        factory: (module, exports, require) => {
          var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;
        },
        map: {"./_baseIsMatch":333,"./_getMatchData":334,"./_matchesStrictComparable":335}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseMatchesProperty.js
      275: {
        factory: (module, exports, require) => {
          var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;
        },
        map: {"./_baseIsEqual":336,"./get":337,"./hasIn":104,"./_isKey":165,"./_isStrictComparable":338,"./_matchesStrictComparable":335,"./_toKey":164}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/property.js
      276: {
        factory: (module, exports, require) => {
          var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;
        },
        map: {"./_baseProperty":339,"./_basePropertyDeep":340,"./_isKey":165,"./_toKey":164}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nice-try/src/index.js
      277: {
        factory: (module, exports, require) => {
          'use strict';
/**
 * Tries to execute a function and discards any error that occurs.
 * @param {Function} fn - Function that might or might not throw an error.
 * @returns {?*} Return-value of the function when no error occurred.
 */

module.exports = function (fn) {
  try {
    return fn();
  } catch (e) {}
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/cross-spawn/lib/util/resolveCommand.js
      278: {
        factory: (module, exports, require) => {
          'use strict';

var path = require('path');

var which = require('which');

var pathKey = require('path-key')();

function resolveCommandAttempt(parsed, withoutPathExt) {
  var cwd = process.cwd();
  var hasCustomCwd = parsed.options.cwd != null; // If a custom `cwd` was specified, we need to change the process cwd
  // because `which` will do stat calls but does not support a custom cwd

  if (hasCustomCwd) {
    try {
      process.chdir(parsed.options.cwd);
    } catch (err) {
      /* Empty */
    }
  }

  var resolved;

  try {
    resolved = which.sync(parsed.command, {
      path: (parsed.options.env || process.env)[pathKey],
      pathExt: withoutPathExt ? path.delimiter : undefined
    });
  } catch (e) {
    /* Empty */
  } finally {
    process.chdir(cwd);
  } // If we successfully resolved, ensure that an absolute path is returned
  // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it


  if (resolved) {
    resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
  }

  return resolved;
}

function resolveCommand(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}

module.exports = resolveCommand;
        },
        map: {"path":-19260817,"which":341,"path-key":342}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/cross-spawn/lib/util/escape.js
      279: {
        factory: (module, exports, require) => {
          'use strict'; // See http://www.robvanderwoude.com/escapechars.php

var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function escapeCommand(arg) {
  // Escape meta chars
  arg = arg.replace(metaCharsRegExp, '^$1');
  return arg;
}

function escapeArgument(arg, doubleEscapeMetaChars) {
  // Convert to string
  arg = "".concat(arg); // Algorithm below is based on https://qntm.org/cmd
  // Sequence of backslashes followed by a double quote:
  // double up all the backslashes and escape the double quote

  arg = arg.replace(/(\\*)"/g, '$1$1\\"'); // Sequence of backslashes followed by the end of the string
  // (which will become a double quote later):
  // double up all the backslashes

  arg = arg.replace(/(\\*)$/, '$1$1'); // All other backslashes occur literally
  // Quote the whole thing:

  arg = "\"".concat(arg, "\""); // Escape meta chars

  arg = arg.replace(metaCharsRegExp, '^$1'); // Double escape meta chars if necessary

  if (doubleEscapeMetaChars) {
    arg = arg.replace(metaCharsRegExp, '^$1');
  }

  return arg;
}

module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/cross-spawn/lib/util/readShebang.js
      280: {
        factory: (module, exports, require) => {
          'use strict';

var fs = require('fs');

var shebangCommand = require('shebang-command');

function readShebang(command) {
  // Read the first 150 bytes from the file
  var size = 150;
  var buffer;

  if (Buffer.alloc) {
    // Node.js v4.5+ / v5.10+
    buffer = Buffer.alloc(size);
  } else {
    // Old Node.js API
    buffer = new Buffer(size);
    buffer.fill(0); // zero-fill
  }

  var fd;

  try {
    fd = fs.openSync(command, 'r');
    fs.readSync(fd, buffer, 0, size, 0);
    fs.closeSync(fd);
  } catch (e) {
    /* Empty */
  } // Attempt to extract shebang (null is returned if not a shebang)


  return shebangCommand(buffer.toString());
}

module.exports = readShebang;
        },
        map: {"fs":-19260817,"shebang-command":343}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/semver/semver.js
      281: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

exports = module.exports = SemVer;
var debug;
/* istanbul ignore next */

if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function debug() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function debug() {};
} // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.


exports.SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var R = 0; // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'; // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
src[FULL] = '^' + FULLPLAIN + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';
var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'; // Coercion.
// Extract anything that could conceivably be a part of a valid semver

var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])'; // Tilde ranges.
// Meaning is "reasonably at or greater than"

var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';
var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';
var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'; // Caret ranges.
// Meaning is "at least and backwards compatible with"

var LONECARET = R++;
src[LONECARET] = '(?:\\^)';
var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';
var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'; // this one has to use the /g flag

re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.

for (var i = 0; i < R; i++) {
  debug(i, src[i]);

  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;

function parse(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[LOOSE] : re[FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;

function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}

exports.clean = clean;

function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version;
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options);
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;
  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version);
  }

  this.raw = version; // these are actually numbers

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version');
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version');
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version');
  } // numberify any prerelease numeric ids


  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;

        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num;
        }
      }

      return id;
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;

  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }

  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);

  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  } // NOT having a prerelease is > having one


  if (this.prerelease.length && !other.prerelease.length) {
    return -1;
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1;
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0;
  }

  var i = 0;

  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
}; // preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.


SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;

    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;

    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.

    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }

      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
        this.major++;
      }

      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;

    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }

      this.patch = 0;
      this.prerelease = [];
      break;

    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }

      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;

        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }

        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }

      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }

  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;

function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;

function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';

    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;
var numeric = /^[0-9]+$/;

function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
}

exports.rcompareIdentifiers = rcompareIdentifiers;

function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;

function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;

function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;

function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;

function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;

function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;

function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;

function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;

function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;

function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;

function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;

function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;

function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;

function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;

function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;

function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a === b;

    case '!==':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError('Invalid operator: ' + op);
  }
}

exports.Comparator = Comparator;

function Comparator(comp, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp;
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options);
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};

Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp);
  }

  this.operator = m[1];

  if (this.operator === '=') {
    this.operator = '';
  } // if it literally is just '>' or '' then allow anything.


  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY) {
    return true;
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;

function Range(range, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range)) {
    return new Range(range, options);
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

  range = range.replace(re[TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

  range = range.replace(re[CARETTRIM], caretTrimReplace); // normalize spaces

  range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);

  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }

  set = set.map(function (comp) {
    return new Comparator(comp, this.options);
  }, this);
  return set;
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
}; // Mostly just for testing and legacy API reasons


exports.toComparators = toComparators;

function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
} // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
} // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0


function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret;
  });
} // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0


function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);
    return ret;
  });
} // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[STAR], '');
} // This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0


function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim();
} // if ANY of the sets match ALL of its comparators, then pass


Range.prototype.test = function (version) {
  if (!version) {
    return false;
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true;
    }
  }

  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);

      if (set[i].semver === ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
}

exports.satisfies = satisfies;

function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;

function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;

function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
}

exports.minVersion = minVersion;

function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error('Unexpected operation: ' + comparator.operator);
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
}

exports.validRange = validRange;

function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
} // Determine if version is less than all the versions possible in the range


exports.ltr = ltr;

function ltr(version, range, options) {
  return outside(version, range, '<', options);
} // Determine if version is greater than all the versions possible in the range.


exports.gtr = gtr;

function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;

function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisifes the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
}

exports.prerelease = prerelease;

function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;

function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
}

exports.coerce = coerce;

function coerce(version) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  var match = version.match(re[COERCE]);

  if (match == null) {
    return null;
  }

  return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
}
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/isNativeFunction.js
      282: {
        factory: (module, exports, require) => {
          function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/once/once.js
      283: {
        factory: (module, exports, require) => {
          var wrappy = require('wrappy');

module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function value() {
      return once(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function value() {
      return onceStrict(this);
    },
    configurable: true
  });
});

function once(fn) {
  var f = function f() {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  f.called = false;
  return f;
}

function onceStrict(fn) {
  var f = function f() {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
        },
        map: {"wrappy":344}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/end-of-stream/index.js
      284: {
        factory: (module, exports, require) => {
          var once = require('once');

var noop = function noop() {};

var isRequest = function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function isChildProcess(stream) {
  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};

var eos = function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var cancelled = false;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var onfinish = function onfinish() {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function onend() {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onexit = function onexit(exitCode) {
    callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    process.nextTick(onclosenexttick);
  };

  var onclosenexttick = function onclosenexttick() {
    if (cancelled) return;
    if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
    if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  if (isChildProcess(stream)) stream.on('exit', onexit);
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    cancelled = true;
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
};

module.exports = eos;
        },
        map: {"once":283}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@curlconverter/yargs/build/index.cjs
      285: {
        factory: (module, exports, require) => {
          "use strict";

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _toArray = require("@babel/runtime/helpers/toArray");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _typeof = require("@babel/runtime/helpers/typeof");

var _createClass = require("@babel/runtime/helpers/createClass");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _assertThisInitialized = require("@babel/runtime/helpers/assertThisInitialized");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

var _wrapNativeSuper = require("@babel/runtime/helpers/wrapNativeSuper");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e22) { throw _e22; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e23) { didErr = true; err = _e23; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var t = require("assert");

var e = /*#__PURE__*/function (_Error) {
  _inherits(e, _Error);

  var _super = _createSuper(e);

  function e(t) {
    var _this;

    _classCallCheck(this, e);

    _this = _super.call(this, t || "yargs error"), _this.name = "YError", Error.captureStackTrace(_assertThisInitialized(_this), e);
    return _this;
  }

  return _createClass(e);
}( /*#__PURE__*/_wrapNativeSuper(Error));

var s,
    i = [];

function n(t, o, a, h) {
  s = h;
  var l = {};

  if (Object.prototype.hasOwnProperty.call(t, "extends")) {
    if ("string" != typeof t["extends"]) return l;

    var _r = /\.json|\..*rc$/.test(t["extends"]);

    var _h = null;
    if (_r) _h = function (t, e) {
      return s.path.resolve(t, e);
    }(o, t["extends"]);else try {
      _h = require.resolve(t["extends"]);
    } catch (e) {
      return t;
    }
    !function (t) {
      if (i.indexOf(t) > -1) throw new e("Circular extended configurations: '".concat(t, "'."));
    }(_h), i.push(_h), l = _r ? JSON.parse(s.readFileSync(_h, "utf8")) : require(t["extends"]), delete t["extends"], l = n(l, s.path.dirname(_h), a, s);
  }

  return i = [], a ? r(l, t) : Object.assign({}, l, t);
}

function r(t, e) {
  var s = {};

  function i(t) {
    return t && "object" == _typeof(t) && !Array.isArray(t);
  }

  Object.assign(s, t);

  for (var _i = 0, _Object$keys = Object.keys(e); _i < _Object$keys.length; _i++) {
    var _n = _Object$keys[_i];
    i(e[_n]) && i(s[_n]) ? s[_n] = r(t[_n], e[_n]) : s[_n] = e[_n];
  }

  return s;
}

function o(t) {
  var e = t.replace(/\s{2,}/g, " ").split(/\s+(?![^[]*]|[^<]*>)/),
      s = /\.*[\][<>]/g,
      i = e.shift();
  if (!i) throw new Error("No command found in: ".concat(t));
  var n = {
    cmd: i.replace(s, ""),
    demanded: [],
    optional: []
  };
  return e.forEach(function (t, i) {
    var r = !1;
    t = t.replace(/\s/g, ""), /\.+[\]>]/.test(t) && i === e.length - 1 && (r = !0), /^\[/.test(t) ? n.optional.push({
      cmd: t.replace(s, "").split("|"),
      variadic: r
    }) : n.demanded.push({
      cmd: t.replace(s, "").split("|"),
      variadic: r
    });
  }), n;
}

var a = ["first", "second", "third", "fourth", "fifth", "sixth"];

function h(t, s, i) {
  try {
    var _n2 = 0;

    var _ref = "object" == _typeof(t) ? [{
      demanded: [],
      optional: []
    }, t, s] : [o("cmd ".concat(t)), s, i],
        _ref2 = _slicedToArray(_ref, 3),
        _r2 = _ref2[0],
        _a = _ref2[1],
        _h2 = _ref2[2],
        _f = [].slice.call(_a);

    for (; _f.length && void 0 === _f[_f.length - 1];) {
      _f.pop();
    }

    var _d = _h2 || _f.length;

    if (_d < _r2.demanded.length) throw new e("Not enough arguments provided. Expected ".concat(_r2.demanded.length, " but received ").concat(_f.length, "."));

    var _u = _r2.demanded.length + _r2.optional.length;

    if (_d > _u) throw new e("Too many arguments provided. Expected max ".concat(_u, " but received ").concat(_d, "."));
    _r2.demanded.forEach(function (t) {
      var e = l(_f.shift());
      0 === t.cmd.filter(function (t) {
        return t === e || "*" === t;
      }).length && c(e, t.cmd, _n2), _n2 += 1;
    }), _r2.optional.forEach(function (t) {
      if (0 === _f.length) return;
      var e = l(_f.shift());
      0 === t.cmd.filter(function (t) {
        return t === e || "*" === t;
      }).length && c(e, t.cmd, _n2), _n2 += 1;
    });
  } catch (t) {
    console.warn(t.stack);
  }
}

function l(t) {
  return Array.isArray(t) ? "array" : null === t ? "null" : _typeof(t);
}

function c(t, s, i) {
  throw new e("Invalid ".concat(a[i] || "manyith", " argument. Expected ").concat(s.join(" or "), " but received ").concat(t, "."));
}

function f(t) {
  return !!t && !!t.then && "function" == typeof t.then;
}

function d(t, e, s, i) {
  s.assert.notStrictEqual(t, e, i);
}

function u(t, e) {
  e.assert.strictEqual(_typeof(t), "string");
}

function p(t) {
  return Object.keys(t);
}

function g() {
  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
    return !0;
  };
  var s = {};
  return p(t).forEach(function (i) {
    e(i, t[i]) && (s[i] = t[i]);
  }), s;
}

function m() {
  return process.versions.electron && !process.defaultApp ? 0 : 1;
}

function y() {
  return process.argv[m()];
}

var b = Object.freeze({
  __proto__: null,
  hideBin: function hideBin(t) {
    return t.slice(m() + 1);
  },
  getProcessArgvBin: y
});

function v(t, e, s, i) {
  if ("a" === s && !i) throw new TypeError("Private accessor was defined without a getter");
  if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return "m" === s ? i : "a" === s ? i.call(t) : i ? i.value : e.get(t);
}

function O(t, e, s, i, n) {
  if ("m" === i) throw new TypeError("Private method is not writable");
  if ("a" === i && !n) throw new TypeError("Private accessor was defined without a setter");
  if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return "a" === i ? n.call(t, s) : n ? n.value = s : e.set(t, s), s;
}

var w = /*#__PURE__*/function () {
  function w(t) {
    _classCallCheck(this, w);

    this.globalMiddleware = [], this.frozens = [], this.yargs = t;
  }

  _createClass(w, [{
    key: "addMiddleware",
    value: function addMiddleware(t, e) {
      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;

      if (h("<array|function> [boolean] [boolean] [boolean]", [t, e, s], arguments.length), Array.isArray(t)) {
        for (var _i2 = 0; _i2 < t.length; _i2++) {
          if ("function" != typeof t[_i2]) throw Error("middleware must be a function");
          var _n3 = t[_i2];
          _n3.applyBeforeValidation = e, _n3.global = s;
        }

        Array.prototype.push.apply(this.globalMiddleware, t);
      } else if ("function" == typeof t) {
        var _n4 = t;
        _n4.applyBeforeValidation = e, _n4.global = s, _n4.mutates = i, this.globalMiddleware.push(t);
      }

      return this.yargs;
    }
  }, {
    key: "addCoerceMiddleware",
    value: function addCoerceMiddleware(t, e) {
      var s = this.yargs.getAliases();
      return this.globalMiddleware = this.globalMiddleware.filter(function (t) {
        var i = [].concat(_toConsumableArray(s[e] || []), [e]);
        return !t.option || !i.includes(t.option);
      }), t.option = e, this.addMiddleware(t, !0, !0, !0);
    }
  }, {
    key: "getMiddleware",
    value: function getMiddleware() {
      return this.globalMiddleware;
    }
  }, {
    key: "freeze",
    value: function freeze() {
      this.frozens.push(_toConsumableArray(this.globalMiddleware));
    }
  }, {
    key: "unfreeze",
    value: function unfreeze() {
      var t = this.frozens.pop();
      void 0 !== t && (this.globalMiddleware = t);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.globalMiddleware = this.globalMiddleware.filter(function (t) {
        return t.global;
      });
    }
  }]);

  return w;
}();

function C(t, e, s, i) {
  return s.reduce(function (t, s) {
    if (s.applyBeforeValidation !== i) return t;

    if (s.mutates) {
      if (s.applied) return t;
      s.applied = !0;
    }

    if (f(t)) return t.then(function (t) {
      return Promise.all([t, s(t, e)]);
    }).then(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          t = _ref4[0],
          e = _ref4[1];

      return Object.assign(t, e);
    });
    {
      var _i3 = s(t, e);

      return f(_i3) ? _i3.then(function (e) {
        return Object.assign(t, e);
      }) : Object.assign(t, _i3);
    }
  }, t);
}

function j(t, e) {
  var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (t) {
    throw t;
  };

  try {
    var _s = "function" == typeof t ? t() : t;

    return f(_s) ? _s.then(function (t) {
      return e(t);
    }) : e(_s);
  } catch (t) {
    return s(t);
  }
}

var _ = /(^\*)|(^\$0)/;

var M = /*#__PURE__*/function () {
  function M(t, e, s, i) {
    _classCallCheck(this, M);

    this.requireCache = new Set(), this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = i, this.usage = t, this.globalMiddleware = s, this.validation = e;
  }

  _createClass(M, [{
    key: "addDirectory",
    value: function addDirectory(t, e, s, i) {
      var _this2 = this;

      "boolean" != typeof (i = i || {}).recurse && (i.recurse = !1), Array.isArray(i.extensions) || (i.extensions = ["js"]);
      var n = "function" == typeof i.visit ? i.visit : function (t) {
        return t;
      };
      i.visit = function (t, e, s) {
        var i = n(t, e, s);

        if (i) {
          if (_this2.requireCache.has(e)) return i;
          _this2.requireCache.add(e), _this2.addHandler(i);
        }

        return i;
      }, this.shim.requireDirectory({
        require: e,
        filename: s
      }, t, i);
    }
  }, {
    key: "addHandler",
    value: function addHandler(t, e, s, i, n, r) {
      var _this3 = this;

      var a = [];

      var h = function (t) {
        return t ? t.map(function (t) {
          return t.applyBeforeValidation = !1, t;
        }) : [];
      }(n);

      if (i = i || function () {}, Array.isArray(t)) {
        if (function (t) {
          return t.every(function (t) {
            return "string" == typeof t;
          });
        }(t)) {
          var _t2 = t;

          var _t3 = _toArray(_t2);

          t = _t3[0];
          a = _t3.slice(1);
        } else {
          var _iterator = _createForOfIteratorHelper(t),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _e = _step.value;
              this.addHandler(_e);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } else {
        if (function (t) {
          return "object" == _typeof(t) && !Array.isArray(t);
        }(t)) {
          var _e2 = Array.isArray(t.command) || "string" == typeof t.command ? t.command : this.moduleName(t);

          return t.aliases && (_e2 = [].concat(_e2).concat(t.aliases)), void this.addHandler(_e2, this.extractDesc(t), t.builder, t.handler, t.middlewares, t.deprecated);
        }

        if (k(s)) return void this.addHandler([t].concat(a), e, s.builder, s.handler, s.middlewares, s.deprecated);
      }

      if ("string" == typeof t) {
        var _n5 = o(t);

        a = a.map(function (t) {
          return o(t).cmd;
        });

        var _l = !1;

        var _c = [_n5.cmd].concat(a).filter(function (t) {
          return !_.test(t) || (_l = !0, !1);
        });

        0 === _c.length && _l && _c.push("$0"), _l && (_n5.cmd = _c[0], a = _c.slice(1), t = t.replace(_, _n5.cmd)), a.forEach(function (t) {
          _this3.aliasMap[t] = _n5.cmd;
        }), !1 !== e && this.usage.command(t, e, _l, a, r), this.handlers[_n5.cmd] = {
          original: t,
          description: e,
          handler: i,
          builder: s || {},
          middlewares: h,
          deprecated: r,
          demanded: _n5.demanded,
          optional: _n5.optional
        }, _l && (this.defaultCommand = this.handlers[_n5.cmd]);
      }
    }
  }, {
    key: "getCommandHandlers",
    value: function getCommandHandlers() {
      return this.handlers;
    }
  }, {
    key: "getCommands",
    value: function getCommands() {
      return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
    }
  }, {
    key: "hasDefaultCommand",
    value: function hasDefaultCommand() {
      return !!this.defaultCommand;
    }
  }, {
    key: "runCommand",
    value: function runCommand(t, e, s, i, n, r) {
      var _this4 = this;

      var o = this.handlers[t] || this.handlers[this.aliasMap[t]] || this.defaultCommand,
          a = e.getInternalMethods().getContext(),
          h = a.commands.slice(),
          l = !t;
      t && (a.commands.push(t), a.fullCommands.push(o.original));
      var c = this.applyBuilderUpdateUsageAndParse(l, o, e, s.aliases, h, i, n, r);
      return f(c) ? c.then(function (t) {
        return _this4.applyMiddlewareAndGetResult(l, o, t.innerArgv, a, n, t.aliases, e);
      }) : this.applyMiddlewareAndGetResult(l, o, c.innerArgv, a, n, c.aliases, e);
    }
  }, {
    key: "applyBuilderUpdateUsageAndParse",
    value: function applyBuilderUpdateUsageAndParse(t, e, s, i, n, r, o, a) {
      var _this5 = this;

      var h = e.builder;
      var l = s;

      if (E(h)) {
        var _c2 = h(s.getInternalMethods().reset(i), a);

        if (f(_c2)) return _c2.then(function (i) {
          var a;
          return l = (a = i) && "function" == typeof a.getInternalMethods ? i : s, _this5.parseAndUpdateUsage(t, e, l, n, r, o);
        });
      } else (function (t) {
        return "object" == _typeof(t);
      })(h) && (l = s.getInternalMethods().reset(i), Object.keys(e.builder).forEach(function (t) {
        l.option(t, h[t]);
      }));

      return this.parseAndUpdateUsage(t, e, l, n, r, o);
    }
  }, {
    key: "parseAndUpdateUsage",
    value: function parseAndUpdateUsage(t, e, s, i, n, r) {
      t && s.getInternalMethods().getUsageInstance().unfreeze(), this.shouldUpdateUsage(s) && s.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i, e), e.description);
      var o = s.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, !0, n, r);
      return f(o) ? o.then(function (t) {
        return {
          aliases: s.parsed.aliases,
          innerArgv: t
        };
      }) : {
        aliases: s.parsed.aliases,
        innerArgv: o
      };
    }
  }, {
    key: "shouldUpdateUsage",
    value: function shouldUpdateUsage(t) {
      return !t.getInternalMethods().getUsageInstance().getUsageDisabled() && 0 === t.getInternalMethods().getUsageInstance().getUsage().length;
    }
  }, {
    key: "usageFromParentCommandsCommandHandler",
    value: function usageFromParentCommandsCommandHandler(t, e) {
      var s = _.test(e.original) ? e.original.replace(_, "").trim() : e.original,
          i = t.filter(function (t) {
        return !_.test(t);
      });
      return i.push(s), "$0 ".concat(i.join(" "));
    }
  }, {
    key: "applyMiddlewareAndGetResult",
    value: function applyMiddlewareAndGetResult(t, e, s, i, n, r, o) {
      var a = {};
      if (n) return s;
      o.getInternalMethods().getHasOutput() || (a = this.populatePositionals(e, s, i, o));
      var h = this.globalMiddleware.getMiddleware().slice(0).concat(e.middlewares);

      if (s = C(s, o, h, !0), !o.getInternalMethods().getHasOutput()) {
        var _e3 = o.getInternalMethods().runValidation(r, a, o.parsed.error, t);

        s = j(s, function (t) {
          return _e3(t), t;
        });
      }

      if (e.handler && !o.getInternalMethods().getHasOutput()) {
        o.getInternalMethods().setHasOutput();

        var _i4 = !!o.getOptions().configuration["populate--"];

        o.getInternalMethods().postProcess(s, _i4, !1, !1), s = j(s = C(s, o, h, !1), function (t) {
          var s = e.handler(t);
          return f(s) ? s.then(function () {
            return t;
          }) : t;
        }), t || o.getInternalMethods().getUsageInstance().cacheHelpMessage(), f(s) && !o.getInternalMethods().hasParseCallback() && s["catch"](function (t) {
          try {
            o.getInternalMethods().getUsageInstance().fail(null, t);
          } catch (t) {}
        });
      }

      return t || (i.commands.pop(), i.fullCommands.pop()), s;
    }
  }, {
    key: "populatePositionals",
    value: function populatePositionals(t, e, s, i) {
      e._ = e._.slice(s.commands.length);
      var n = t.demanded.slice(0),
          r = t.optional.slice(0),
          o = {};

      for (this.validation.positionalCount(n.length, e._.length); n.length;) {
        var _t4 = n.shift();

        this.populatePositional(_t4, e, o);
      }

      for (; r.length;) {
        var _t5 = r.shift();

        this.populatePositional(_t5, e, o);
      }

      return e._ = s.commands.concat(e._.map(function (t) {
        return "" + t;
      })), this.postProcessPositionals(e, o, this.cmdToParseOptions(t.original), i), o;
    }
  }, {
    key: "populatePositional",
    value: function populatePositional(t, e, s) {
      var i = t.cmd[0];
      t.variadic ? s[i] = e._.splice(0).map(String) : e._.length && (s[i] = [String(e._.shift())]);
    }
  }, {
    key: "cmdToParseOptions",
    value: function cmdToParseOptions(t) {
      var e = {
        array: [],
        "default": {},
        alias: {},
        demand: {}
      },
          s = o(t);
      return s.demanded.forEach(function (t) {
        var _t$cmd = _toArray(t.cmd),
            s = _t$cmd[0],
            i = _t$cmd.slice(1);

        t.variadic && (e.array.push(s), e["default"][s] = []), e.alias[s] = i, e.demand[s] = !0;
      }), s.optional.forEach(function (t) {
        var _t$cmd2 = _toArray(t.cmd),
            s = _t$cmd2[0],
            i = _t$cmd2.slice(1);

        t.variadic && (e.array.push(s), e["default"][s] = []), e.alias[s] = i;
      }), e;
    }
  }, {
    key: "postProcessPositionals",
    value: function postProcessPositionals(t, e, s, i) {
      var n = Object.assign({}, i.getOptions());
      n["default"] = Object.assign(s["default"], n["default"]);

      for (var _i5 = 0, _Object$keys2 = Object.keys(s.alias); _i5 < _Object$keys2.length; _i5++) {
        var _t6 = _Object$keys2[_i5];
        n.alias[_t6] = (n.alias[_t6] || []).concat(s.alias[_t6]);
      }

      n.array = n.array.concat(s.array), n.config = {};
      var r = [];
      if (Object.keys(e).forEach(function (t) {
        e[t].map(function (e) {
          n.configuration["unknown-options-as-args"] && (n.key[t] = !0), r.push("--".concat(t)), r.push(e);
        });
      }), !r.length) return;
      var o = Object.assign({}, n.configuration, {
        "populate--": !1
      }),
          a = this.shim.Parser.detailed(r, Object.assign({}, n, {
        configuration: o
      }));
      if (a.error) i.getInternalMethods().getUsageInstance().fail(a.error.message, a.error);else {
        var _s2 = Object.keys(e);

        Object.keys(e).forEach(function (t) {
          _s2.push.apply(_s2, _toConsumableArray(a.aliases[t]));
        });
        var _n6 = i.getOptions()["default"];
        Object.keys(a.argv).forEach(function (i) {
          _s2.includes(i) && (e[i] || (e[i] = a.argv[i]), !Object.prototype.hasOwnProperty.call(_n6, i) && Object.prototype.hasOwnProperty.call(t, i) && Object.prototype.hasOwnProperty.call(a.argv, i) && (Array.isArray(t[i]) || Array.isArray(a.argv[i])) ? t[i] = [].concat(t[i], a.argv[i]) : t[i] = a.argv[i]);
        });
      }
    }
  }, {
    key: "runDefaultBuilderOn",
    value: function runDefaultBuilderOn(t) {
      if (!this.defaultCommand) return;

      if (this.shouldUpdateUsage(t)) {
        var _e4 = _.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");

        t.getInternalMethods().getUsageInstance().usage(_e4, this.defaultCommand.description);
      }

      var e = this.defaultCommand.builder;
      if (E(e)) return e(t, !0);
      k(e) || Object.keys(e).forEach(function (s) {
        t.option(s, e[s]);
      });
    }
  }, {
    key: "moduleName",
    value: function moduleName(t) {
      var e = function (t) {
        if ("undefined" == typeof require) return null;

        for (var _e5, _s3 = 0, _i6 = Object.keys(require.cache); _s3 < _i6.length; _s3++) {
          if (_e5 = require.cache[_i6[_s3]], _e5.exports === t) return _e5;
        }

        return null;
      }(t);

      if (!e) throw new Error("No command name given for module: ".concat(this.shim.inspect(t)));
      return this.commandFromFilename(e.filename);
    }
  }, {
    key: "commandFromFilename",
    value: function commandFromFilename(t) {
      return this.shim.path.basename(t, this.shim.path.extname(t));
    }
  }, {
    key: "extractDesc",
    value: function extractDesc(_ref5) {
      var t = _ref5.describe,
          e = _ref5.description,
          s = _ref5.desc;

      for (var _i7 = 0, _arr = [t, e, s]; _i7 < _arr.length; _i7++) {
        var _i8 = _arr[_i7];
        if ("string" == typeof _i8 || !1 === _i8) return _i8;
        d(_i8, !0, this.shim);
      }

      return !1;
    }
  }, {
    key: "freeze",
    value: function freeze() {
      this.frozens.push({
        handlers: this.handlers,
        aliasMap: this.aliasMap,
        defaultCommand: this.defaultCommand
      });
    }
  }, {
    key: "unfreeze",
    value: function unfreeze() {
      var _t7;

      var t = this.frozens.pop();
      d(t, void 0, this.shim), (_t7 = t, this.handlers = _t7.handlers, this.aliasMap = _t7.aliasMap, this.defaultCommand = _t7.defaultCommand, _t7);
    }
  }, {
    key: "reset",
    value: function reset() {
      return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = void 0, this.requireCache = new Set(), this;
    }
  }]);

  return M;
}();

function k(t) {
  return "object" == _typeof(t) && !!t.builder && "function" == typeof t.handler;
}

function E(t) {
  return "function" == typeof t;
}

function x(t) {
  "undefined" != typeof process && [process.stdout, process.stderr].forEach(function (e) {
    var s = e;
    s._handle && s.isTTY && "function" == typeof s._handle.setBlocking && s._handle.setBlocking(t);
  });
}

function A(t) {
  return "boolean" == typeof t;
}

function S(t, s) {
  var i = s.y18n.__,
      n = {},
      r = [];

  n.failFn = function (t) {
    r.push(t);
  };

  var o = null,
      a = !0;

  n.showHelpOnFail = function () {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    var e = arguments.length > 1 ? arguments[1] : undefined;

    var _ref6 = "string" == typeof t ? [!0, t] : [t, e],
        _ref7 = _slicedToArray(_ref6, 2),
        s = _ref7[0],
        i = _ref7[1];

    return o = i, a = s, n;
  };

  var h = !1;

  n.fail = function (s, i) {
    var l = t.getInternalMethods().getLoggerInstance();

    if (!r.length) {
      if (t.getExitProcess() && x(!0), h || (h = !0, a && (t.showHelp("error"), l.error()), (s || i) && l.error(s || i), o && ((s || i) && l.error(""), l.error(o))), i = i || new e(s), t.getExitProcess()) return t.exit(1);
      if (t.getInternalMethods().hasParseCallback()) return t.exit(1, i);
      throw i;
    }

    for (var _t8 = r.length - 1; _t8 >= 0; --_t8) {
      var _e6 = r[_t8];

      if (A(_e6)) {
        if (i) throw i;
        if (s) throw Error(s);
      } else _e6(s, i, n);
    }
  };

  var l = [],
      c = !1;
  n.usage = function (t, e) {
    return null === t ? (c = !0, l = [], n) : (c = !1, l.push([t, e || ""]), n);
  }, n.getUsage = function () {
    return l;
  }, n.getUsageDisabled = function () {
    return c;
  }, n.getPositionalGroupName = function () {
    return i("Positionals:");
  };
  var f = [];

  n.example = function (t, e) {
    f.push([t, e || ""]);
  };

  var d = [];
  n.command = function (t, e, s, i) {
    var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    s && (d = d.map(function (t) {
      return t[2] = !1, t;
    })), d.push([t, e || "", s, i, n]);
  }, n.getCommands = function () {
    return d;
  };
  var u = {};
  n.describe = function (t, e) {
    Array.isArray(t) ? t.forEach(function (t) {
      n.describe(t, e);
    }) : "object" == _typeof(t) ? Object.keys(t).forEach(function (e) {
      n.describe(e, t[e]);
    }) : u[t] = e;
  }, n.getDescriptions = function () {
    return u;
  };
  var p = [];

  n.epilog = function (t) {
    p.push(t);
  };

  var m,
      y = !1;

  function b() {
    return y || (m = function () {
      var t = 80;
      return s.process.stdColumns ? Math.min(t, s.process.stdColumns) : t;
    }(), y = !0), m;
  }

  n.wrap = function (t) {
    y = !0, m = t;
  };

  var v = "__yargsString__:";

  function O(t, e, i) {
    var n = 0;
    return Array.isArray(t) || (t = Object.values(t).map(function (t) {
      return [t];
    })), t.forEach(function (t) {
      n = Math.max(s.stringWidth(i ? "".concat(i, " ").concat(I(t[0])) : I(t[0])) + $(t[0]), n);
    }), e && (n = Math.min(n, parseInt((.5 * e).toString(), 10))), n;
  }

  var w;

  function C(e) {
    return t.getOptions().hiddenOptions.indexOf(e) < 0 || t.parsed.argv[t.getOptions().showHiddenOpt];
  }

  function j(t, e) {
    var s = "[".concat(i("default:"), " ");
    if (void 0 === t && !e) return null;
    if (e) s += e;else switch (_typeof(t)) {
      case "string":
        s += "\"".concat(t, "\"");
        break;

      case "object":
        s += JSON.stringify(t);
        break;

      default:
        s += t;
    }
    return "".concat(s, "]");
  }

  n.deferY18nLookup = function (t) {
    return v + t;
  }, n.help = function () {
    if (w) return w;
    !function () {
      var e = t.getDemandedOptions(),
          s = t.getOptions();
      (Object.keys(s.alias) || []).forEach(function (i) {
        s.alias[i].forEach(function (r) {
          u[r] && n.describe(i, u[r]), r in e && t.demandOption(i, e[r]), s["boolean"].includes(r) && t["boolean"](i), s.count.includes(r) && t.count(i), s.string.includes(r) && t.string(i), s.normalize.includes(r) && t.normalize(i), s.array.includes(r) && t.array(i), s.number.includes(r) && t.number(i);
        });
      });
    }();
    var e = t.customScriptName ? t.$0 : s.path.basename(t.$0),
        r = t.getDemandedOptions(),
        o = t.getDemandedCommands(),
        a = t.getDeprecatedOptions(),
        h = t.getGroups(),
        g = t.getOptions();
    var m = [];
    m = m.concat(Object.keys(u)), m = m.concat(Object.keys(r)), m = m.concat(Object.keys(o)), m = m.concat(Object.keys(g["default"])), m = m.filter(C), m = Object.keys(m.reduce(function (t, e) {
      return "_" !== e && (t[e] = !0), t;
    }, {}));

    var y = b(),
        _ = s.cliui({
      width: y,
      wrap: !!y
    });

    if (!c) if (l.length) l.forEach(function (t) {
      _.div({
        text: "".concat(t[0].replace(/\$0/g, e))
      }), t[1] && _.div({
        text: "".concat(t[1]),
        padding: [1, 0, 0, 0]
      });
    }), _.div();else if (d.length) {
      var _t9 = null;
      _t9 = o._ ? "".concat(e, " <").concat(i("command"), ">\n") : "".concat(e, " [").concat(i("command"), "]\n"), _.div("".concat(_t9));
    }

    if (d.length > 1 || 1 === d.length && !d[0][2]) {
      _.div(i("Commands:"));

      var _s4 = t.getInternalMethods().getContext(),
          _n7 = _s4.commands.length ? "".concat(_s4.commands.join(" "), " ") : "";

      !0 === t.getInternalMethods().getParserConfiguration()["sort-commands"] && (d = d.sort(function (t, e) {
        return t[0].localeCompare(e[0]);
      }));

      var _r3 = e ? "".concat(e, " ") : "";

      d.forEach(function (t) {
        var s = "".concat(_r3).concat(_n7).concat(t[0].replace(/^\$0 ?/, ""));

        _.span({
          text: s,
          padding: [0, 2, 0, 2],
          width: O(d, y, "".concat(e).concat(_n7)) + 4
        }, {
          text: t[1]
        });

        var o = [];
        t[2] && o.push("[".concat(i("default"), "]")), t[3] && t[3].length && o.push("[".concat(i("aliases:"), " ").concat(t[3].join(", "), "]")), t[4] && ("string" == typeof t[4] ? o.push("[".concat(i("deprecated: %s", t[4]), "]")) : o.push("[".concat(i("deprecated"), "]"))), o.length ? _.div({
          text: o.join(" "),
          padding: [0, 0, 0, 2],
          align: "right"
        }) : _.div();
      }), _.div();
    }

    var M = (Object.keys(g.alias) || []).concat(Object.keys(t.parsed.newAliases) || []);
    m = m.filter(function (e) {
      return !t.parsed.newAliases[e] && M.every(function (t) {
        return -1 === (g.alias[t] || []).indexOf(e);
      });
    });
    var k = i("Options:");
    h[k] || (h[k] = []), function (t, e, s, i) {
      var n = [],
          r = null;
      Object.keys(s).forEach(function (t) {
        n = n.concat(s[t]);
      }), t.forEach(function (t) {
        r = [t].concat(e[t]), r.some(function (t) {
          return -1 !== n.indexOf(t);
        }) || s[i].push(t);
      });
    }(m, g.alias, h, k);

    var E = function E(t) {
      return /^--/.test(I(t));
    },
        x = Object.keys(h).filter(function (t) {
      return h[t].length > 0;
    }).map(function (t) {
      return {
        groupName: t,
        normalizedKeys: h[t].filter(C).map(function (t) {
          if (M.includes(t)) return t;

          for (var _e7, _s5 = 0; void 0 !== (_e7 = M[_s5]); _s5++) {
            if ((g.alias[_e7] || []).includes(t)) return _e7;
          }

          return t;
        })
      };
    }).filter(function (_ref8) {
      var t = _ref8.normalizedKeys;
      return t.length > 0;
    }).map(function (_ref9) {
      var t = _ref9.groupName,
          e = _ref9.normalizedKeys;
      var s = e.reduce(function (e, s) {
        return e[s] = [s].concat(g.alias[s] || []).map(function (e) {
          return t === n.getPositionalGroupName() ? e : (/^[0-9]$/.test(e) ? g["boolean"].includes(s) ? "-" : "--" : e.length > 1 ? "--" : "-") + e;
        }).sort(function (t, e) {
          return E(t) === E(e) ? 0 : E(t) ? 1 : -1;
        }).join(", "), e;
      }, {});
      return {
        groupName: t,
        normalizedKeys: e,
        switches: s
      };
    });

    if (x.filter(function (_ref10) {
      var t = _ref10.groupName;
      return t !== n.getPositionalGroupName();
    }).some(function (_ref11) {
      var t = _ref11.normalizedKeys,
          e = _ref11.switches;
      return !t.every(function (t) {
        return E(e[t]);
      });
    }) && x.filter(function (_ref12) {
      var t = _ref12.groupName;
      return t !== n.getPositionalGroupName();
    }).forEach(function (_ref13) {
      var t = _ref13.normalizedKeys,
          e = _ref13.switches;
      t.forEach(function (t) {
        var s, i;
        E(e[t]) && (e[t] = (s = e[t], i = "-x, ".length, P(s) ? {
          text: s.text,
          indentation: s.indentation + i
        } : {
          text: s,
          indentation: i
        }));
      });
    }), x.forEach(function (_ref14) {
      var t = _ref14.groupName,
          e = _ref14.normalizedKeys,
          s = _ref14.switches;
      _.div(t), e.forEach(function (t) {
        var e = s[t];
        var o = u[t] || "",
            h = null;
        o.includes(v) && (o = i(o.substring(v.length))), g["boolean"].includes(t) && (h = "[".concat(i("boolean"), "]")), g.count.includes(t) && (h = "[".concat(i("count"), "]")), g.string.includes(t) && (h = "[".concat(i("string"), "]")), g.normalize.includes(t) && (h = "[".concat(i("string"), "]")), g.array.includes(t) && (h = "[".concat(i("array"), "]")), g.number.includes(t) && (h = "[".concat(i("number"), "]"));
        var l = [t in a ? (c = a[t], "string" == typeof c ? "[".concat(i("deprecated: %s", c), "]") : "[".concat(i("deprecated"), "]")) : null, h, t in r ? "[".concat(i("required"), "]") : null, g.choices && g.choices[t] ? "[".concat(i("choices:"), " ").concat(n.stringifiedValues(g.choices[t]), "]") : null, j(g["default"][t], g.defaultDescription[t])].filter(Boolean).join(" ");
        var c;
        _.span({
          text: I(e),
          padding: [0, 2, 0, 2 + $(e)],
          width: O(s, y) + 4
        }, o), l ? _.div({
          text: l,
          padding: [0, 0, 0, 2],
          align: "right"
        }) : _.div();
      }), _.div();
    }), f.length && (_.div(i("Examples:")), f.forEach(function (t) {
      t[0] = t[0].replace(/\$0/g, e);
    }), f.forEach(function (t) {
      "" === t[1] ? _.div({
        text: t[0],
        padding: [0, 2, 0, 2]
      }) : _.div({
        text: t[0],
        padding: [0, 2, 0, 2],
        width: O(f, y) + 4
      }, {
        text: t[1]
      });
    }), _.div()), p.length > 0) {
      var _t10 = p.map(function (t) {
        return t.replace(/\$0/g, e);
      }).join("\n");

      _.div("".concat(_t10, "\n"));
    }

    return _.toString().replace(/\s*$/, "");
  }, n.cacheHelpMessage = function () {
    w = this.help();
  }, n.clearCachedHelpMessage = function () {
    w = void 0;
  }, n.hasCachedHelpMessage = function () {
    return !!w;
  }, n.showHelp = function (e) {
    var s = t.getInternalMethods().getLoggerInstance();
    e || (e = "error");
    ("function" == typeof e ? e : s[e])(n.help());
  }, n.functionDescription = function (t) {
    return ["(", t.name ? s.Parser.decamelize(t.name, "-") : i("generated-value"), ")"].join("");
  }, n.stringifiedValues = function (t, e) {
    var s = "";
    var i = e || ", ",
        n = [].concat(t);
    return t && n.length ? (n.forEach(function (t) {
      s.length && (s += i), s += JSON.stringify(t);
    }), s) : s;
  };
  var _ = null;
  n.version = function (t) {
    _ = t;
  }, n.showVersion = function (e) {
    var s = t.getInternalMethods().getLoggerInstance();
    e || (e = "error");
    ("function" == typeof e ? e : s[e])(_);
  }, n.reset = function (t) {
    return o = null, h = !1, l = [], c = !1, p = [], f = [], d = [], u = g(u, function (e) {
      return !t[e];
    }), n;
  };
  var M = [];
  return n.freeze = function () {
    M.push({
      failMessage: o,
      failureOutput: h,
      usages: l,
      usageDisabled: c,
      epilogs: p,
      examples: f,
      commands: d,
      descriptions: u
    });
  }, n.unfreeze = function () {
    var _t11;

    var t = M.pop();
    t && (_t11 = t, o = _t11.failMessage, h = _t11.failureOutput, l = _t11.usages, c = _t11.usageDisabled, p = _t11.epilogs, f = _t11.examples, d = _t11.commands, u = _t11.descriptions, _t11);
  }, n;
}

function P(t) {
  return "object" == _typeof(t);
}

function $(t) {
  return P(t) ? t.indentation : 0;
}

function I(t) {
  return P(t) ? t.text : t;
}

var D = /*#__PURE__*/function () {
  function D(t, e, s, i) {
    _classCallCheck(this, D);

    var n, r, o;
    this.yargs = t, this.usage = e, this.command = s, this.shim = i, this.completionKey = "get-yargs-completions", this.aliases = null, this.customCompletionFunction = null, this.zshShell = null !== (o = (null === (n = this.shim.getEnv("SHELL")) || void 0 === n ? void 0 : n.includes("zsh")) || (null === (r = this.shim.getEnv("ZSH_NAME")) || void 0 === r ? void 0 : r.includes("zsh"))) && void 0 !== o && o;
  }

  _createClass(D, [{
    key: "defaultCompletion",
    value: function defaultCompletion(t, e, s, i) {
      var n = this.command.getCommandHandlers();

      for (var _e8 = 0, _s6 = t.length; _e8 < _s6; ++_e8) {
        if (n[t[_e8]] && n[t[_e8]].builder) {
          var _s7 = n[t[_e8]].builder;

          if (E(_s7)) {
            var _t12 = this.yargs.getInternalMethods().reset();

            return _s7(_t12, !0), _t12.argv;
          }
        }
      }

      var r = [];
      this.commandCompletions(r, t, s), this.optionCompletions(r, t, e, s), this.choicesCompletions(r, t, e, s), i(null, r);
    }
  }, {
    key: "commandCompletions",
    value: function commandCompletions(t, e, s) {
      var _this6 = this;

      var i = this.yargs.getInternalMethods().getContext().commands;
      s.match(/^-/) || i[i.length - 1] === s || this.previousArgHasChoices(e) || this.usage.getCommands().forEach(function (s) {
        var i = o(s[0]).cmd;
        if (-1 === e.indexOf(i)) if (_this6.zshShell) {
          var _e9 = s[1] || "";

          t.push(i.replace(/:/g, "\\:") + ":" + _e9);
        } else t.push(i);
      });
    }
  }, {
    key: "optionCompletions",
    value: function optionCompletions(t, e, s, i) {
      var _this7 = this;

      if ((i.match(/^-/) || "" === i && 0 === t.length) && !this.previousArgHasChoices(e)) {
        var _n8 = this.yargs.getOptions(),
            _r4 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];

        Object.keys(_n8.key).forEach(function (o) {
          var a = !!_n8.configuration["boolean-negation"] && _n8["boolean"].includes(o);

          _r4.includes(o) || _this7.argsContainKey(e, s, o, a) || (_this7.completeOptionKey(o, t, i), a && _n8["default"][o] && _this7.completeOptionKey("no-".concat(o), t, i));
        });
      }
    }
  }, {
    key: "choicesCompletions",
    value: function choicesCompletions(t, e, s, i) {
      if (this.previousArgHasChoices(e)) {
        var _s8 = this.getPreviousArgChoices(e);

        _s8 && _s8.length > 0 && t.push.apply(t, _toConsumableArray(_s8));
      }
    }
  }, {
    key: "getPreviousArgChoices",
    value: function getPreviousArgChoices(t) {
      if (t.length < 1) return;
      var e = t[t.length - 1],
          s = "";
      if (!e.startsWith("--") && t.length > 1 && (s = e, e = t[t.length - 2]), !e.startsWith("--")) return;
      var i = e.replace(/-/g, ""),
          n = this.yargs.getOptions();
      return Object.keys(n.key).some(function (t) {
        return t === i;
      }) && Array.isArray(n.choices[i]) ? n.choices[i].filter(function (t) {
        return !s || t.startsWith(s);
      }) : void 0;
    }
  }, {
    key: "previousArgHasChoices",
    value: function previousArgHasChoices(t) {
      var e = this.getPreviousArgChoices(t);
      return void 0 !== e && e.length > 0;
    }
  }, {
    key: "argsContainKey",
    value: function argsContainKey(t, e, s, i) {
      if (-1 !== t.indexOf("--".concat(s))) return !0;
      if (i && -1 !== t.indexOf("--no-".concat(s))) return !0;

      if (this.aliases) {
        var _iterator2 = _createForOfIteratorHelper(this.aliases[s]),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _t13 = _step2.value;
            if (void 0 !== e[_t13]) return !0;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      return !1;
    }
  }, {
    key: "completeOptionKey",
    value: function completeOptionKey(t, e, s) {
      var i = this.usage.getDescriptions(),
          n = !/^--/.test(s) && function (t) {
        return /^[^0-9]$/.test(t);
      }(t) ? "-" : "--";

      if (this.zshShell) {
        var _s9 = i[t] || "";

        e.push(n + "".concat(t.replace(/:/g, "\\:"), ":").concat(_s9.replace("__yargsString__:", "")));
      } else e.push(n + t);
    }
  }, {
    key: "customCompletion",
    value: function customCompletion(t, e, s, i) {
      var _this8 = this;

      if (d(this.customCompletionFunction, null, this.shim), this.customCompletionFunction.length < 3) {
        var _t14 = this.customCompletionFunction(s, e);

        return f(_t14) ? _t14.then(function (t) {
          _this8.shim.process.nextTick(function () {
            i(null, t);
          });
        })["catch"](function (t) {
          _this8.shim.process.nextTick(function () {
            i(t, void 0);
          });
        }) : i(null, _t14);
      }

      return function (t) {
        return t.length > 3;
      }(this.customCompletionFunction) ? this.customCompletionFunction(s, e, function () {
        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : i;
        return _this8.defaultCompletion(t, e, s, n);
      }, function (t) {
        i(null, t);
      }) : this.customCompletionFunction(s, e, function (t) {
        i(null, t);
      });
    }
  }, {
    key: "getCompletion",
    value: function getCompletion(t, e) {
      var _this9 = this;

      var s = t.length ? t[t.length - 1] : "",
          i = this.yargs.parse(t, !0),
          n = this.customCompletionFunction ? function (i) {
        return _this9.customCompletion(t, i, s, e);
      } : function (i) {
        return _this9.defaultCompletion(t, i, s, e);
      };
      return f(i) ? i.then(n) : n(i);
    }
  }, {
    key: "generateCompletionScript",
    value: function generateCompletionScript(t, e) {
      var s = this.zshShell ? '#compdef {{app_name}}\n###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$\'\n\' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "${words[@]}"))\n  IFS=$si\n  _describe \'values\' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n' : '###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word="${COMP_WORDS[COMP_CWORD]}"\n    args=("${COMP_WORDS[@]}")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions "${args[@]}")\n\n    COMPREPLY=( $(compgen -W "${type_list}" -- ${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ ${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o default -F _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n';
      var i = this.shim.path.basename(t);
      return t.match(/\.js$/) && (t = "./".concat(t)), s = s.replace(/{{app_name}}/g, i), s = s.replace(/{{completion_command}}/g, e), s.replace(/{{app_path}}/g, t);
    }
  }, {
    key: "registerFunction",
    value: function registerFunction(t) {
      this.customCompletionFunction = t;
    }
  }, {
    key: "setParsed",
    value: function setParsed(t) {
      this.aliases = t.aliases;
    }
  }]);

  return D;
}();

function N(t, e) {
  if (0 === t.length) return e.length;
  if (0 === e.length) return t.length;
  var s = [];
  var i, n;

  for (i = 0; i <= e.length; i++) {
    s[i] = [i];
  }

  for (n = 0; n <= t.length; n++) {
    s[0][n] = n;
  }

  for (i = 1; i <= e.length; i++) {
    for (n = 1; n <= t.length; n++) {
      e.charAt(i - 1) === t.charAt(n - 1) ? s[i][n] = s[i - 1][n - 1] : i > 1 && n > 1 && e.charAt(i - 2) === t.charAt(n - 1) && e.charAt(i - 1) === t.charAt(n - 2) ? s[i][n] = s[i - 2][n - 2] + 1 : s[i][n] = Math.min(s[i - 1][n - 1] + 1, Math.min(s[i][n - 1] + 1, s[i - 1][n] + 1));
    }
  }

  return s[e.length][t.length];
}

var H = ["$0", "--", "_"];
var z, q, W, U, F, L, V, T, R, G, K, B, Y, J, Z, X, Q, tt, et, st, it, nt, rt, ot, at, ht, lt, ct, ft, dt, ut, pt, gt;

var mt = Symbol("copyDoubleDash"),
    yt = Symbol("copyDoubleDash"),
    bt = Symbol("deleteFromParserHintObject"),
    vt = Symbol("emitWarning"),
    Ot = Symbol("freeze"),
    wt = Symbol("getDollarZero"),
    Ct = Symbol("getParserConfiguration"),
    jt = Symbol("guessLocale"),
    _t = Symbol("guessVersion"),
    Mt = Symbol("parsePositionalNumbers"),
    kt = Symbol("pkgUp"),
    Et = Symbol("populateParserHintArray"),
    xt = Symbol("populateParserHintSingleValueDictionary"),
    At = Symbol("populateParserHintArrayDictionary"),
    St = Symbol("populateParserHintDictionary"),
    Pt = Symbol("sanitizeKey"),
    $t = Symbol("setKey"),
    It = Symbol("unfreeze"),
    Dt = Symbol("validateAsync"),
    Nt = Symbol("getCommandInstance"),
    Ht = Symbol("getContext"),
    zt = Symbol("getHasOutput"),
    qt = Symbol("getLoggerInstance"),
    Wt = Symbol("getParseContext"),
    Ut = Symbol("getUsageInstance"),
    Ft = Symbol("getValidationInstance"),
    Lt = Symbol("hasParseCallback"),
    Vt = Symbol("postProcess"),
    Tt = Symbol("rebase"),
    Rt = Symbol("reset"),
    Gt = Symbol("runYargsParserAndExecuteCommands"),
    Kt = Symbol("runValidation"),
    Bt = Symbol("setHasOutput"),
    Yt = Symbol("kTrackManuallySetKeys");

var Jt = /*#__PURE__*/function (_ref15) {
  function Jt() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var e = arguments.length > 1 ? arguments[1] : undefined;
    var s = arguments.length > 2 ? arguments[2] : undefined;
    var i = arguments.length > 3 ? arguments[3] : undefined;

    _classCallCheck(this, Jt);

    this.customScriptName = !1, this.parsed = !1, z.set(this, void 0), q.set(this, void 0), W.set(this, {
      commands: [],
      fullCommands: []
    }), U.set(this, null), F.set(this, null), L.set(this, "show-hidden"), V.set(this, null), T.set(this, !0), R.set(this, {}), G.set(this, !0), K.set(this, []), B.set(this, void 0), Y.set(this, {}), J.set(this, !1), Z.set(this, null), X.set(this, void 0), Q.set(this, ""), tt.set(this, void 0), et.set(this, void 0), st.set(this, {}), it.set(this, null), nt.set(this, null), rt.set(this, {}), ot.set(this, {}), at.set(this, void 0), ht.set(this, !1), lt.set(this, void 0), ct.set(this, !1), ft.set(this, !1), dt.set(this, !1), ut.set(this, void 0), pt.set(this, null), gt.set(this, void 0), O(this, lt, i, "f"), O(this, at, t, "f"), O(this, q, e, "f"), O(this, et, s, "f"), O(this, B, new w(this), "f"), this.$0 = this[wt](), this[Rt](), O(this, z, v(this, z, "f"), "f"), O(this, ut, v(this, ut, "f"), "f"), O(this, gt, v(this, gt, "f"), "f"), O(this, tt, v(this, tt, "f"), "f"), v(this, tt, "f").showHiddenOpt = v(this, L, "f"), O(this, X, this[yt](), "f");
  }

  _createClass(Jt, [{
    key: "addHelpOpt",
    value: function addHelpOpt(t, e) {
      return h("[string|boolean] [string]", [t, e], arguments.length), v(this, Z, "f") && (this[bt](v(this, Z, "f")), O(this, Z, null, "f")), !1 === t && void 0 === e || (O(this, Z, "string" == typeof t ? t : "help", "f"), this["boolean"](v(this, Z, "f")), this.describe(v(this, Z, "f"), e || v(this, ut, "f").deferY18nLookup("Show help"))), this;
    }
  }, {
    key: "help",
    value: function help(t, e) {
      return this.addHelpOpt(t, e);
    }
  }, {
    key: "addShowHiddenOpt",
    value: function addShowHiddenOpt(t, e) {
      if (h("[string|boolean] [string]", [t, e], arguments.length), !1 === t && void 0 === e) return this;
      var s = "string" == typeof t ? t : v(this, L, "f");
      return this["boolean"](s), this.describe(s, e || v(this, ut, "f").deferY18nLookup("Show hidden options")), v(this, tt, "f").showHiddenOpt = s, this;
    }
  }, {
    key: "showHidden",
    value: function showHidden(t, e) {
      return this.addShowHiddenOpt(t, e);
    }
  }, {
    key: "alias",
    value: function alias(t, e) {
      return h("<object|string|array> [string|array]", [t, e], arguments.length), this[At](this.alias.bind(this), "alias", t, e), this;
    }
  }, {
    key: "array",
    value: function array(t) {
      return h("<array|string>", [t], arguments.length), this[Et]("array", t), this[Yt](t), this;
    }
  }, {
    key: "boolean",
    value: function boolean(t) {
      return h("<array|string>", [t], arguments.length), this[Et]("boolean", t), this[Yt](t), this;
    }
  }, {
    key: "check",
    value: function check(t, e) {
      var _this10 = this;

      return h("<function> [boolean]", [t, e], arguments.length), this.middleware(function (e, s) {
        return j(function () {
          return t(e);
        }, function (s) {
          return s ? ("string" == typeof s || s instanceof Error) && v(_this10, ut, "f").fail(s.toString(), s) : v(_this10, ut, "f").fail(v(_this10, lt, "f").y18n.__("Argument check failed: %s", t.toString())), e;
        }, function (t) {
          return v(_this10, ut, "f").fail(t.message ? t.message : t.toString(), t), e;
        });
      }, !1, e), this;
    }
  }, {
    key: "choices",
    value: function choices(t, e) {
      return h("<object|string|array> [string|array]", [t, e], arguments.length), this[At](this.choices.bind(this), "choices", t, e), this;
    }
  }, {
    key: "coerce",
    value: function coerce(t, s) {
      if (h("<object|string|array> [function]", [t, s], arguments.length), Array.isArray(t)) {
        if (!s) throw new e("coerce callback must be provided");

        var _iterator3 = _createForOfIteratorHelper(t),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _e10 = _step3.value;
            this.coerce(_e10, s);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return this;
      }

      if ("object" == _typeof(t)) {
        for (var _i9 = 0, _Object$keys3 = Object.keys(t); _i9 < _Object$keys3.length; _i9++) {
          var _e11 = _Object$keys3[_i9];
          this.coerce(_e11, t[_e11]);
        }

        return this;
      }

      if (!s) throw new e("coerce callback must be provided");
      return v(this, tt, "f").key[t] = !0, v(this, B, "f").addCoerceMiddleware(function (i, n) {
        var r;
        return j(function () {
          return r = n.getAliases(), s(i[t]);
        }, function (e) {
          if (i[t] = e, r[t]) {
            var _iterator4 = _createForOfIteratorHelper(r[t]),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var _s10 = _step4.value;
                i[_s10] = e;
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }

          return i;
        }, function (t) {
          throw new e(t.message);
        });
      }, t), this;
    }
  }, {
    key: "conflicts",
    value: function conflicts(t, e) {
      return h("<string|object> [string|array]", [t, e], arguments.length), v(this, gt, "f").conflicts(t, e), this;
    }
  }, {
    key: "config",
    value: function config() {
      var _this11 = this;

      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "config";
      var e = arguments.length > 1 ? arguments[1] : undefined;
      var s = arguments.length > 2 ? arguments[2] : undefined;
      return h("[object|string] [string|function] [function]", [t, e, s], arguments.length), "object" != _typeof(t) || Array.isArray(t) ? ("function" == typeof e && (s = e, e = void 0), this.describe(t, e || v(this, ut, "f").deferY18nLookup("Path to JSON config file")), (Array.isArray(t) ? t : [t]).forEach(function (t) {
        v(_this11, tt, "f").config[t] = s || !0;
      }), this) : (t = n(t, v(this, q, "f"), this[Ct]()["deep-merge-config"] || !1, v(this, lt, "f")), v(this, tt, "f").configObjects = (v(this, tt, "f").configObjects || []).concat(t), this);
    }
  }, {
    key: "completion",
    value: function completion(t, e, s) {
      return h("[string] [string|boolean|function] [function]", [t, e, s], arguments.length), "function" == typeof e && (s = e, e = void 0), O(this, F, t || v(this, F, "f") || "completion", "f"), e || !1 === e || (e = "generate completion script"), this.command(v(this, F, "f"), e), s && v(this, U, "f").registerFunction(s), this;
    }
  }, {
    key: "command",
    value: function command(t, e, s, i, n, r) {
      return h("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [t, e, s, i, n, r], arguments.length), v(this, z, "f").addHandler(t, e, s, i, n, r), this;
    }
  }, {
    key: "commands",
    value: function commands(t, e, s, i, n, r) {
      return this.command(t, e, s, i, n, r);
    }
  }, {
    key: "commandDir",
    value: function commandDir(t, e) {
      h("<string> [object]", [t, e], arguments.length);

      var s = v(this, et, "f") || v(this, lt, "f").require;

      return v(this, z, "f").addDirectory(t, s, v(this, lt, "f").getCallerFile(), e), this;
    }
  }, {
    key: "count",
    value: function count(t) {
      return h("<array|string>", [t], arguments.length), this[Et]("count", t), this[Yt](t), this;
    }
  }, {
    key: "default",
    value: function _default(t, e, s) {
      return h("<object|string|array> [*] [string]", [t, e, s], arguments.length), s && (u(t, v(this, lt, "f")), v(this, tt, "f").defaultDescription[t] = s), "function" == typeof e && (u(t, v(this, lt, "f")), v(this, tt, "f").defaultDescription[t] || (v(this, tt, "f").defaultDescription[t] = v(this, ut, "f").functionDescription(e)), e = e.call()), this[xt](this["default"].bind(this), "default", t, e), this;
    }
  }, {
    key: "defaults",
    value: function defaults(t, e, s) {
      return this["default"](t, e, s);
    }
  }, {
    key: "demandCommand",
    value: function demandCommand() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var e = arguments.length > 1 ? arguments[1] : undefined;
      var s = arguments.length > 2 ? arguments[2] : undefined;
      var i = arguments.length > 3 ? arguments[3] : undefined;
      return h("[number] [number|string] [string|null|undefined] [string|null|undefined]", [t, e, s, i], arguments.length), "number" != typeof e && (s = e, e = 1 / 0), this.global("_", !1), v(this, tt, "f").demandedCommands._ = {
        min: t,
        max: e,
        minMsg: s,
        maxMsg: i
      }, this;
    }
  }, {
    key: "demand",
    value: function demand(t, e, s) {
      var _this12 = this;

      return Array.isArray(e) ? (e.forEach(function (t) {
        d(s, !0, v(_this12, lt, "f")), _this12.demandOption(t, s);
      }), e = 1 / 0) : "number" != typeof e && (s = e, e = 1 / 0), "number" == typeof t ? (d(s, !0, v(this, lt, "f")), this.demandCommand(t, e, s, s)) : Array.isArray(t) ? t.forEach(function (t) {
        d(s, !0, v(_this12, lt, "f")), _this12.demandOption(t, s);
      }) : "string" == typeof s ? this.demandOption(t, s) : !0 !== s && void 0 !== s || this.demandOption(t), this;
    }
  }, {
    key: "demandOption",
    value: function demandOption(t, e) {
      return h("<object|string|array> [string]", [t, e], arguments.length), this[xt](this.demandOption.bind(this), "demandedOptions", t, e), this;
    }
  }, {
    key: "deprecateOption",
    value: function deprecateOption(t, e) {
      return h("<string> [string|boolean]", [t, e], arguments.length), v(this, tt, "f").deprecatedOptions[t] = e, this;
    }
  }, {
    key: "describe",
    value: function describe(t, e) {
      return h("<object|string|array> [string]", [t, e], arguments.length), this[$t](t, !0), v(this, ut, "f").describe(t, e), this;
    }
  }, {
    key: "detectLocale",
    value: function detectLocale(t) {
      return h("<boolean>", [t], arguments.length), O(this, T, t, "f"), this;
    }
  }, {
    key: "env",
    value: function env(t) {
      return h("[string|boolean]", [t], arguments.length), !1 === t ? delete v(this, tt, "f").envPrefix : v(this, tt, "f").envPrefix = t || "", this;
    }
  }, {
    key: "epilogue",
    value: function epilogue(t) {
      return h("<string>", [t], arguments.length), v(this, ut, "f").epilog(t), this;
    }
  }, {
    key: "epilog",
    value: function epilog(t) {
      return this.epilogue(t);
    }
  }, {
    key: "example",
    value: function example(t, e) {
      var _this13 = this;

      return h("<string|array> [string]", [t, e], arguments.length), Array.isArray(t) ? t.forEach(function (t) {
        return _this13.example.apply(_this13, _toConsumableArray(t));
      }) : v(this, ut, "f").example(t, e), this;
    }
  }, {
    key: "exit",
    value: function exit(t, e) {
      O(this, J, !0, "f"), O(this, V, e, "f"), v(this, G, "f") && v(this, lt, "f").process.exit(t);
    }
  }, {
    key: "exitProcess",
    value: function exitProcess() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
      return h("[boolean]", [t], arguments.length), O(this, G, t, "f"), this;
    }
  }, {
    key: "fail",
    value: function fail(t) {
      if (h("<function|boolean>", [t], arguments.length), "boolean" == typeof t && !1 !== t) throw new e("Invalid first argument. Expected function or boolean 'false'");
      return v(this, ut, "f").failFn(t), this;
    }
  }, {
    key: "getAliases",
    value: function getAliases() {
      return this.parsed ? this.parsed.aliases : {};
    }
  }, {
    key: "getCompletion",
    value: function () {
      var _getCompletion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(t, e) {
        var _this14 = this;

        var _args = arguments;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", (h("<array> [function]", [t, e], _args.length), e ? v(this, U, "f").getCompletion(t, e) : new Promise(function (e, s) {
                  v(_this14, U, "f").getCompletion(t, function (t, i) {
                    t ? s(t) : e(i);
                  });
                })));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getCompletion(_x, _x2) {
        return _getCompletion.apply(this, arguments);
      }

      return getCompletion;
    }()
  }, {
    key: "getDemandedOptions",
    value: function getDemandedOptions() {
      return h([], 0), v(this, tt, "f").demandedOptions;
    }
  }, {
    key: "getDemandedCommands",
    value: function getDemandedCommands() {
      return h([], 0), v(this, tt, "f").demandedCommands;
    }
  }, {
    key: "getDeprecatedOptions",
    value: function getDeprecatedOptions() {
      return h([], 0), v(this, tt, "f").deprecatedOptions;
    }
  }, {
    key: "getDetectLocale",
    value: function getDetectLocale() {
      return v(this, T, "f");
    }
  }, {
    key: "getExitProcess",
    value: function getExitProcess() {
      return v(this, G, "f");
    }
  }, {
    key: "getGroups",
    value: function getGroups() {
      return Object.assign({}, v(this, Y, "f"), v(this, ot, "f"));
    }
  }, {
    key: "getHelp",
    value: function getHelp() {
      var _this15 = this;

      if (O(this, J, !0, "f"), !v(this, ut, "f").hasCachedHelpMessage()) {
        if (!this.parsed) {
          var _t16 = this[Gt](v(this, at, "f"), void 0, void 0, 0, !0);

          if (f(_t16)) return _t16.then(function () {
            return v(_this15, ut, "f").help();
          });
        }

        var _t15 = v(this, z, "f").runDefaultBuilderOn(this);

        if (f(_t15)) return _t15.then(function () {
          return v(_this15, ut, "f").help();
        });
      }

      return Promise.resolve(v(this, ut, "f").help());
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      return v(this, tt, "f");
    }
  }, {
    key: "getStrict",
    value: function getStrict() {
      return v(this, ct, "f");
    }
  }, {
    key: "getStrictCommands",
    value: function getStrictCommands() {
      return v(this, ft, "f");
    }
  }, {
    key: "getStrictOptions",
    value: function getStrictOptions() {
      return v(this, dt, "f");
    }
  }, {
    key: "global",
    value: function global(t, e) {
      var _this16 = this;

      return h("<string|array> [boolean]", [t, e], arguments.length), t = [].concat(t), !1 !== e ? v(this, tt, "f").local = v(this, tt, "f").local.filter(function (e) {
        return -1 === t.indexOf(e);
      }) : t.forEach(function (t) {
        v(_this16, tt, "f").local.includes(t) || v(_this16, tt, "f").local.push(t);
      }), this;
    }
  }, {
    key: "group",
    value: function group(t, e) {
      h("<string|array> <string>", [t, e], arguments.length);
      var s = v(this, ot, "f")[e] || v(this, Y, "f")[e];
      v(this, ot, "f")[e] && delete v(this, ot, "f")[e];
      var i = {};
      return v(this, Y, "f")[e] = (s || []).concat(t).filter(function (t) {
        return !i[t] && (i[t] = !0);
      }), this;
    }
  }, {
    key: "hide",
    value: function hide(t) {
      return h("<string>", [t], arguments.length), v(this, tt, "f").hiddenOptions.push(t), this;
    }
  }, {
    key: "implies",
    value: function implies(t, e) {
      return h("<string|object> [number|string|array]", [t, e], arguments.length), v(this, gt, "f").implies(t, e), this;
    }
  }, {
    key: "locale",
    value: function locale(t) {
      return h("[string]", [t], arguments.length), t ? (O(this, T, !1, "f"), v(this, lt, "f").y18n.setLocale(t), this) : (this[jt](), v(this, lt, "f").y18n.getLocale());
    }
  }, {
    key: "middleware",
    value: function middleware(t, e, s) {
      return v(this, B, "f").addMiddleware(t, !!e, s);
    }
  }, {
    key: "nargs",
    value: function nargs(t, e) {
      return h("<string|object|array> [number]", [t, e], arguments.length), this[xt](this.nargs.bind(this), "narg", t, e), this;
    }
  }, {
    key: "normalize",
    value: function normalize(t) {
      return h("<array|string>", [t], arguments.length), this[Et]("normalize", t), this;
    }
  }, {
    key: "number",
    value: function number(t) {
      return h("<array|string>", [t], arguments.length), this[Et]("number", t), this[Yt](t), this;
    }
  }, {
    key: "option",
    value: function option(t, e) {
      var _this17 = this;

      if (h("<string|object> [object]", [t, e], arguments.length), "object" == _typeof(t)) Object.keys(t).forEach(function (e) {
        _this17.options(e, t[e]);
      });else {
        "object" != _typeof(e) && (e = {}), this[Yt](t), !v(this, pt, "f") || "version" !== t && "version" !== (null == e ? void 0 : e.alias) || this[vt](['"version" is a reserved word.', "Please do one of the following:", '- Disable version with `yargs.version(false)` if using "version" as an option', "- Use the built-in `yargs.version` method instead (if applicable)", "- Use a different option key", "https://yargs.js.org/docs/#api-reference-version"].join("\n"), void 0, "versionWarning"), v(this, tt, "f").key[t] = !0, e.alias && this.alias(t, e.alias);

        var _s11 = e.deprecate || e.deprecated;

        _s11 && this.deprecateOption(t, _s11);

        var _i10 = e.demand || e.required || e.require;

        _i10 && this.demand(t, _i10), e.demandOption && this.demandOption(t, "string" == typeof e.demandOption ? e.demandOption : void 0), e.conflicts && this.conflicts(t, e.conflicts), "default" in e && this["default"](t, e["default"]), void 0 !== e.implies && this.implies(t, e.implies), void 0 !== e.nargs && this.nargs(t, e.nargs), e.config && this.config(t, e.configParser), e.normalize && this.normalize(t), e.choices && this.choices(t, e.choices), e.coerce && this.coerce(t, e.coerce), e.group && this.group(t, e.group), (e["boolean"] || "boolean" === e.type) && (this["boolean"](t), e.alias && this["boolean"](e.alias)), (e.array || "array" === e.type) && (this.array(t), e.alias && this.array(e.alias)), (e.number || "number" === e.type) && (this.number(t), e.alias && this.number(e.alias)), (e.string || "string" === e.type) && (this.string(t), e.alias && this.string(e.alias)), (e.count || "count" === e.type) && this.count(t), "boolean" == typeof e.global && this.global(t, e.global), e.defaultDescription && (v(this, tt, "f").defaultDescription[t] = e.defaultDescription), e.skipValidation && this.skipValidation(t);

        var _n9 = e.describe || e.description || e.desc;

        this.describe(t, _n9), e.hidden && this.hide(t), e.requiresArg && this.requiresArg(t);
      }
      return this;
    }
  }, {
    key: "options",
    value: function options(t, e) {
      return this.option(t, e);
    }
  }, {
    key: "parse",
    value: function parse(t, e, s) {
      var _this18 = this;

      h("[string|array] [function|boolean|object] [function]", [t, e, s], arguments.length), this[Ot](), void 0 === t && (t = v(this, at, "f")), "object" == _typeof(e) && (O(this, nt, e, "f"), e = s), "function" == typeof e && (O(this, it, e, "f"), e = !1), e || O(this, at, t, "f"), v(this, it, "f") && O(this, G, !1, "f");
      var i = this[Gt](t, !!e),
          n = this.parsed;
      return v(this, U, "f").setParsed(this.parsed), f(i) ? i.then(function (t) {
        return v(_this18, it, "f") && v(_this18, it, "f").call(_this18, v(_this18, V, "f"), t, v(_this18, Q, "f")), t;
      })["catch"](function (t) {
        throw v(_this18, it, "f") && v(_this18, it, "f")(t, _this18.parsed.argv, v(_this18, Q, "f")), t;
      })["finally"](function () {
        _this18[It](), _this18.parsed = n;
      }) : (v(this, it, "f") && v(this, it, "f").call(this, v(this, V, "f"), i, v(this, Q, "f")), this[It](), this.parsed = n, i);
    }
  }, {
    key: "parseAsync",
    value: function parseAsync(t, e, s) {
      var i = this.parse(t, e, s);
      return f(i) ? i : Promise.resolve(i);
    }
  }, {
    key: "parseSync",
    value: function parseSync(t, s, i) {
      var n = this.parse(t, s, i);
      if (f(n)) throw new e(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
      return n;
    }
  }, {
    key: "parserConfiguration",
    value: function parserConfiguration(t) {
      return h("<object>", [t], arguments.length), O(this, st, t, "f"), this;
    }
  }, {
    key: "pkgConf",
    value: function pkgConf(t, e) {
      h("<string> [string]", [t, e], arguments.length);
      var s = null;
      var i = this[kt](e || v(this, q, "f"));
      return i[t] && "object" == _typeof(i[t]) && (s = n(i[t], e || v(this, q, "f"), this[Ct]()["deep-merge-config"] || !1, v(this, lt, "f")), v(this, tt, "f").configObjects = (v(this, tt, "f").configObjects || []).concat(s)), this;
    }
  }, {
    key: "positional",
    value: function positional(t, e) {
      h("<string> <object>", [t, e], arguments.length);
      var s = ["default", "defaultDescription", "implies", "normalize", "choices", "conflicts", "coerce", "type", "describe", "desc", "description", "alias"];
      e = g(e, function (t, e) {
        return !("type" === t && !["string", "number", "boolean"].includes(e)) && s.includes(t);
      });
      var i = v(this, W, "f").fullCommands[v(this, W, "f").fullCommands.length - 1],
          n = i ? v(this, z, "f").cmdToParseOptions(i) : {
        array: [],
        alias: {},
        "default": {},
        demand: {}
      };
      return p(n).forEach(function (s) {
        var i = n[s];
        Array.isArray(i) ? -1 !== i.indexOf(t) && (e[s] = !0) : i[t] && !(s in e) && (e[s] = i[t]);
      }), this.group(t, v(this, ut, "f").getPositionalGroupName()), this.option(t, e);
    }
  }, {
    key: "recommendCommands",
    value: function recommendCommands() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
      return h("[boolean]", [t], arguments.length), O(this, ht, t, "f"), this;
    }
  }, {
    key: "required",
    value: function required(t, e, s) {
      return this.demand(t, e, s);
    }
  }, {
    key: "require",
    value: function require(t, e, s) {
      return this.demand(t, e, s);
    }
  }, {
    key: "requiresArg",
    value: function requiresArg(t) {
      return h("<array|string|object> [number]", [t], arguments.length), "string" == typeof t && v(this, tt, "f").narg[t] || this[xt](this.requiresArg.bind(this), "narg", t, NaN), this;
    }
  }, {
    key: "showCompletionScript",
    value: function showCompletionScript(t, e) {
      return h("[string] [string]", [t, e], arguments.length), t = t || this.$0, v(this, X, "f").log(v(this, U, "f").generateCompletionScript(t, e || v(this, F, "f") || "completion")), this;
    }
  }, {
    key: "showHelp",
    value: function showHelp(t) {
      var _this19 = this;

      if (h("[string|function]", [t], arguments.length), O(this, J, !0, "f"), !v(this, ut, "f").hasCachedHelpMessage()) {
        if (!this.parsed) {
          var _e13 = this[Gt](v(this, at, "f"), void 0, void 0, 0, !0);

          if (f(_e13)) return _e13.then(function () {
            v(_this19, ut, "f").showHelp(t);
          }), this;
        }

        var _e12 = v(this, z, "f").runDefaultBuilderOn(this);

        if (f(_e12)) return _e12.then(function () {
          v(_this19, ut, "f").showHelp(t);
        }), this;
      }

      return v(this, ut, "f").showHelp(t), this;
    }
  }, {
    key: "scriptName",
    value: function scriptName(t) {
      return this.customScriptName = !0, this.$0 = t, this;
    }
  }, {
    key: "showHelpOnFail",
    value: function showHelpOnFail(t, e) {
      return h("[boolean|string] [string]", [t, e], arguments.length), v(this, ut, "f").showHelpOnFail(t, e), this;
    }
  }, {
    key: "showVersion",
    value: function showVersion(t) {
      return h("[string|function]", [t], arguments.length), v(this, ut, "f").showVersion(t), this;
    }
  }, {
    key: "skipValidation",
    value: function skipValidation(t) {
      return h("<array|string>", [t], arguments.length), this[Et]("skipValidation", t), this;
    }
  }, {
    key: "strict",
    value: function strict(t) {
      return h("[boolean]", [t], arguments.length), O(this, ct, !1 !== t, "f"), this;
    }
  }, {
    key: "strictCommands",
    value: function strictCommands(t) {
      return h("[boolean]", [t], arguments.length), O(this, ft, !1 !== t, "f"), this;
    }
  }, {
    key: "strictOptions",
    value: function strictOptions(t) {
      return h("[boolean]", [t], arguments.length), O(this, dt, !1 !== t, "f"), this;
    }
  }, {
    key: "string",
    value: function string(t) {
      return h("<array|string>", [t], arguments.length), this[Et]("string", t), this[Yt](t), this;
    }
  }, {
    key: "terminalWidth",
    value: function terminalWidth() {
      return h([], 0), v(this, lt, "f").process.stdColumns;
    }
  }, {
    key: "updateLocale",
    value: function updateLocale(t) {
      return this.updateStrings(t);
    }
  }, {
    key: "updateStrings",
    value: function updateStrings(t) {
      return h("<object>", [t], arguments.length), O(this, T, !1, "f"), v(this, lt, "f").y18n.updateLocale(t), this;
    }
  }, {
    key: "usage",
    value: function usage(t, s, i, n) {
      if (h("<string|null|undefined> [string|boolean] [function|object] [function]", [t, s, i, n], arguments.length), void 0 !== s) {
        if (d(t, null, v(this, lt, "f")), (t || "").match(/^\$0( |$)/)) return this.command(t, s, i, n);
        throw new e(".usage() description must start with $0 if being used as alias for .command()");
      }

      return v(this, ut, "f").usage(t), this;
    }
  }, {
    key: "version",
    value: function version(t, e, s) {
      var i = "version";
      if (h("[boolean|string] [string] [string]", [t, e, s], arguments.length), v(this, pt, "f") && (this[bt](v(this, pt, "f")), v(this, ut, "f").version(void 0), O(this, pt, null, "f")), 0 === arguments.length) s = this[_t](), t = i;else if (1 === arguments.length) {
        if (!1 === t) return this;
        s = t, t = i;
      } else 2 === arguments.length && (s = e, e = void 0);
      return O(this, pt, "string" == typeof t ? t : i, "f"), e = e || v(this, ut, "f").deferY18nLookup("Show version number"), v(this, ut, "f").version(s || void 0), this["boolean"](v(this, pt, "f")), this.describe(v(this, pt, "f"), e), this;
    }
  }, {
    key: "wrap",
    value: function wrap(t) {
      return h("<number|null|undefined>", [t], arguments.length), v(this, ut, "f").wrap(t), this;
    }
  }, {
    key: _ref15,
    value: function value(t) {
      if (!t._ || !t["--"]) return t;

      t._.push.apply(t._, t["--"]);

      try {
        delete t["--"];
      } catch (t) {}

      return t;
    }
  }, {
    key: yt,
    value: function value() {
      var _this20 = this;

      return {
        log: function log() {
          var _console;

          for (var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++) {
            t[_key] = arguments[_key];
          }

          _this20[Lt]() || (_console = console).log.apply(_console, t), O(_this20, J, !0, "f"), v(_this20, Q, "f").length && O(_this20, Q, v(_this20, Q, "f") + "\n", "f"), O(_this20, Q, v(_this20, Q, "f") + t.join(" "), "f");
        },
        error: function error() {
          var _console2;

          for (var _len2 = arguments.length, t = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            t[_key2] = arguments[_key2];
          }

          _this20[Lt]() || (_console2 = console).error.apply(_console2, t), O(_this20, J, !0, "f"), v(_this20, Q, "f").length && O(_this20, Q, v(_this20, Q, "f") + "\n", "f"), O(_this20, Q, v(_this20, Q, "f") + t.join(" "), "f");
        }
      };
    }
  }, {
    key: bt,
    value: function value(t) {
      var _this21 = this;

      p(v(this, tt, "f")).forEach(function (e) {
        if ("configObjects" === e) return;
        var s = v(_this21, tt, "f")[e];
        Array.isArray(s) ? s.includes(t) && s.splice(s.indexOf(t), 1) : "object" == _typeof(s) && delete s[t];
      }), delete v(this, ut, "f").getDescriptions()[t];
    }
  }, {
    key: vt,
    value: function value(t, e, s) {
      v(this, R, "f")[s] || (v(this, lt, "f").process.emitWarning(t, e), v(this, R, "f")[s] = !0);
    }
  }, {
    key: Ot,
    value: function value() {
      v(this, K, "f").push({
        options: v(this, tt, "f"),
        configObjects: v(this, tt, "f").configObjects.slice(0),
        exitProcess: v(this, G, "f"),
        groups: v(this, Y, "f"),
        strict: v(this, ct, "f"),
        strictCommands: v(this, ft, "f"),
        strictOptions: v(this, dt, "f"),
        completionCommand: v(this, F, "f"),
        output: v(this, Q, "f"),
        exitError: v(this, V, "f"),
        hasOutput: v(this, J, "f"),
        parsed: this.parsed,
        parseFn: v(this, it, "f"),
        parseContext: v(this, nt, "f")
      }), v(this, ut, "f").freeze(), v(this, gt, "f").freeze(), v(this, z, "f").freeze(), v(this, B, "f").freeze();
    }
  }, {
    key: wt,
    value: function value() {
      var _this22 = this;

      var t,
          e = "";
      return t = /\b(node|iojs|electron)(\.exe)?$/.test(v(this, lt, "f").process.argv()[0]) ? v(this, lt, "f").process.argv().slice(1, 2) : v(this, lt, "f").process.argv().slice(0, 1), e = t.map(function (t) {
        var e = _this22[Tt](v(_this22, q, "f"), t);

        return t.match(/^(\/|([a-zA-Z]:)?\\)/) && e.length < t.length ? e : t;
      }).join(" ").trim(), v(this, lt, "f").getEnv("_") && v(this, lt, "f").getProcessArgvBin() === v(this, lt, "f").getEnv("_") && (e = v(this, lt, "f").getEnv("_").replace("".concat(v(this, lt, "f").path.dirname(v(this, lt, "f").process.execPath()), "/"), "")), e;
    }
  }, {
    key: Ct,
    value: function value() {
      return v(this, st, "f");
    }
  }, {
    key: jt,
    value: function value() {
      if (!v(this, T, "f")) return;
      var t = v(this, lt, "f").getEnv("LC_ALL") || v(this, lt, "f").getEnv("LC_MESSAGES") || v(this, lt, "f").getEnv("LANG") || v(this, lt, "f").getEnv("LANGUAGE") || "en_US";
      this.locale(t.replace(/[.:].*/, ""));
    }
  }, {
    key: _t,
    value: function value() {
      return this[kt]().version || "unknown";
    }
  }, {
    key: Mt,
    value: function value(t) {
      var e = t["--"] ? t["--"] : t._;

      for (var _t17, _s12 = 0; void 0 !== (_t17 = e[_s12]); _s12++) {
        v(this, lt, "f").Parser.looksLikeNumber(_t17) && Number.isSafeInteger(Math.floor(parseFloat("".concat(_t17)))) && (e[_s12] = Number(_t17));
      }

      return t;
    }
  }, {
    key: kt,
    value: function value(t) {
      var e = t || "*";
      if (v(this, rt, "f")[e]) return v(this, rt, "f")[e];
      var s = {};

      try {
        var _e14 = t || v(this, lt, "f").mainFilename;

        !t && v(this, lt, "f").path.extname(_e14) && (_e14 = v(this, lt, "f").path.dirname(_e14));

        var _i11 = v(this, lt, "f").findUp(_e14, function (t, e) {
          return e.includes("package.json") ? "package.json" : void 0;
        });

        d(_i11, void 0, v(this, lt, "f")), s = JSON.parse(v(this, lt, "f").readFileSync(_i11, "utf8"));
      } catch (t) {}

      return v(this, rt, "f")[e] = s || {}, v(this, rt, "f")[e];
    }
  }, {
    key: Et,
    value: function value(t, e) {
      var _this23 = this;

      (e = [].concat(e)).forEach(function (e) {
        e = _this23[Pt](e), v(_this23, tt, "f")[t].push(e);
      });
    }
  }, {
    key: xt,
    value: function value(t, e, s, i) {
      var _this24 = this;

      this[St](t, e, s, i, function (t, e, s) {
        v(_this24, tt, "f")[t][e] = s;
      });
    }
  }, {
    key: At,
    value: function value(t, e, s, i) {
      var _this25 = this;

      this[St](t, e, s, i, function (t, e, s) {
        v(_this25, tt, "f")[t][e] = (v(_this25, tt, "f")[t][e] || []).concat(s);
      });
    }
  }, {
    key: St,
    value: function value(t, e, s, i, n) {
      if (Array.isArray(s)) s.forEach(function (e) {
        t(e, i);
      });else if (function (t) {
        return "object" == _typeof(t);
      }(s)) {
        var _iterator5 = _createForOfIteratorHelper(p(s)),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _e15 = _step5.value;
            t(_e15, s[_e15]);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      } else n(e, this[Pt](s), i);
    }
  }, {
    key: Pt,
    value: function value(t) {
      return "__proto__" === t ? "___proto___" : t;
    }
  }, {
    key: $t,
    value: function value(t, e) {
      return this[xt](this[$t].bind(this), "key", t, e), this;
    }
  }, {
    key: It,
    value: function value() {
      var _u2;

      var t, e, s, i, n, r, o, a, h, l, c, f;
      var u = v(this, K, "f").pop();
      var p;
      d(u, void 0, v(this, lt, "f")), t = this, e = this, s = this, i = this, n = this, r = this, o = this, a = this, h = this, l = this, c = this, f = this, (_u2 = u, {
        set value(e) {
          O(t, tt, e, "f");
        }

      }.value = _u2.options, p = _u2.configObjects, {
        set value(t) {
          O(e, G, t, "f");
        }

      }.value = _u2.exitProcess, {
        set value(t) {
          O(s, Y, t, "f");
        }

      }.value = _u2.groups, {
        set value(t) {
          O(i, Q, t, "f");
        }

      }.value = _u2.output, {
        set value(t) {
          O(n, V, t, "f");
        }

      }.value = _u2.exitError, {
        set value(t) {
          O(r, J, t, "f");
        }

      }.value = _u2.hasOutput, this.parsed = _u2.parsed, {
        set value(t) {
          O(o, ct, t, "f");
        }

      }.value = _u2.strict, {
        set value(t) {
          O(a, ft, t, "f");
        }

      }.value = _u2.strictCommands, {
        set value(t) {
          O(h, dt, t, "f");
        }

      }.value = _u2.strictOptions, {
        set value(t) {
          O(l, F, t, "f");
        }

      }.value = _u2.completionCommand, {
        set value(t) {
          O(c, it, t, "f");
        }

      }.value = _u2.parseFn, {
        set value(t) {
          O(f, nt, t, "f");
        }

      }.value = _u2.parseContext, _u2), v(this, tt, "f").configObjects = p, v(this, ut, "f").unfreeze(), v(this, gt, "f").unfreeze(), v(this, z, "f").unfreeze(), v(this, B, "f").unfreeze();
    }
  }, {
    key: Dt,
    value: function value(t, e) {
      return j(e, function (e) {
        return t(e), e;
      });
    }
  }, {
    key: "getInternalMethods",
    value: function getInternalMethods() {
      return {
        getCommandInstance: this[Nt].bind(this),
        getContext: this[Ht].bind(this),
        getHasOutput: this[zt].bind(this),
        getLoggerInstance: this[qt].bind(this),
        getParseContext: this[Wt].bind(this),
        getParserConfiguration: this[Ct].bind(this),
        getUsageInstance: this[Ut].bind(this),
        getValidationInstance: this[Ft].bind(this),
        hasParseCallback: this[Lt].bind(this),
        postProcess: this[Vt].bind(this),
        reset: this[Rt].bind(this),
        runValidation: this[Kt].bind(this),
        runYargsParserAndExecuteCommands: this[Gt].bind(this),
        setHasOutput: this[Bt].bind(this)
      };
    }
  }, {
    key: Nt,
    value: function value() {
      return v(this, z, "f");
    }
  }, {
    key: Ht,
    value: function value() {
      return v(this, W, "f");
    }
  }, {
    key: zt,
    value: function value() {
      return v(this, J, "f");
    }
  }, {
    key: qt,
    value: function value() {
      return v(this, X, "f");
    }
  }, {
    key: Wt,
    value: function value() {
      return v(this, nt, "f") || {};
    }
  }, {
    key: Ut,
    value: function value() {
      return v(this, ut, "f");
    }
  }, {
    key: Ft,
    value: function value() {
      return v(this, gt, "f");
    }
  }, {
    key: Lt,
    value: function value() {
      return !!v(this, it, "f");
    }
  }, {
    key: Vt,
    value: function value(t, e, s, i) {
      if (s) return t;
      if (f(t)) return t;
      e || (t = this[mt](t));
      return (this[Ct]()["parse-positional-numbers"] || void 0 === this[Ct]()["parse-positional-numbers"]) && (t = this[Mt](t)), i && (t = C(t, this, v(this, B, "f").getMiddleware(), !1)), t;
    }
  }, {
    key: Rt,
    value: function value() {
      var _this26 = this;

      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      O(this, tt, v(this, tt, "f") || {}, "f");
      var e = {};
      e.local = v(this, tt, "f").local || [], e.configObjects = v(this, tt, "f").configObjects || [];
      var s = {};
      e.local.forEach(function (e) {
        s[e] = !0, (t[e] || []).forEach(function (t) {
          s[t] = !0;
        });
      }), Object.assign(v(this, ot, "f"), Object.keys(v(this, Y, "f")).reduce(function (t, e) {
        var i = v(_this26, Y, "f")[e].filter(function (t) {
          return !(t in s);
        });
        return i.length > 0 && (t[e] = i), t;
      }, {})), O(this, Y, {}, "f");
      return ["array", "boolean", "string", "skipValidation", "count", "normalize", "number", "hiddenOptions"].forEach(function (t) {
        e[t] = (v(_this26, tt, "f")[t] || []).filter(function (t) {
          return !s[t];
        });
      }), ["narg", "key", "alias", "default", "defaultDescription", "config", "choices", "demandedOptions", "demandedCommands", "deprecatedOptions"].forEach(function (t) {
        e[t] = g(v(_this26, tt, "f")[t], function (t) {
          return !s[t];
        });
      }), e.envPrefix = v(this, tt, "f").envPrefix, O(this, tt, e, "f"), O(this, ut, v(this, ut, "f") ? v(this, ut, "f").reset(s) : S(this, v(this, lt, "f")), "f"), O(this, gt, v(this, gt, "f") ? v(this, gt, "f").reset(s) : function (t, e, s) {
        var i = s.y18n.__,
            n = s.y18n.__n,
            r = {
          nonOptionCount: function nonOptionCount(s) {
            var i = t.getDemandedCommands(),
                r = s._.length + (s["--"] ? s["--"].length : 0) - t.getInternalMethods().getContext().commands.length;
            i._ && (r < i._.min || r > i._.max) && (r < i._.min ? void 0 !== i._.minMsg ? e.fail(i._.minMsg ? i._.minMsg.replace(/\$0/g, r.toString()).replace(/\$1/, i._.min.toString()) : null) : e.fail(n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", r, r.toString(), i._.min.toString())) : r > i._.max && (void 0 !== i._.maxMsg ? e.fail(i._.maxMsg ? i._.maxMsg.replace(/\$0/g, r.toString()).replace(/\$1/, i._.max.toString()) : null) : e.fail(n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", r, r.toString(), i._.max.toString()))));
          },
          positionalCount: function positionalCount(t, s) {
            s < t && e.fail(n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", s, s + "", t + ""));
          },
          requiredArguments: function requiredArguments(t, s) {
            var i = null;

            for (var _i12 = 0, _Object$keys4 = Object.keys(s); _i12 < _Object$keys4.length; _i12++) {
              var _e16 = _Object$keys4[_i12];
              Object.prototype.hasOwnProperty.call(t, _e16) && void 0 !== t[_e16] || (i = i || {}, i[_e16] = s[_e16]);
            }

            if (i) {
              var _t18 = [];

              for (var _i13 = 0, _Object$keys5 = Object.keys(i); _i13 < _Object$keys5.length; _i13++) {
                var _e17 = _Object$keys5[_i13];
                var _s14 = i[_e17];
                _s14 && _t18.indexOf(_s14) < 0 && _t18.push(_s14);
              }

              var _s13 = _t18.length ? "\n".concat(_t18.join("\n")) : "";

              e.fail(n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(i).length, Object.keys(i).join(", ") + _s13));
            }
          },
          unknownArguments: function unknownArguments(s, i, o, a) {
            var h = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;
            var l;
            var c = t.getInternalMethods().getCommandInstance().getCommands(),
                f = [],
                d = t.getInternalMethods().getContext();

            if (Object.keys(s).forEach(function (e) {
              H.includes(e) || Object.prototype.hasOwnProperty.call(o, e) || Object.prototype.hasOwnProperty.call(t.getInternalMethods().getParseContext(), e) || r.isValidAndSomeAliasIsNotNew(e, i) || f.push(e);
            }), h && (d.commands.length > 0 || c.length > 0 || a) && s._.slice(d.commands.length).forEach(function (t) {
              c.includes("" + t) || f.push("" + t);
            }), h) {
              var _e18 = (null === (l = t.getDemandedCommands()._) || void 0 === l ? void 0 : l.max) || 0,
                  _i14 = d.commands.length + _e18;

              _i14 < s._.length && s._.slice(_i14).forEach(function (t) {
                t = String(t), d.commands.includes(t) || f.includes(t) || f.push(t);
              });
            }

            f.length && e.fail(n("Unknown argument: %s", "Unknown arguments: %s", f.length, f.join(", ")));
          },
          unknownCommands: function unknownCommands(s) {
            var i = t.getInternalMethods().getCommandInstance().getCommands(),
                r = [],
                o = t.getInternalMethods().getContext();
            return (o.commands.length > 0 || i.length > 0) && s._.slice(o.commands.length).forEach(function (t) {
              i.includes("" + t) || r.push("" + t);
            }), r.length > 0 && (e.fail(n("Unknown command: %s", "Unknown commands: %s", r.length, r.join(", "))), !0);
          },
          isValidAndSomeAliasIsNotNew: function isValidAndSomeAliasIsNotNew(e, s) {
            if (!Object.prototype.hasOwnProperty.call(s, e)) return !1;
            var i = t.parsed.newAliases;
            return [e].concat(_toConsumableArray(s[e])).some(function (t) {
              return !Object.prototype.hasOwnProperty.call(i, t) || !i[e];
            });
          },
          limitedChoices: function limitedChoices(s) {
            var n = t.getOptions(),
                r = {};
            if (!Object.keys(n.choices).length) return;
            Object.keys(s).forEach(function (t) {
              -1 === H.indexOf(t) && Object.prototype.hasOwnProperty.call(n.choices, t) && [].concat(s[t]).forEach(function (e) {
                -1 === n.choices[t].indexOf(e) && void 0 !== e && (r[t] = (r[t] || []).concat(e));
              });
            });
            var o = Object.keys(r);
            if (!o.length) return;
            var a = i("Invalid values:");
            o.forEach(function (t) {
              a += "\n  ".concat(i("Argument: %s, Given: %s, Choices: %s", t, e.stringifiedValues(r[t]), e.stringifiedValues(n.choices[t])));
            }), e.fail(a);
          }
        };
        var o = {};

        function a(t, e) {
          var s = Number(e);
          return "number" == typeof (e = isNaN(s) ? e : s) ? e = t._.length >= e : e.match(/^--no-.+/) ? (e = e.match(/^--no-(.+)/)[1], e = !Object.prototype.hasOwnProperty.call(t, e)) : e = Object.prototype.hasOwnProperty.call(t, e), e;
        }

        r.implies = function (e, i) {
          h("<string|object> [array|number|string]", [e, i], arguments.length), "object" == _typeof(e) ? Object.keys(e).forEach(function (t) {
            r.implies(t, e[t]);
          }) : (t.global(e), o[e] || (o[e] = []), Array.isArray(i) ? i.forEach(function (t) {
            return r.implies(e, t);
          }) : (d(i, void 0, s), o[e].push(i)));
        }, r.getImplied = function () {
          return o;
        }, r.implications = function (t) {
          var s = [];

          if (Object.keys(o).forEach(function (e) {
            var i = e;
            (o[e] || []).forEach(function (e) {
              var n = i;
              var r = e;
              n = a(t, n), e = a(t, e), n && !e && s.push(" ".concat(i, " -> ").concat(r));
            });
          }), s.length) {
            var _t19 = "".concat(i("Implications failed:"), "\n");

            s.forEach(function (e) {
              _t19 += e;
            }), e.fail(_t19);
          }
        };
        var l = {};
        r.conflicts = function (e, s) {
          h("<string|object> [array|string]", [e, s], arguments.length), "object" == _typeof(e) ? Object.keys(e).forEach(function (t) {
            r.conflicts(t, e[t]);
          }) : (t.global(e), l[e] || (l[e] = []), Array.isArray(s) ? s.forEach(function (t) {
            return r.conflicts(e, t);
          }) : l[e].push(s));
        }, r.getConflicting = function () {
          return l;
        }, r.conflicting = function (n) {
          Object.keys(n).forEach(function (t) {
            l[t] && l[t].forEach(function (s) {
              s && void 0 !== n[t] && void 0 !== n[s] && e.fail(i("Arguments %s and %s are mutually exclusive", t, s));
            });
          }), t.getInternalMethods().getParserConfiguration()["strip-dashed"] && Object.keys(l).forEach(function (t) {
            l[t].forEach(function (r) {
              r && void 0 !== n[s.Parser.camelCase(t)] && void 0 !== n[s.Parser.camelCase(r)] && e.fail(i("Arguments %s and %s are mutually exclusive", t, r));
            });
          });
        }, r.recommendCommands = function (t, s) {
          s = s.sort(function (t, e) {
            return e.length - t.length;
          });
          var n = null,
              r = 1 / 0;

          for (var _e19, _i15 = 0; void 0 !== (_e19 = s[_i15]); _i15++) {
            var _s15 = N(t, _e19);

            _s15 <= 3 && _s15 < r && (r = _s15, n = _e19);
          }

          n && e.fail(i("Did you mean %s?", n));
        }, r.reset = function (t) {
          return o = g(o, function (e) {
            return !t[e];
          }), l = g(l, function (e) {
            return !t[e];
          }), r;
        };
        var c = [];
        return r.freeze = function () {
          c.push({
            implied: o,
            conflicting: l
          });
        }, r.unfreeze = function () {
          var _t20;

          var t = c.pop();
          d(t, void 0, s), (_t20 = t, o = _t20.implied, l = _t20.conflicting, _t20);
        }, r;
      }(this, v(this, ut, "f"), v(this, lt, "f")), "f"), O(this, z, v(this, z, "f") ? v(this, z, "f").reset() : function (t, e, s, i) {
        return new M(t, e, s, i);
      }(v(this, ut, "f"), v(this, gt, "f"), v(this, B, "f"), v(this, lt, "f")), "f"), v(this, U, "f") || O(this, U, function (t, e, s, i) {
        return new D(t, e, s, i);
      }(this, v(this, ut, "f"), v(this, z, "f"), v(this, lt, "f")), "f"), v(this, B, "f").reset(), O(this, F, null, "f"), O(this, Q, "", "f"), O(this, V, null, "f"), O(this, J, !1, "f"), this.parsed = !1, this;
    }
  }, {
    key: Tt,
    value: function value(t, e) {
      return v(this, lt, "f").path.relative(t, e);
    }
  }, {
    key: Gt,
    value: function value(t, s, i) {
      var _this27 = this;

      var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      var o = !!i || r;
      t = t || v(this, at, "f"), v(this, tt, "f").__ = v(this, lt, "f").y18n.__, v(this, tt, "f").configuration = this[Ct]();
      var a = !!v(this, tt, "f").configuration["populate--"],
          h = Object.assign({}, v(this, tt, "f").configuration, {
        "populate--": !0
      }),
          l = v(this, lt, "f").Parser.detailed(t, Object.assign({}, v(this, tt, "f"), {
        configuration: _objectSpread({
          "parse-positional-numbers": !1
        }, h)
      })),
          c = Object.assign(l.argv, v(this, nt, "f"));
      var d;
      var u = l.aliases;
      var p = !1,
          g = !1;
      Object.keys(c).forEach(function (t) {
        t === v(_this27, Z, "f") && c[t] ? p = !0 : t === v(_this27, pt, "f") && c[t] && (g = !0);
      }), c.$0 = this.$0, this.parsed = l, 0 === n && v(this, ut, "f").clearCachedHelpMessage();

      try {
        if (this[jt](), s) return this[Vt](c, a, !!i, !1);

        if (v(this, Z, "f")) {
          [v(this, Z, "f")].concat(u[v(this, Z, "f")] || []).filter(function (t) {
            return t.length > 1;
          }).includes("" + c._[c._.length - 1]) && (c._.pop(), p = !0);
        }

        var _h3 = v(this, z, "f").getCommands(),
            _m = (v(this, U, "f").completionKey in c),
            _y = p || _m || r;

        if (c._.length) {
          if (_h3.length) {
            var _t21;

            for (var _e20, _s16 = n || 0; void 0 !== c._[_s16]; _s16++) {
              if (_e20 = String(c._[_s16]), _h3.includes(_e20) && _e20 !== v(this, F, "f")) {
                var _t22 = v(this, z, "f").runCommand(_e20, this, l, _s16 + 1, r, p || g || r);

                return this[Vt](_t22, a, !!i, !1);
              }

              if (!_t21 && _e20 !== v(this, F, "f")) {
                _t21 = _e20;
                break;
              }
            }

            !v(this, z, "f").hasDefaultCommand() && v(this, ht, "f") && _t21 && !_y && v(this, gt, "f").recommendCommands(_t21, _h3);
          }

          v(this, F, "f") && c._.includes(v(this, F, "f")) && !_m && (v(this, G, "f") && x(!0), this.showCompletionScript(), this.exit(0));
        }

        if (v(this, z, "f").hasDefaultCommand() && !_y) {
          var _t23 = v(this, z, "f").runCommand(null, this, l, 0, r, p || g || r);

          return this[Vt](_t23, a, !!i, !1);
        }

        if (_m) {
          v(this, G, "f") && x(!0);

          var _s17 = (t = [].concat(t)).slice(t.indexOf("--".concat(v(this, U, "f").completionKey)) + 1);

          return v(this, U, "f").getCompletion(_s17, function (t, s) {
            if (t) throw new e(t.message);
            (s || []).forEach(function (t) {
              v(_this27, X, "f").log(t);
            }), _this27.exit(0);
          }), this[Vt](c, !a, !!i, !1);
        }

        if (v(this, J, "f") || (p ? (v(this, G, "f") && x(!0), o = !0, this.showHelp("log"), this.exit(0)) : g && (v(this, G, "f") && x(!0), o = !0, v(this, ut, "f").showVersion("log"), this.exit(0))), !o && v(this, tt, "f").skipValidation.length > 0 && (o = Object.keys(c).some(function (t) {
          return v(_this27, tt, "f").skipValidation.indexOf(t) >= 0 && !0 === c[t];
        })), !o) {
          if (l.error) throw new e(l.error.message);

          if (!_m) {
            var _t24 = this[Kt](u, {}, l.error);

            i || (d = C(c, this, v(this, B, "f").getMiddleware(), !0)), d = this[Dt](_t24, null != d ? d : c), f(d) && !i && (d = d.then(function () {
              return C(c, _this27, v(_this27, B, "f").getMiddleware(), !1);
            }));
          }
        }
      } catch (t) {
        if (!(t instanceof e)) throw t;
        v(this, ut, "f").fail(t.message, t);
      }

      return this[Vt](null != d ? d : c, a, !!i, !0);
    }
  }, {
    key: Kt,
    value: function value(t, s, i, n) {
      var _this28 = this;

      var r = _objectSpread({}, this.getDemandedOptions());

      return function (o) {
        if (i) throw new e(i.message);
        v(_this28, gt, "f").nonOptionCount(o), v(_this28, gt, "f").requiredArguments(o, r);
        var a = !1;
        v(_this28, ft, "f") && (a = v(_this28, gt, "f").unknownCommands(o)), v(_this28, ct, "f") && !a ? v(_this28, gt, "f").unknownArguments(o, t, s, !!n) : v(_this28, dt, "f") && v(_this28, gt, "f").unknownArguments(o, t, {}, !1, !1), v(_this28, gt, "f").limitedChoices(o), v(_this28, gt, "f").implications(o), v(_this28, gt, "f").conflicting(o);
      };
    }
  }, {
    key: Bt,
    value: function value() {
      O(this, J, !0, "f");
    }
  }, {
    key: Yt,
    value: function value(t) {
      if ("string" == typeof t) v(this, tt, "f").key[t] = !0;else {
        var _iterator6 = _createForOfIteratorHelper(t),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _e21 = _step6.value;
            v(this, tt, "f").key[_e21] = !0;
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
    }
  }]);

  return Jt;
}((z = new WeakMap(), q = new WeakMap(), W = new WeakMap(), U = new WeakMap(), F = new WeakMap(), L = new WeakMap(), V = new WeakMap(), T = new WeakMap(), R = new WeakMap(), G = new WeakMap(), K = new WeakMap(), B = new WeakMap(), Y = new WeakMap(), J = new WeakMap(), Z = new WeakMap(), X = new WeakMap(), Q = new WeakMap(), tt = new WeakMap(), et = new WeakMap(), st = new WeakMap(), it = new WeakMap(), nt = new WeakMap(), rt = new WeakMap(), ot = new WeakMap(), at = new WeakMap(), ht = new WeakMap(), lt = new WeakMap(), ct = new WeakMap(), ft = new WeakMap(), dt = new WeakMap(), ut = new WeakMap(), pt = new WeakMap(), gt = new WeakMap(), mt));

var Zt, Xt;

var _require = require("fs"),
    Qt = _require.readFileSync,
    _require2 = require("util"),
    te = _require2.inspect,
    _require3 = require("path"),
    ee = _require3.resolve,
    se = require("y18n"),
    ie = require("@curlconverter/yargs-parser");

var ne,
    re = {
  assert: {
    notStrictEqual: t.notStrictEqual,
    strictEqual: t.strictEqual
  },
  cliui: require("cliui"),
  findUp: require("escalade/sync"),
  getEnv: function getEnv(t) {
    return process.env[t];
  },
  getCallerFile: require("get-caller-file"),
  getProcessArgvBin: y,
  inspect: te,
  mainFilename: null !== (Xt = null === (Zt = null === require || void 0 === require ? void 0 : require.main) || void 0 === Zt ? void 0 : Zt.filename) && void 0 !== Xt ? Xt : process.cwd(),
  Parser: ie,
  path: require("path"),
  process: {
    argv: function argv() {
      return process.argv;
    },
    cwd: process.cwd,
    emitWarning: function emitWarning(t, e) {
      return process.emitWarning(t, e);
    },
    execPath: function execPath() {
      return process.execPath;
    },
    exit: function exit(t) {
      process.exit(t);
    },
    nextTick: process.nextTick,
    stdColumns: void 0 !== process.stdout.columns ? process.stdout.columns : null
  },
  readFileSync: Qt,
  require: require,
  requireDirectory: require("require-directory"),
  stringWidth: require("string-width"),
  y18n: se({
    directory: ee(__dirname, "../locales"),
    updateFiles: !1
  })
};
var oe = (null === (ne = null === process || void 0 === process ? void 0 : process.env) || void 0 === ne ? void 0 : ne.YARGS_MIN_NODE_VERSION) ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;

if (process && process.version) {
  if (Number(process.version.match(/v([^.]+)/)[1]) < oe) throw Error("yargs supports a minimum Node.js version of ".concat(oe, ". Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions"));
}

var ae = require("@curlconverter/yargs-parser");

var he,
    le = {
  applyExtends: n,
  cjsPlatformShim: re,
  Yargs: (he = re, function () {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : he.process.cwd();
    var s = arguments.length > 2 ? arguments[2] : undefined;
    var i = new Jt(t, e, s, he);
    return Object.defineProperty(i, "argv", {
      get: function get() {
        return i.parse();
      },
      enumerable: !0
    }), i.help(), i.version(), i;
  }),
  argsert: h,
  isPromise: f,
  objFilter: g,
  parseCommand: o,
  Parser: ae,
  processArgv: b,
  YError: e
};
module.exports = le;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/toArray":345,"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/slicedToArray":120,"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/assertThisInitialized":41,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"@babel/runtime/helpers/wrapNativeSuper":194,"assert":-19260817,"fs":-19260817,"util":-19260817,"path":-19260817,"y18n":346,"@curlconverter/yargs-parser":347,"cliui":348,"escalade/sync":349,"get-caller-file":350,"require-directory":351,"string-width":352}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/asap/asap.js
      286: {
        factory: (module, exports, require) => {
          "use strict";

var rawAsap = require("./raw");

var freeTasks = [];
/**
 * Calls a task as soon as possible after returning, in its own event, with
 * priority over IO events. An exception thrown in a task can be handled by
 * `process.on("uncaughtException") or `domain.on("error")`, but will otherwise
 * crash the process. If the error is handled, all subsequent tasks will
 * resume.
 *
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */

module.exports = asap;

function asap(task) {
  var rawTask;

  if (freeTasks.length) {
    rawTask = freeTasks.pop();
  } else {
    rawTask = new RawTask();
  }

  rawTask.task = task;
  rawTask.domain = process.domain;
  rawAsap(rawTask);
}

function RawTask() {
  this.task = null;
  this.domain = null;
}

RawTask.prototype.call = function () {
  if (this.domain) {
    this.domain.enter();
  }

  var threw = true;

  try {
    this.task.call();
    threw = false; // If the task throws an exception (presumably) Node.js restores the
    // domain stack for the next event.

    if (this.domain) {
      this.domain.exit();
    }
  } finally {
    // We use try/finally and a threw flag to avoid messing up stack traces
    // when we catch and release errors.
    if (threw) {
      // In Node.js, uncaught exceptions are considered fatal errors.
      // Re-throw them to interrupt flushing!
      // Ensure that flushing continues if an uncaught exception is
      // suppressed listening process.on("uncaughtException") or
      // domain.on("error").
      rawAsap.requestFlush();
    } // If the task threw an error, we do not want to exit the domain here.
    // Exiting the domain would prevent the domain from catching the error.


    this.task = null;
    this.domain = null;
    freeTasks.push(this);
  }
};
        },
        map: {"./raw":353}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/a-sync-waterfall/index.js
      287: {
        factory: (module, exports, require) => {
          // MIT license (by Elan Shanker).
(function (globals) {
  'use strict';

  var executeSync = function executeSync() {
    var args = Array.prototype.slice.call(arguments);

    if (typeof args[0] === 'function') {
      args[0].apply(null, args.splice(1));
    }
  };

  var executeAsync = function executeAsync(fn) {
    if (typeof setImmediate === 'function') {
      setImmediate(fn);
    } else if (typeof process !== 'undefined' && process.nextTick) {
      process.nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  };

  var makeIterator = function makeIterator(tasks) {
    var makeCallback = function makeCallback(index) {
      var fn = function fn() {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }

        return fn.next();
      };

      fn.next = function () {
        return index < tasks.length - 1 ? makeCallback(index + 1) : null;
      };

      return fn;
    };

    return makeCallback(0);
  };

  var _isArray = Array.isArray || function (maybeArray) {
    return Object.prototype.toString.call(maybeArray) === '[object Array]';
  };

  var waterfall = function waterfall(tasks, callback, forceAsync) {
    var nextTick = forceAsync ? executeAsync : executeSync;

    callback = callback || function () {};

    if (!_isArray(tasks)) {
      var err = new Error('First argument to waterfall must be an array of functions');
      return callback(err);
    }

    if (!tasks.length) {
      return callback();
    }

    var wrapIterator = function wrapIterator(iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);

          callback = function callback() {};
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();

          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }

          nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };

    wrapIterator(makeIterator(tasks))();
  };

  if (typeof define !== 'undefined' && define.amd) {
    define([], function () {
      return waterfall;
    }); // RequireJS
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = waterfall; // CommonJS
  } else {
    globals.waterfall = waterfall; // <script>
  }
})(this);
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/filters.js
      288: {
        factory: (module, exports, require) => {
          'use strict';

var lib = require('./lib');

var r = require('./runtime');

var _exports = module.exports = {};

function normalize(value, defaultValue) {
  if (value === null || value === undefined || value === false) {
    return defaultValue;
  }

  return value;
}

_exports.abs = Math.abs;

function isNaN(num) {
  return num !== num; // eslint-disable-line no-self-compare
}

function batch(arr, linecount, fillWith) {
  var i;
  var res = [];
  var tmp = [];

  for (i = 0; i < arr.length; i++) {
    if (i % linecount === 0 && tmp.length) {
      res.push(tmp);
      tmp = [];
    }

    tmp.push(arr[i]);
  }

  if (tmp.length) {
    if (fillWith) {
      for (i = tmp.length; i < linecount; i++) {
        tmp.push(fillWith);
      }
    }

    res.push(tmp);
  }

  return res;
}

_exports.batch = batch;

function capitalize(str) {
  str = normalize(str, '');
  var ret = str.toLowerCase();
  return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
}

_exports.capitalize = capitalize;

function center(str, width) {
  str = normalize(str, '');
  width = width || 80;

  if (str.length >= width) {
    return str;
  }

  var spaces = width - str.length;
  var pre = lib.repeat(' ', spaces / 2 - spaces % 2);
  var post = lib.repeat(' ', spaces / 2);
  return r.copySafeness(str, pre + str + post);
}

_exports.center = center;

function default_(val, def, bool) {
  if (bool) {
    return val || def;
  } else {
    return val !== undefined ? val : def;
  }
} // TODO: it is confusing to export something called 'default'


_exports['default'] = default_; // eslint-disable-line dot-notation

function dictsort(val, caseSensitive, by) {
  if (!lib.isObject(val)) {
    throw new lib.TemplateError('dictsort filter: val must be an object');
  }

  var array = []; // deliberately include properties from the object's prototype

  for (var k in val) {
    // eslint-disable-line guard-for-in, no-restricted-syntax
    array.push([k, val[k]]);
  }

  var si;

  if (by === undefined || by === 'key') {
    si = 0;
  } else if (by === 'value') {
    si = 1;
  } else {
    throw new lib.TemplateError('dictsort filter: You can only sort by either key or value');
  }

  array.sort(function (t1, t2) {
    var a = t1[si];
    var b = t2[si];

    if (!caseSensitive) {
      if (lib.isString(a)) {
        a = a.toUpperCase();
      }

      if (lib.isString(b)) {
        b = b.toUpperCase();
      }
    }

    return a > b ? 1 : a === b ? 0 : -1; // eslint-disable-line no-nested-ternary
  });
  return array;
}

_exports.dictsort = dictsort;

function dump(obj, spaces) {
  return JSON.stringify(obj, null, spaces);
}

_exports.dump = dump;

function escape(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

_exports.escape = escape;

function safe(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(str.toString());
}

_exports.safe = safe;

function first(arr) {
  return arr[0];
}

_exports.first = first;

function forceescape(str) {
  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

_exports.forceescape = forceescape;

function groupby(arr, attr) {
  return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
}

_exports.groupby = groupby;

function indent(str, width, indentfirst) {
  str = normalize(str, '');

  if (str === '') {
    return '';
  }

  width = width || 4; // let res = '';

  var lines = str.split('\n');
  var sp = lib.repeat(' ', width);
  var res = lines.map(function (l, i) {
    return i === 0 && !indentfirst ? l : "" + sp + l;
  }).join('\n');
  return r.copySafeness(str, res);
}

_exports.indent = indent;

function join(arr, del, attr) {
  del = del || '';

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return arr.join(del);
}

_exports.join = join;

function last(arr) {
  return arr[arr.length - 1];
}

_exports.last = last;

function lengthFilter(val) {
  var value = normalize(val, '');

  if (value !== undefined) {
    if (typeof Map === 'function' && value instanceof Map || typeof Set === 'function' && value instanceof Set) {
      // ECMAScript 2015 Maps and Sets
      return value.size;
    }

    if (lib.isObject(value) && !(value instanceof r.SafeString)) {
      // Objects (besides SafeStrings), non-primative Arrays
      return lib.keys(value).length;
    }

    return value.length;
  }

  return 0;
}

_exports.length = lengthFilter;

function list(val) {
  if (lib.isString(val)) {
    return val.split('');
  } else if (lib.isObject(val)) {
    return lib._entries(val || {}).map(function (_ref) {
      var key = _ref[0],
          value = _ref[1];
      return {
        key: key,
        value: value
      };
    });
  } else if (lib.isArray(val)) {
    return val;
  } else {
    throw new lib.TemplateError('list filter: type not iterable');
  }
}

_exports.list = list;

function lower(str) {
  str = normalize(str, '');
  return str.toLowerCase();
}

_exports.lower = lower;

function nl2br(str) {
  if (str === null || str === undefined) {
    return '';
  }

  return r.copySafeness(str, str.replace(/\r\n|\n/g, '<br />\n'));
}

_exports.nl2br = nl2br;

function random(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

_exports.random = random;
/**
 * Construct select or reject filter
 *
 * @param {boolean} expectedTestResult
 * @returns {function(array, string, *): array}
 */

function getSelectOrReject(expectedTestResult) {
  function filter(arr, testName, secondArg) {
    if (testName === void 0) {
      testName = 'truthy';
    }

    var context = this;
    var test = context.env.getTest(testName);
    return lib.toArray(arr).filter(function examineTestResult(item) {
      return test.call(context, item, secondArg) === expectedTestResult;
    });
  }

  return filter;
}

_exports.reject = getSelectOrReject(false);

function rejectattr(arr, attr) {
  return arr.filter(function (item) {
    return !item[attr];
  });
}

_exports.rejectattr = rejectattr;
_exports.select = getSelectOrReject(true);

function selectattr(arr, attr) {
  return arr.filter(function (item) {
    return !!item[attr];
  });
}

_exports.selectattr = selectattr;

function replace(str, old, new_, maxCount) {
  var originalStr = str;

  if (old instanceof RegExp) {
    return str.replace(old, new_);
  }

  if (typeof maxCount === 'undefined') {
    maxCount = -1;
  }

  var res = ''; // Output
  // Cast Numbers in the search term to string

  if (typeof old === 'number') {
    old = '' + old;
  } else if (typeof old !== 'string') {
    // If it is something other than number or string,
    // return the original string
    return str;
  } // Cast numbers in the replacement to string


  if (typeof str === 'number') {
    str = '' + str;
  } // If by now, we don't have a string, throw it back


  if (typeof str !== 'string' && !(str instanceof r.SafeString)) {
    return str;
  } // ShortCircuits


  if (old === '') {
    // Mimic the python behaviour: empty string is replaced
    // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
    res = new_ + str.split('').join(new_) + new_;
    return r.copySafeness(str, res);
  }

  var nextIndex = str.indexOf(old); // if # of replacements to perform is 0, or the string to does
  // not contain the old value, return the string

  if (maxCount === 0 || nextIndex === -1) {
    return str;
  }

  var pos = 0;
  var count = 0; // # of replacements made

  while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
    // Grab the next chunk of src string and add it with the
    // replacement, to the result
    res += str.substring(pos, nextIndex) + new_; // Increment our pointer in the src string

    pos = nextIndex + old.length;
    count++; // See if there are any more replacements to be made

    nextIndex = str.indexOf(old, pos);
  } // We've either reached the end, or done the max # of
  // replacements, tack on any remaining string


  if (pos < str.length) {
    res += str.substring(pos);
  }

  return r.copySafeness(originalStr, res);
}

_exports.replace = replace;

function reverse(val) {
  var arr;

  if (lib.isString(val)) {
    arr = list(val);
  } else {
    // Copy it
    arr = lib.map(val, function (v) {
      return v;
    });
  }

  arr.reverse();

  if (lib.isString(val)) {
    return r.copySafeness(val, arr.join(''));
  }

  return arr;
}

_exports.reverse = reverse;

function round(val, precision, method) {
  precision = precision || 0;
  var factor = Math.pow(10, precision);
  var rounder;

  if (method === 'ceil') {
    rounder = Math.ceil;
  } else if (method === 'floor') {
    rounder = Math.floor;
  } else {
    rounder = Math.round;
  }

  return rounder(val * factor) / factor;
}

_exports.round = round;

function slice(arr, slices, fillWith) {
  var sliceLength = Math.floor(arr.length / slices);
  var extra = arr.length % slices;
  var res = [];
  var offset = 0;

  for (var i = 0; i < slices; i++) {
    var start = offset + i * sliceLength;

    if (i < extra) {
      offset++;
    }

    var end = offset + (i + 1) * sliceLength;
    var currSlice = arr.slice(start, end);

    if (fillWith && i >= extra) {
      currSlice.push(fillWith);
    }

    res.push(currSlice);
  }

  return res;
}

_exports.slice = slice;

function sum(arr, attr, start) {
  if (start === void 0) {
    start = 0;
  }

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return start + arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

_exports.sum = sum;
_exports.sort = r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function sortFilter(arr, reversed, caseSens, attr) {
  var _this = this; // Copy it


  var array = lib.map(arr, function (v) {
    return v;
  });
  var getAttribute = lib.getAttrGetter(attr);
  array.sort(function (a, b) {
    var x = attr ? getAttribute(a) : a;
    var y = attr ? getAttribute(b) : b;

    if (_this.env.opts.throwOnUndefined && attr && (x === undefined || y === undefined)) {
      throw new TypeError("sort: attribute \"" + attr + "\" resolved to undefined");
    }

    if (!caseSens && lib.isString(x) && lib.isString(y)) {
      x = x.toLowerCase();
      y = y.toLowerCase();
    }

    if (x < y) {
      return reversed ? 1 : -1;
    } else if (x > y) {
      return reversed ? -1 : 1;
    } else {
      return 0;
    }
  });
  return array;
});

function string(obj) {
  return r.copySafeness(obj, obj);
}

_exports.string = string;

function striptags(input, preserveLinebreaks) {
  input = normalize(input, '');
  var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
  var trimmedInput = trim(input.replace(tags, ''));
  var res = '';

  if (preserveLinebreaks) {
    res = trimmedInput.replace(/^ +| +$/gm, '') // remove leading and trailing spaces
    .replace(/ +/g, ' ') // squash adjacent spaces
    .replace(/(\r\n)/g, '\n') // normalize linebreaks (CRLF -> LF)
    .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
  } else {
    res = trimmedInput.replace(/\s+/gi, ' ');
  }

  return r.copySafeness(input, res);
}

_exports.striptags = striptags;

function title(str) {
  str = normalize(str, '');
  var words = str.split(' ').map(function (word) {
    return capitalize(word);
  });
  return r.copySafeness(str, words.join(' '));
}

_exports.title = title;

function trim(str) {
  return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
}

_exports.trim = trim;

function truncate(input, length, killwords, end) {
  var orig = input;
  input = normalize(input, '');
  length = length || 255;

  if (input.length <= length) {
    return input;
  }

  if (killwords) {
    input = input.substring(0, length);
  } else {
    var idx = input.lastIndexOf(' ', length);

    if (idx === -1) {
      idx = length;
    }

    input = input.substring(0, idx);
  }

  input += end !== undefined && end !== null ? end : '...';
  return r.copySafeness(orig, input);
}

_exports.truncate = truncate;

function upper(str) {
  str = normalize(str, '');
  return str.toUpperCase();
}

_exports.upper = upper;

function urlencode(obj) {
  var enc = encodeURIComponent;

  if (lib.isString(obj)) {
    return enc(obj);
  } else {
    var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
    return keyvals.map(function (_ref2) {
      var k = _ref2[0],
          v = _ref2[1];
      return enc(k) + "=" + enc(v);
    }).join('&');
  }
}

_exports.urlencode = urlencode; // For the jinja regexp, see
// https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23

var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/; // from http://blog.gerv.net/2011/05/html5_email_address_regexp/

var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
var httpHttpsRe = /^https?:\/\/.*$/;
var wwwRe = /^www\./;
var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;

function urlize(str, length, nofollow) {
  if (isNaN(length)) {
    length = Infinity;
  }

  var noFollowAttr = nofollow === true ? ' rel="nofollow"' : '';
  var words = str.split(/(\s+)/).filter(function (word) {
    // If the word has no length, bail. This can happen for str with
    // trailing whitespace.
    return word && word.length;
  }).map(function (word) {
    var matches = word.match(puncRe);
    var possibleUrl = matches ? matches[1] : word;
    var shortUrl = possibleUrl.substr(0, length); // url that starts with http or https

    if (httpHttpsRe.test(possibleUrl)) {
      return "<a href=\"" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // url that starts with www.


    if (wwwRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // an email address of the form username@domain.tld


    if (emailRe.test(possibleUrl)) {
      return "<a href=\"mailto:" + possibleUrl + "\">" + possibleUrl + "</a>";
    } // url that ends in .com, .org or .net that is not an email address


    if (tldRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    }

    return word;
  });
  return words.join('');
}

_exports.urlize = urlize;

function wordcount(str) {
  str = normalize(str, '');
  var words = str ? str.match(/\w+/g) : null;
  return words ? words.length : null;
}

_exports.wordcount = wordcount;

function _float(val, def) {
  var res = parseFloat(val);
  return isNaN(res) ? def : res;
}

_exports["float"] = _float;
var intFilter = r.makeMacro(['value', 'default', 'base'], [], function doInt(value, defaultValue, base) {
  if (base === void 0) {
    base = 10;
  }

  var res = parseInt(value, base);
  return isNaN(res) ? defaultValue : res;
});
_exports["int"] = intFilter; // Aliases

_exports.d = _exports["default"];
_exports.e = _exports.escape;
        },
        map: {"./lib":200,"./runtime":208}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/tests.js
      289: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var SafeString = require('./runtime').SafeString;
/**
 * Returns `true` if the object is a function, otherwise `false`.
 * @param { any } value
 * @returns { boolean }
 */


function callable(value) {
  return typeof value === 'function';
}

exports.callable = callable;
/**
 * Returns `true` if the object is strictly not `undefined`.
 * @param { any } value
 * @returns { boolean }
 */

function defined(value) {
  return value !== undefined;
}

exports.defined = defined;
/**
 * Returns `true` if the operand (one) is divisble by the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function divisibleby(one, two) {
  return one % two === 0;
}

exports.divisibleby = divisibleby;
/**
 * Returns true if the string has been escaped (i.e., is a SafeString).
 * @param { any } value
 * @returns { boolean }
 */

function escaped(value) {
  return value instanceof SafeString;
}

exports.escaped = escaped;
/**
 * Returns `true` if the arguments are strictly equal.
 * @param { any } one
 * @param { any } two
 */

function equalto(one, two) {
  return one === two;
}

exports.equalto = equalto; // Aliases

exports.eq = exports.equalto;
exports.sameas = exports.equalto;
/**
 * Returns `true` if the value is evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function even(value) {
  return value % 2 === 0;
}

exports.even = even;
/**
 * Returns `true` if the value is falsy - if I recall correctly, '', 0, false,
 * undefined, NaN or null. I don't know if we should stick to the default JS
 * behavior or attempt to replicate what Python believes should be falsy (i.e.,
 * empty arrays, empty dicts, not 0...).
 * @param { any } value
 * @returns { boolean }
 */

function falsy(value) {
  return !value;
}

exports.falsy = falsy;
/**
 * Returns `true` if the operand (one) is greater or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ge(one, two) {
  return one >= two;
}

exports.ge = ge;
/**
 * Returns `true` if the operand (one) is greater than the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function greaterthan(one, two) {
  return one > two;
}

exports.greaterthan = greaterthan; // alias

exports.gt = exports.greaterthan;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function le(one, two) {
  return one <= two;
}

exports.le = le;
/**
 * Returns `true` if the operand (one) is less than the test's passed argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function lessthan(one, two) {
  return one < two;
}

exports.lessthan = lessthan; // alias

exports.lt = exports.lessthan;
/**
 * Returns `true` if the string is lowercased.
 * @param { string } value
 * @returns { boolean }
 */

function lower(value) {
  return value.toLowerCase() === value;
}

exports.lower = lower;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ne(one, two) {
  return one !== two;
}

exports.ne = ne;
/**
 * Returns true if the value is strictly equal to `null`.
 * @param { any }
 * @returns { boolean }
 */

function nullTest(value) {
  return value === null;
}

exports["null"] = nullTest;
/**
 * Returns true if value is a number.
 * @param { any }
 * @returns { boolean }
 */

function number(value) {
  return typeof value === 'number';
}

exports.number = number;
/**
 * Returns `true` if the value is *not* evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function odd(value) {
  return value % 2 === 1;
}

exports.odd = odd;
/**
 * Returns `true` if the value is a string, `false` if not.
 * @param { any } value
 * @returns { boolean }
 */

function string(value) {
  return typeof value === 'string';
}

exports.string = string;
/**
 * Returns `true` if the value is not in the list of things considered falsy:
 * '', null, undefined, 0, NaN and false.
 * @param { any } value
 * @returns { boolean }
 */

function truthy(value) {
  return !!value;
}

exports.truthy = truthy;
/**
 * Returns `true` if the value is undefined.
 * @param { any } value
 * @returns { boolean }
 */

function undefinedTest(value) {
  return value === undefined;
}

exports.undefined = undefinedTest;
/**
 * Returns `true` if the string is uppercased.
 * @param { string } value
 * @returns { boolean }
 */

function upper(value) {
  return value.toUpperCase() === value;
}

exports.upper = upper;
/**
 * If ES6 features are available, returns `true` if the value implements the
 * `Symbol.iterator` method. If not, it's a string or Array.
 *
 * Could potentially cause issues if a browser exists that has Set and Map but
 * not Symbol.
 *
 * @param { any } value
 * @returns { boolean }
 */

function iterable(value) {
  if (typeof Symbol !== 'undefined') {
    return !!value[Symbol.iterator];
  } else {
    return Array.isArray(value) || typeof value === 'string';
  }
}

exports.iterable = iterable;
/**
 * If ES6 features are available, returns `true` if the value is an object hash
 * or an ES6 Map. Otherwise just return if it's an object hash.
 * @param { any } value
 * @returns { boolean }
 */

function mapping(value) {
  // only maps and object hashes
  var bool = value !== null && value !== undefined && _typeof(value) === 'object' && !Array.isArray(value);

  if (Set) {
    return bool && !(value instanceof Set);
  } else {
    return bool;
  }
}

exports.mapping = mapping;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./runtime":208}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/globals.js
      290: {
        factory: (module, exports, require) => {
          'use strict';

function _cycler(items) {
  var index = -1;
  return {
    current: null,
    reset: function reset() {
      index = -1;
      this.current = null;
    },
    next: function next() {
      index++;

      if (index >= items.length) {
        index = 0;
      }

      this.current = items[index];
      return this.current;
    }
  };
}

function _joiner(sep) {
  sep = sep || ',';
  var first = true;
  return function () {
    var val = first ? '' : sep;
    first = false;
    return val;
  };
} // Making this a function instead so it returns a new object
// each time it's called. That way, if something like an environment
// uses it, they will each have their own copy.


function globals() {
  return {
    range: function range(start, stop, step) {
      if (typeof stop === 'undefined') {
        stop = start;
        start = 0;
        step = 1;
      } else if (!step) {
        step = 1;
      }

      var arr = [];

      if (step > 0) {
        for (var i = start; i < stop; i += step) {
          arr.push(i);
        }
      } else {
        for (var _i = start; _i > stop; _i += step) {
          // eslint-disable-line for-direction
          arr.push(_i);
        }
      }

      return arr;
    },
    cycler: function cycler() {
      return _cycler(Array.prototype.slice.call(arguments));
    },
    joiner: function joiner(sep) {
      return _joiner(sep);
    }
  };
}

module.exports = globals;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/object.js
      291: {
        factory: (module, exports, require) => {
          'use strict'; // A simple class system, more documentation to come

var _typeof = require("@babel/runtime/helpers/typeof");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var EventEmitter = require('events');

var lib = require('./lib');

function parentWrap(parent, prop) {
  if (typeof parent !== 'function' || typeof prop !== 'function') {
    return prop;
  }

  return function wrap() {
    // Save the current parent method
    var tmp = this.parent; // Set parent to the previous method, call, and restore

    this.parent = parent;
    var res = prop.apply(this, arguments);
    this.parent = tmp;
    return res;
  };
}

function extendClass(cls, name, props) {
  props = props || {};
  lib.keys(props).forEach(function (k) {
    props[k] = parentWrap(cls.prototype[k], props[k]);
  });

  var subclass = /*#__PURE__*/function (_cls) {
    _inheritsLoose(subclass, _cls);

    function subclass() {
      return _cls.apply(this, arguments) || this;
    }

    _createClass(subclass, [{
      key: "typename",
      get: function get() {
        return name;
      }
    }]);

    return subclass;
  }(cls);

  lib._assign(subclass.prototype, props);

  return subclass;
}

var Obj = /*#__PURE__*/function () {
  function Obj() {
    // Unfortunately necessary for backwards compatibility
    this.init.apply(this, arguments);
  }

  var _proto = Obj.prototype;

  _proto.init = function init() {};

  Obj.extend = function extend(name, props) {
    if (_typeof(name) === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(Obj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return Obj;
}();

var EmitterObj = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(EmitterObj, _EventEmitter);

  function EmitterObj() {
    var _this2;

    var _this;

    _this = _EventEmitter.call(this) || this; // Unfortunately necessary for backwards compatibility

    (_this2 = _this).init.apply(_this2, arguments);

    return _this;
  }

  var _proto2 = EmitterObj.prototype;

  _proto2.init = function init() {};

  EmitterObj.extend = function extend(name, props) {
    if (_typeof(name) === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(EmitterObj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return EmitterObj;
}(EventEmitter);

module.exports = {
  Obj: Obj,
  EmitterObj: EmitterObj
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"events":-19260817,"./lib":200}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/express-app.js
      292: {
        factory: (module, exports, require) => {
          "use strict";

var path = require('path');

module.exports = function express(env, app) {
  function NunjucksView(name, opts) {
    this.name = name;
    this.path = name;
    this.defaultEngine = opts.defaultEngine;
    this.ext = path.extname(name);

    if (!this.ext && !this.defaultEngine) {
      throw new Error('No default engine was specified and no extension was provided.');
    }

    if (!this.ext) {
      this.name += this.ext = (this.defaultEngine[0] !== '.' ? '.' : '') + this.defaultEngine;
    }
  }

  NunjucksView.prototype.render = function render(opts, cb) {
    env.render(this.name, opts, cb);
  };

  app.set('view', NunjucksView);
  app.set('nunjucksEnv', env);
  return env;
};
        },
        map: {"path":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/node-loaders.js
      293: {
        factory: (module, exports, require) => {
          /* eslint-disable no-console */
'use strict';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var fs = require('fs');

var path = require('path');

var Loader = require('./loader');

var _require = require('./precompiled-loader.js'),
    PrecompiledLoader = _require.PrecompiledLoader;

var chokidar;

var FileSystemLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(FileSystemLoader, _Loader);

  function FileSystemLoader(searchPaths, opts) {
    var _this;

    _this = _Loader.call(this) || this;

    if (typeof opts === 'boolean') {
      console.log('[nunjucks] Warning: you passed a boolean as the second ' + 'argument to FileSystemLoader, but it now takes an options ' + 'object. See http://mozilla.github.io/nunjucks/api.html#filesystemloader');
    }

    opts = opts || {};
    _this.pathsToNames = {};
    _this.noCache = !!opts.noCache;

    if (searchPaths) {
      searchPaths = Array.isArray(searchPaths) ? searchPaths : [searchPaths]; // For windows, convert to forward slashes

      _this.searchPaths = searchPaths.map(path.normalize);
    } else {
      _this.searchPaths = ['.'];
    }

    if (opts.watch) {
      // Watch all the templates in the paths and fire an event when
      // they change
      try {
        chokidar = require('chokidar'); // eslint-disable-line global-require
      } catch (e) {
        throw new Error('watch requires chokidar to be installed');
      }

      var paths = _this.searchPaths.filter(fs.existsSync);

      var watcher = chokidar.watch(paths);
      watcher.on('all', function (event, fullname) {
        fullname = path.resolve(fullname);

        if (event === 'change' && fullname in _this.pathsToNames) {
          _this.emit('update', _this.pathsToNames[fullname], fullname);
        }
      });
      watcher.on('error', function (error) {
        console.log('Watcher error: ' + error);
      });
    }

    return _this;
  }

  var _proto = FileSystemLoader.prototype;

  _proto.getSource = function getSource(name) {
    var fullpath = null;
    var paths = this.searchPaths;

    for (var i = 0; i < paths.length; i++) {
      var basePath = path.resolve(paths[i]);
      var p = path.resolve(paths[i], name); // Only allow the current directory and anything
      // underneath it to be searched

      if (p.indexOf(basePath) === 0 && fs.existsSync(p)) {
        fullpath = p;
        break;
      }
    }

    if (!fullpath) {
      return null;
    }

    this.pathsToNames[fullpath] = name;
    var source = {
      src: fs.readFileSync(fullpath, 'utf-8'),
      path: fullpath,
      noCache: this.noCache
    };
    this.emit('load', name, source);
    return source;
  };

  return FileSystemLoader;
}(Loader);

var NodeResolveLoader = /*#__PURE__*/function (_Loader2) {
  _inheritsLoose(NodeResolveLoader, _Loader2);

  function NodeResolveLoader(opts) {
    var _this2;

    _this2 = _Loader2.call(this) || this;
    opts = opts || {};
    _this2.pathsToNames = {};
    _this2.noCache = !!opts.noCache;

    if (opts.watch) {
      try {
        chokidar = require('chokidar'); // eslint-disable-line global-require
      } catch (e) {
        throw new Error('watch requires chokidar to be installed');
      }

      _this2.watcher = chokidar.watch();

      _this2.watcher.on('change', function (fullname) {
        _this2.emit('update', _this2.pathsToNames[fullname], fullname);
      });

      _this2.watcher.on('error', function (error) {
        console.log('Watcher error: ' + error);
      });

      _this2.on('load', function (name, source) {
        _this2.watcher.add(source.path);
      });
    }

    return _this2;
  }

  var _proto2 = NodeResolveLoader.prototype;

  _proto2.getSource = function getSource(name) {
    // Don't allow file-system traversal
    if (/^\.?\.?(\/|\\)/.test(name)) {
      return null;
    }

    if (/^[A-Z]:/.test(name)) {
      return null;
    }

    var fullpath;

    try {
      fullpath = require.resolve(name);
    } catch (e) {
      return null;
    }

    this.pathsToNames[fullpath] = name;
    var source = {
      src: fs.readFileSync(fullpath, 'utf-8'),
      path: fullpath,
      noCache: this.noCache
    };
    this.emit('load', name, source);
    return source;
  };

  return NodeResolveLoader;
}(Loader);

module.exports = {
  FileSystemLoader: FileSystemLoader,
  PrecompiledLoader: PrecompiledLoader,
  NodeResolveLoader: NodeResolveLoader
};
        },
        map: {"fs":-19260817,"path":-19260817,"./loader":202,"./precompiled-loader.js":354,"chokidar":355}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/precompile-global.js
      294: {
        factory: (module, exports, require) => {
          'use strict';

function precompileGlobal(templates, opts) {
  var out = '';
  opts = opts || {};

  for (var i = 0; i < templates.length; i++) {
    var name = JSON.stringify(templates[i].name);
    var template = templates[i].template;
    out += '(function() {' + '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' + '[' + name + '] = (function() {\n' + template + '\n})();\n';

    if (opts.asFunction) {
      out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\n';
    }

    out += '})();\n';
  }

  return out;
}

module.exports = precompileGlobal;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/transformer.js
      295: {
        factory: (module, exports, require) => {
          'use strict';

var nodes = require('./nodes');

var lib = require('./lib');

var sym = 0;

function gensym() {
  return 'hole_' + sym++;
} // copy-on-write version of map


function mapCOW(arr, func) {
  var res = null;

  for (var i = 0; i < arr.length; i++) {
    var item = func(arr[i]);

    if (item !== arr[i]) {
      if (!res) {
        res = arr.slice();
      }

      res[i] = item;
    }
  }

  return res || arr;
}

function walk(ast, func, depthFirst) {
  if (!(ast instanceof nodes.Node)) {
    return ast;
  }

  if (!depthFirst) {
    var astT = func(ast);

    if (astT && astT !== ast) {
      return astT;
    }
  }

  if (ast instanceof nodes.NodeList) {
    var children = mapCOW(ast.children, function (node) {
      return walk(node, func, depthFirst);
    });

    if (children !== ast.children) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
    }
  } else if (ast instanceof nodes.CallExtension) {
    var args = walk(ast.args, func, depthFirst);
    var contentArgs = mapCOW(ast.contentArgs, function (node) {
      return walk(node, func, depthFirst);
    });

    if (args !== ast.args || contentArgs !== ast.contentArgs) {
      ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
    }
  } else {
    var props = ast.fields.map(function (field) {
      return ast[field];
    });
    var propsT = mapCOW(props, function (prop) {
      return walk(prop, func, depthFirst);
    });

    if (propsT !== props) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno);
      propsT.forEach(function (prop, i) {
        ast[ast.fields[i]] = prop;
      });
    }
  }

  return depthFirst ? func(ast) || ast : ast;
}

function depthWalk(ast, func) {
  return walk(ast, func, true);
}

function _liftFilters(node, asyncFilters, prop) {
  var children = [];
  var walked = depthWalk(prop ? node[prop] : node, function (descNode) {
    var symbol;

    if (descNode instanceof nodes.Block) {
      return descNode;
    } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
      symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
      children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
    }

    return symbol;
  });

  if (prop) {
    node[prop] = walked;
  } else {
    node = walked;
  }

  if (children.length) {
    children.push(node);
    return new nodes.NodeList(node.lineno, node.colno, children);
  } else {
    return node;
  }
}

function liftFilters(ast, asyncFilters) {
  return depthWalk(ast, function (node) {
    if (node instanceof nodes.Output) {
      return _liftFilters(node, asyncFilters);
    } else if (node instanceof nodes.Set) {
      return _liftFilters(node, asyncFilters, 'value');
    } else if (node instanceof nodes.For) {
      return _liftFilters(node, asyncFilters, 'arr');
    } else if (node instanceof nodes.If) {
      return _liftFilters(node, asyncFilters, 'cond');
    } else if (node instanceof nodes.CallExtension) {
      return _liftFilters(node, asyncFilters, 'args');
    } else {
      return undefined;
    }
  });
}

function liftSuper(ast) {
  return walk(ast, function (blockNode) {
    if (!(blockNode instanceof nodes.Block)) {
      return;
    }

    var hasSuper = false;
    var symbol = gensym();
    blockNode.body = walk(blockNode.body, function (node) {
      // eslint-disable-line consistent-return
      if (node instanceof nodes.FunCall && node.name.value === 'super') {
        hasSuper = true;
        return new nodes.Symbol(node.lineno, node.colno, symbol);
      }
    });

    if (hasSuper) {
      blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
    }
  });
}

function convertStatements(ast) {
  return depthWalk(ast, function (node) {
    if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
      return undefined;
    }

    var async = false;
    walk(node, function (child) {
      if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
        async = true; // Stop iterating by returning the node

        return child;
      }

      return undefined;
    });

    if (async) {
      if (node instanceof nodes.If) {
        return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
      } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
        return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
      }
    }

    return undefined;
  });
}

function cps(ast, asyncFilters) {
  return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
}

function transform(ast, asyncFilters) {
  return cps(ast, asyncFilters || []);
} // var parser = require('./parser');
// var src = 'hello {% foo %}{% endfoo %} end';
// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
// nodes.printNodes(ast);


module.exports = {
  transform: transform
};
        },
        map: {"./nodes":209,"./lib":200}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/call-bind/index.js
      296: {
        factory: (module, exports, require) => {
          'use strict';

var bind = require('function-bind');

var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
  }
}

module.exports = function callBind(originalFunction) {
  var func = $reflectApply(bind, $call, arguments);

  if ($gOPD && $defineProperty) {
    var desc = $gOPD(func, 'length');

    if (desc.configurable) {
      // original length, plus the receiver, minus any additional arguments (after the receiver)
      $defineProperty(func, 'length', {
        value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
      });
    }
  }

  return func;
};

var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}
        },
        map: {"function-bind":329,"get-intrinsic":266}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/object-keys/index.js
      297: {
        factory: (module, exports, require) => {
          'use strict';

var slice = Array.prototype.slice;

var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : require('./implementation');
var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);

    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }

        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }

  return Object.keys || keysShim;
};

module.exports = keysShim;
        },
        map: {"./isArguments":356,"./implementation":357}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/helpers/callBound.js
      298: {
        factory: (module, exports, require) => {
          'use strict'; // TODO; semver-major: remove

module.exports = require('call-bind/callBound');
        },
        map: {"call-bind/callBound":267}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/2019/RequireObjectCoercible.js
      299: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = require('../5/CheckObjectCoercible');
        },
        map: {"../5/CheckObjectCoercible":358}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/2019/ToString.js
      300: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = GetIntrinsic('%TypeError%'); // https://ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function ToString(argument) {
  if (_typeof(argument) === 'symbol') {
    throw new $TypeError('Cannot convert a Symbol value to a string');
  }

  return $String(argument);
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"get-intrinsic":266}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/2019/IsRegExp.js
      301: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');

var ToBoolean = require('./ToBoolean'); // https://ecma-international.org/ecma-262/6.0/#sec-isregexp


module.exports = function IsRegExp(argument) {
  if (!argument || _typeof(argument) !== 'object') {
    return false;
  }

  if ($match) {
    var isRegExp = argument[$match];

    if (typeof isRegExp !== 'undefined') {
      return ToBoolean(isRegExp);
    }
  }

  return hasRegExpMatcher(argument);
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"get-intrinsic":266,"is-regex":359,"./ToBoolean":360}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/2019/ToInteger.js
      302: {
        factory: (module, exports, require) => {
          'use strict';

var ES5ToInteger = require('../5/ToInteger');

var ToNumber = require('./ToNumber'); // https://ecma-international.org/ecma-262/6.0/#sec-tointeger


module.exports = function ToInteger(value) {
  var number = ToNumber(value);
  return ES5ToInteger(number);
};
        },
        map: {"../5/ToInteger":361,"./ToNumber":362}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Inline.js
      303: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

// Generated by CoffeeScript 1.12.4
var DumpException,
    Escaper,
    Inline,
    ParseException,
    ParseMore,
    Pattern,
    Unescaper,
    Utils,
    indexOf = [].indexOf || function (item) {
  for (var i = 0, l = this.length; i < l; i++) {
    if (i in this && this[i] === item) return i;
  }

  return -1;
};

Pattern = require('./Pattern');
Unescaper = require('./Unescaper');
Escaper = require('./Escaper');
Utils = require('./Utils');
ParseException = require('./Exception/ParseException');
ParseMore = require('./Exception/ParseMore');
DumpException = require('./Exception/DumpException');

Inline = function () {
  function Inline() {}

  Inline.REGEX_QUOTED_STRING = '(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'(?:[^\']*(?:\'\'[^\']*)*)\')';
  Inline.PATTERN_TRAILING_COMMENTS = new Pattern('^\\s*#.*$');
  Inline.PATTERN_QUOTED_SCALAR = new Pattern('^' + Inline.REGEX_QUOTED_STRING);
  Inline.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern('^(-|\\+)?[0-9,]+(\\.[0-9]+)?$');
  Inline.PATTERN_SCALAR_BY_DELIMITERS = {};
  Inline.settings = {};

  Inline.configure = function (exceptionOnInvalidType, objectDecoder) {
    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = null;
    }

    if (objectDecoder == null) {
      objectDecoder = null;
    }

    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;
  };

  Inline.parse = function (value, exceptionOnInvalidType, objectDecoder) {
    var context, result;

    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }

    if (objectDecoder == null) {
      objectDecoder = null;
    }

    this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
    this.settings.objectDecoder = objectDecoder;

    if (value == null) {
      return '';
    }

    value = Utils.trim(value);

    if (0 === value.length) {
      return '';
    }

    context = {
      exceptionOnInvalidType: exceptionOnInvalidType,
      objectDecoder: objectDecoder,
      i: 0
    };

    switch (value.charAt(0)) {
      case '[':
        result = this.parseSequence(value, context);
        ++context.i;
        break;

      case '{':
        result = this.parseMapping(value, context);
        ++context.i;
        break;

      default:
        result = this.parseScalar(value, null, ['"', "'"], context);
    }

    if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), '') !== '') {
      throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
    }

    return result;
  };

  Inline.dump = function (value, exceptionOnInvalidType, objectEncoder) {
    var ref, result, type;

    if (exceptionOnInvalidType == null) {
      exceptionOnInvalidType = false;
    }

    if (objectEncoder == null) {
      objectEncoder = null;
    }

    if (value == null) {
      return 'null';
    }

    type = _typeof(value);

    if (type === 'object') {
      if (value instanceof Date) {
        return value.toISOString();
      } else if (objectEncoder != null) {
        result = objectEncoder(value);

        if (typeof result === 'string' || result != null) {
          return result;
        }
      }

      return this.dumpObject(value);
    }

    if (type === 'boolean') {
      return value ? 'true' : 'false';
    }

    if (Utils.isDigits(value)) {
      return type === 'string' ? "'" + value + "'" : String(parseInt(value));
    }

    if (Utils.isNumeric(value)) {
      return type === 'string' ? "'" + value + "'" : String(parseFloat(value));
    }

    if (type === 'number') {
      return value === 2e308 ? '.Inf' : value === -2e308 ? '-.Inf' : isNaN(value) ? '.NaN' : value;
    }

    if (Escaper.requiresDoubleQuoting(value)) {
      return Escaper.escapeWithDoubleQuotes(value);
    }

    if (Escaper.requiresSingleQuoting(value)) {
      return Escaper.escapeWithSingleQuotes(value);
    }

    if ('' === value) {
      return '""';
    }

    if (Utils.PATTERN_DATE.test(value)) {
      return "'" + value + "'";
    }

    if ((ref = value.toLowerCase()) === 'null' || ref === '~' || ref === 'true' || ref === 'false') {
      return "'" + value + "'";
    }

    return value;
  };

  Inline.dumpObject = function (value, exceptionOnInvalidType, objectSupport) {
    var j, key, len1, output, val;

    if (objectSupport == null) {
      objectSupport = null;
    }

    if (value instanceof Array) {
      output = [];

      for (j = 0, len1 = value.length; j < len1; j++) {
        val = value[j];
        output.push(this.dump(val));
      }

      return '[' + output.join(', ') + ']';
    } else {
      output = [];

      for (key in value) {
        val = value[key];
        output.push(this.dump(key) + ': ' + this.dump(val));
      }

      return '{' + output.join(', ') + '}';
    }
  };

  Inline.parseScalar = function (scalar, delimiters, stringDelimiters, context, evaluate) {
    var i, joinedDelimiters, match, output, pattern, ref, ref1, strpos, tmp;

    if (delimiters == null) {
      delimiters = null;
    }

    if (stringDelimiters == null) {
      stringDelimiters = ['"', "'"];
    }

    if (context == null) {
      context = null;
    }

    if (evaluate == null) {
      evaluate = true;
    }

    if (context == null) {
      context = {
        exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
        objectDecoder: this.settings.objectDecoder,
        i: 0
      };
    }

    i = context.i;

    if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) >= 0) {
      output = this.parseQuotedScalar(scalar, context);
      i = context.i;

      if (delimiters != null) {
        tmp = Utils.ltrim(scalar.slice(i), ' ');

        if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) >= 0)) {
          throw new ParseException('Unexpected characters (' + scalar.slice(i) + ').');
        }
      }
    } else {
      if (!delimiters) {
        output = scalar.slice(i);
        i += output.length;
        strpos = output.indexOf(' #');

        if (strpos !== -1) {
          output = Utils.rtrim(output.slice(0, strpos));
        }
      } else {
        joinedDelimiters = delimiters.join('|');
        pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];

        if (pattern == null) {
          pattern = new Pattern('^(.+?)(' + joinedDelimiters + ')');
          this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
        }

        if (match = pattern.exec(scalar.slice(i))) {
          output = match[1];
          i += output.length;
        } else {
          throw new ParseException('Malformed inline YAML string (' + scalar + ').');
        }
      }

      if (evaluate) {
        output = this.evaluateScalar(output, context);
      }
    }

    context.i = i;
    return output;
  };

  Inline.parseQuotedScalar = function (scalar, context) {
    var i, match, output;
    i = context.i;

    if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
      throw new ParseMore('Malformed inline YAML string (' + scalar.slice(i) + ').');
    }

    output = match[0].substr(1, match[0].length - 2);

    if ('"' === scalar.charAt(i)) {
      output = Unescaper.unescapeDoubleQuotedString(output);
    } else {
      output = Unescaper.unescapeSingleQuotedString(output);
    }

    i += match[0].length;
    context.i = i;
    return output;
  };

  Inline.parseSequence = function (sequence, context) {
    var e, i, isQuoted, len, output, ref, value;
    output = [];
    len = sequence.length;
    i = context.i;
    i += 1;

    while (i < len) {
      context.i = i;

      switch (sequence.charAt(i)) {
        case '[':
          output.push(this.parseSequence(sequence, context));
          i = context.i;
          break;

        case '{':
          output.push(this.parseMapping(sequence, context));
          i = context.i;
          break;

        case ']':
          return output;

        case ',':
        case ' ':
        case "\n":
          break;

        default:
          isQuoted = (ref = sequence.charAt(i)) === '"' || ref === "'";
          value = this.parseScalar(sequence, [',', ']'], ['"', "'"], context);
          i = context.i;

          if (!isQuoted && typeof value === 'string' && (value.indexOf(': ') !== -1 || value.indexOf(":\n") !== -1)) {
            try {
              value = this.parseMapping('{' + value + '}');
            } catch (error) {
              e = error;
            }
          }

          output.push(value);
          --i;
      }

      ++i;
    }

    throw new ParseMore('Malformed inline YAML string ' + sequence);
  };

  Inline.parseMapping = function (mapping, context) {
    var done, i, key, len, output, shouldContinueWhileLoop, value;
    output = {};
    len = mapping.length;
    i = context.i;
    i += 1;
    shouldContinueWhileLoop = false;

    while (i < len) {
      context.i = i;

      switch (mapping.charAt(i)) {
        case ' ':
        case ',':
        case "\n":
          ++i;
          context.i = i;
          shouldContinueWhileLoop = true;
          break;

        case '}':
          return output;
      }

      if (shouldContinueWhileLoop) {
        shouldContinueWhileLoop = false;
        continue;
      }

      key = this.parseScalar(mapping, [':', ' ', "\n"], ['"', "'"], context, false);
      i = context.i;
      done = false;

      while (i < len) {
        context.i = i;

        switch (mapping.charAt(i)) {
          case '[':
            value = this.parseSequence(mapping, context);
            i = context.i;

            if (output[key] === void 0) {
              output[key] = value;
            }

            done = true;
            break;

          case '{':
            value = this.parseMapping(mapping, context);
            i = context.i;

            if (output[key] === void 0) {
              output[key] = value;
            }

            done = true;
            break;

          case ':':
          case ' ':
          case "\n":
            break;

          default:
            value = this.parseScalar(mapping, [',', '}'], ['"', "'"], context);
            i = context.i;

            if (output[key] === void 0) {
              output[key] = value;
            }

            done = true;
            --i;
        }

        ++i;

        if (done) {
          break;
        }
      }
    }

    throw new ParseMore('Malformed inline YAML string ' + mapping);
  };

  Inline.evaluateScalar = function (scalar, context) {
    var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
    scalar = Utils.trim(scalar);
    scalarLower = scalar.toLowerCase();

    switch (scalarLower) {
      case 'null':
      case '':
      case '~':
        return null;

      case 'true':
        return true;

      case 'false':
        return false;

      case '.inf':
        return 2e308;

      case '.nan':
        return 0 / 0;

      case '-.inf':
        return 2e308;

      default:
        firstChar = scalarLower.charAt(0);

        switch (firstChar) {
          case '!':
            firstSpace = scalar.indexOf(' ');

            if (firstSpace === -1) {
              firstWord = scalarLower;
            } else {
              firstWord = scalarLower.slice(0, firstSpace);
            }

            switch (firstWord) {
              case '!':
                if (firstSpace !== -1) {
                  return parseInt(this.parseScalar(scalar.slice(2)));
                }

                return null;

              case '!str':
                return Utils.ltrim(scalar.slice(4));

              case '!!str':
                return Utils.ltrim(scalar.slice(5));

              case '!!int':
                return parseInt(this.parseScalar(scalar.slice(5)));

              case '!!bool':
                return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);

              case '!!float':
                return parseFloat(this.parseScalar(scalar.slice(7)));

              case '!!timestamp':
                return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));

              default:
                if (context == null) {
                  context = {
                    exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                    objectDecoder: this.settings.objectDecoder,
                    i: 0
                  };
                }

                objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;

                if (objectDecoder) {
                  trimmedScalar = Utils.rtrim(scalar);
                  firstSpace = trimmedScalar.indexOf(' ');

                  if (firstSpace === -1) {
                    return objectDecoder(trimmedScalar, null);
                  } else {
                    subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));

                    if (!(subValue.length > 0)) {
                      subValue = null;
                    }

                    return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                  }
                }

                if (exceptionOnInvalidType) {
                  throw new ParseException('Custom object support when parsing a YAML file has been disabled.');
                }

                return null;
            }

            break;

          case '0':
            if ('0x' === scalar.slice(0, 2)) {
              return Utils.hexDec(scalar);
            } else if (Utils.isDigits(scalar)) {
              return Utils.octDec(scalar);
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else {
              return scalar;
            }

            break;

          case '+':
            if (Utils.isDigits(scalar)) {
              raw = scalar;
              cast = parseInt(raw);

              if (raw === String(cast)) {
                return cast;
              } else {
                return raw;
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }

            return scalar;

          case '-':
            if (Utils.isDigits(scalar.slice(1))) {
              if ('0' === scalar.charAt(1)) {
                return -Utils.octDec(scalar.slice(1));
              } else {
                raw = scalar.slice(1);
                cast = parseInt(raw);

                if (raw === String(cast)) {
                  return -cast;
                } else {
                  return -raw;
                }
              }
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }

            return scalar;

          default:
            if (date = Utils.stringToDate(scalar)) {
              return date;
            } else if (Utils.isNumeric(scalar)) {
              return parseFloat(scalar);
            } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
              return parseFloat(scalar.replace(',', ''));
            }

            return scalar;
        }

    }
  };

  return Inline;
}();

module.exports = Inline;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./Pattern":304,"./Unescaper":363,"./Escaper":364,"./Utils":222,"./Exception/ParseException":305,"./Exception/ParseMore":306,"./Exception/DumpException":365}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Pattern.js
      304: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var Pattern;

Pattern = function () {
  Pattern.prototype.regex = null;
  Pattern.prototype.rawRegex = null;
  Pattern.prototype.cleanedRegex = null;
  Pattern.prototype.mapping = null;

  function Pattern(rawRegex, modifiers) {
    var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;

    if (modifiers == null) {
      modifiers = '';
    }

    cleanedRegex = '';
    len = rawRegex.length;
    mapping = null;
    capturingBracketNumber = 0;
    i = 0;

    while (i < len) {
      _char = rawRegex.charAt(i);

      if (_char === '\\') {
        cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
        i++;
      } else if (_char === '(') {
        if (i < len - 2) {
          part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);

          if (part === '(?:') {
            i += 2;
            cleanedRegex += part;
          } else if (part === '(?<') {
            capturingBracketNumber++;
            i += 2;
            name = '';

            while (i + 1 < len) {
              subChar = rawRegex.charAt(i + 1);

              if (subChar === '>') {
                cleanedRegex += '(';
                i++;

                if (name.length > 0) {
                  if (mapping == null) {
                    mapping = {};
                  }

                  mapping[name] = capturingBracketNumber;
                }

                break;
              } else {
                name += subChar;
              }

              i++;
            }
          } else {
            cleanedRegex += _char;
            capturingBracketNumber++;
          }
        } else {
          cleanedRegex += _char;
        }
      } else {
        cleanedRegex += _char;
      }

      i++;
    }

    this.rawRegex = rawRegex;
    this.cleanedRegex = cleanedRegex;
    this.regex = new RegExp(this.cleanedRegex, 'g' + modifiers.replace('g', ''));
    this.mapping = mapping;
  }

  Pattern.prototype.exec = function (str) {
    var index, matches, name, ref;
    this.regex.lastIndex = 0;
    matches = this.regex.exec(str);

    if (matches == null) {
      return null;
    }

    if (this.mapping != null) {
      ref = this.mapping;

      for (name in ref) {
        index = ref[name];
        matches[name] = matches[index];
      }
    }

    return matches;
  };

  Pattern.prototype.test = function (str) {
    this.regex.lastIndex = 0;
    return this.regex.test(str);
  };

  Pattern.prototype.replace = function (str, replacement) {
    this.regex.lastIndex = 0;
    return str.replace(this.regex, replacement);
  };

  Pattern.prototype.replaceAll = function (str, replacement, limit) {
    var count;

    if (limit == null) {
      limit = 0;
    }

    this.regex.lastIndex = 0;
    count = 0;

    while (this.regex.test(str) && (limit === 0 || count < limit)) {
      this.regex.lastIndex = 0;
      str = str.replace(this.regex, replacement);
      count++;
    }

    return [str, count];
  };

  return Pattern;
}();

module.exports = Pattern;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Exception/ParseException.js
      305: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var ParseException,
    extend = function extend(child, parent) {
  for (var key in parent) {
    if (hasProp.call(parent, key)) child[key] = parent[key];
  }

  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
  child.__super__ = parent.prototype;
  return child;
},
    hasProp = {}.hasOwnProperty;

ParseException = function (superClass) {
  extend(ParseException, superClass);

  function ParseException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  ParseException.prototype.toString = function () {
    if (this.parsedLine != null && this.snippet != null) {
      return '<ParseException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<ParseException> ' + this.message;
    }
  };

  return ParseException;
}(Error);

module.exports = ParseException;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Exception/ParseMore.js
      306: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var ParseMore,
    extend = function extend(child, parent) {
  for (var key in parent) {
    if (hasProp.call(parent, key)) child[key] = parent[key];
  }

  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
  child.__super__ = parent.prototype;
  return child;
},
    hasProp = {}.hasOwnProperty;

ParseMore = function (superClass) {
  extend(ParseMore, superClass);

  function ParseMore(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  ParseMore.prototype.toString = function () {
    if (this.parsedLine != null && this.snippet != null) {
      return '<ParseMore> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<ParseMore> ' + this.message;
    }
  };

  return ParseMore;
}(Error);

module.exports = ParseMore;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_listCacheClear.js
      307: {
        factory: (module, exports, require) => {
          /**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_listCacheDelete.js
      308: {
        factory: (module, exports, require) => {
          var assocIndexOf = require('./_assocIndexOf');
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;
        },
        map: {"./_assocIndexOf":366}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_listCacheGet.js
      309: {
        factory: (module, exports, require) => {
          var assocIndexOf = require('./_assocIndexOf');
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;
        },
        map: {"./_assocIndexOf":366}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_listCacheHas.js
      310: {
        factory: (module, exports, require) => {
          var assocIndexOf = require('./_assocIndexOf');
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;
        },
        map: {"./_assocIndexOf":366}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_listCacheSet.js
      311: {
        factory: (module, exports, require) => {
          var assocIndexOf = require('./_assocIndexOf');
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;
        },
        map: {"./_assocIndexOf":366}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_MapCache.js
      312: {
        factory: (module, exports, require) => {
          var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;
        },
        map: {"./_mapCacheClear":367,"./_mapCacheDelete":368,"./_mapCacheGet":369,"./_mapCacheHas":370,"./_mapCacheSet":371}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_freeGlobal.js
      313: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_arrayFilter.js
      314: {
        factory: (module, exports, require) => {
          /**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getNative.js
      315: {
        factory: (module, exports, require) => {
          var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;
        },
        map: {"./_baseIsNative":372,"./_getValue":373}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_Symbol.js
      316: {
        factory: (module, exports, require) => {
          var root = require('./_root');
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;
        },
        map: {"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getRawTag.js
      317: {
        factory: (module, exports, require) => {
          var _Symbol = require('./_Symbol');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;
        },
        map: {"./_Symbol":316}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_objectToString.js
      318: {
        factory: (module, exports, require) => {
          /** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_Uint8Array.js
      319: {
        factory: (module, exports, require) => {
          var root = require('./_root');
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;
        },
        map: {"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_overArg.js
      320: {
        factory: (module, exports, require) => {
          /**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseTimes.js
      321: {
        factory: (module, exports, require) => {
          /**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isTypedArray.js
      322: {
        factory: (module, exports, require) => {
          var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;
        },
        map: {"./_baseIsTypedArray":374,"./_baseUnary":250,"./_nodeUtil":251}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_nativeKeys.js
      323: {
        factory: (module, exports, require) => {
          var overArg = require('./_overArg');
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;
        },
        map: {"./_overArg":320}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/isFunction.js
      324: {
        factory: (module, exports, require) => {
          var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;
        },
        map: {"./_baseGetTag":238,"./isObject":158}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_nativeKeysIn.js
      325: {
        factory: (module, exports, require) => {
          /**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/memoize.js
      326: {
        factory: (module, exports, require) => {
          var MapCache = require('./_MapCache');
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;
        },
        map: {"./_MapCache":312}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_createBaseFor.js
      327: {
        factory: (module, exports, require) => {
          /**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/has-symbols/index.js
      328: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var origSymbol = typeof Symbol !== 'undefined' && Symbol;

var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (_typeof(origSymbol('foo')) !== 'symbol') {
    return false;
  }

  if (_typeof(Symbol('bar')) !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"./shams":375}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/function-bind/index.js
      329: {
        factory: (module, exports, require) => {
          'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;
        },
        map: {"./implementation":376}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/has/src/index.js
      330: {
        factory: (module, exports, require) => {
          'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
        },
        map: {"function-bind":329}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/object-inspect/util.inspect.js
      331: {
        factory: (module, exports, require) => {
          module.exports = require('util').inspect;
        },
        map: {"util":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsArguments.js
      332: {
        factory: (module, exports, require) => {
          var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;
        },
        map: {"./_baseGetTag":238,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsMatch.js
      333: {
        factory: (module, exports, require) => {
          var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;
        },
        map: {"./_Stack":143,"./_baseIsEqual":336}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getMatchData.js
      334: {
        factory: (module, exports, require) => {
          var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;
        },
        map: {"./_isStrictComparable":338,"./keys":160}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_matchesStrictComparable.js
      335: {
        factory: (module, exports, require) => {
          /**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsEqual.js
      336: {
        factory: (module, exports, require) => {
          var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;
        },
        map: {"./_baseIsEqualDeep":377,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/get.js
      337: {
        factory: (module, exports, require) => {
          var baseGet = require('./_baseGet');
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;
        },
        map: {"./_baseGet":177}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_isStrictComparable.js
      338: {
        factory: (module, exports, require) => {
          var isObject = require('./isObject');
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;
        },
        map: {"./isObject":158}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseProperty.js
      339: {
        factory: (module, exports, require) => {
          /**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_basePropertyDeep.js
      340: {
        factory: (module, exports, require) => {
          var baseGet = require('./_baseGet');
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;
        },
        map: {"./_baseGet":177}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/which/which.js
      341: {
        factory: (module, exports, require) => {
          module.exports = which;
which.sync = whichSync;
var isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';

var path = require('path');

var COLON = isWindows ? ';' : ':';

var isexe = require('isexe');

function getNotFoundError(cmd) {
  var er = new Error('not found: ' + cmd);
  er.code = 'ENOENT';
  return er;
}

function getPathInfo(cmd, opt) {
  var colon = opt.colon || COLON;
  var pathEnv = opt.path || process.env.PATH || '';
  var pathExt = [''];
  pathEnv = pathEnv.split(colon);
  var pathExtExe = '';

  if (isWindows) {
    pathEnv.unshift(process.cwd());
    pathExtExe = opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM';
    pathExt = pathExtExe.split(colon); // Always test the cmd itself first.  isexe will check to make sure
    // it's found in the pathExt set.

    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
  } // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.


  if (cmd.match(/\//) || isWindows && cmd.match(/\\/)) pathEnv = [''];
  return {
    env: pathEnv,
    ext: pathExt,
    extExe: pathExtExe
  };
}

function which(cmd, opt, cb) {
  if (typeof opt === 'function') {
    cb = opt;
    opt = {};
  }

  var info = getPathInfo(cmd, opt);
  var pathEnv = info.env;
  var pathExt = info.ext;
  var pathExtExe = info.extExe;
  var found = [];

  (function F(i, l) {
    if (i === l) {
      if (opt.all && found.length) return cb(null, found);else return cb(getNotFoundError(cmd));
    }

    var pathPart = pathEnv[i];
    if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"') pathPart = pathPart.slice(1, -1);
    var p = path.join(pathPart, cmd);

    if (!pathPart && /^\.[\\\/]/.test(cmd)) {
      p = cmd.slice(0, 2) + p;
    }

    ;

    (function E(ii, ll) {
      if (ii === ll) return F(i + 1, l);
      var ext = pathExt[ii];
      isexe(p + ext, {
        pathExt: pathExtExe
      }, function (er, is) {
        if (!er && is) {
          if (opt.all) found.push(p + ext);else return cb(null, p + ext);
        }

        return E(ii + 1, ll);
      });
    })(0, pathExt.length);
  })(0, pathEnv.length);
}

function whichSync(cmd, opt) {
  opt = opt || {};
  var info = getPathInfo(cmd, opt);
  var pathEnv = info.env;
  var pathExt = info.ext;
  var pathExtExe = info.extExe;
  var found = [];

  for (var i = 0, l = pathEnv.length; i < l; i++) {
    var pathPart = pathEnv[i];
    if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"') pathPart = pathPart.slice(1, -1);
    var p = path.join(pathPart, cmd);

    if (!pathPart && /^\.[\\\/]/.test(cmd)) {
      p = cmd.slice(0, 2) + p;
    }

    for (var j = 0, ll = pathExt.length; j < ll; j++) {
      var cur = p + pathExt[j];
      var is;

      try {
        is = isexe.sync(cur, {
          pathExt: pathExtExe
        });

        if (is) {
          if (opt.all) found.push(cur);else return cur;
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length) return found;
  if (opt.nothrow) return null;
  throw getNotFoundError(cmd);
}
        },
        map: {"path":-19260817,"isexe":378}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/path-key/index.js
      342: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function (opts) {
  opts = opts || {};
  var env = opts.env || process.env;
  var platform = opts.platform || process.platform;

  if (platform !== 'win32') {
    return 'PATH';
  }

  return Object.keys(env).find(function (x) {
    return x.toUpperCase() === 'PATH';
  }) || 'Path';
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/shebang-command/index.js
      343: {
        factory: (module, exports, require) => {
          'use strict';

var shebangRegex = require('shebang-regex');

module.exports = function (str) {
  var match = str.match(shebangRegex);

  if (!match) {
    return null;
  }

  var arr = match[0].replace(/#! ?/, '').split(' ');
  var bin = arr[0].split('/').pop();
  var arg = arr[1];
  return bin === 'env' ? arg : bin + (arg ? ' ' + arg : '');
};
        },
        map: {"shebang-regex":379}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/wrappy/wrappy.js
      344: {
        factory: (module, exports, require) => {
          // Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;

function wrappy(fn, cb) {
  if (fn && cb) return wrappy(fn)(cb);
  if (typeof fn !== 'function') throw new TypeError('need wrapper function');
  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });
  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];

    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }

    return ret;
  }
}
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@babel/runtime/helpers/toArray.js
      345: {
        factory: (module, exports, require) => {
          var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArray = require("./iterableToArray.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
}

module.exports = _toArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
        },
        map: {"./arrayWithHoles.js":188,"./iterableToArray.js":110,"./unsupportedIterableToArray.js":111,"./nonIterableRest.js":190}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@curlconverter/yargs/node_modules/y18n/build/index.cjs
      346: {
        factory: (module, exports, require) => {
          'use strict';

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var fs = require('fs');

var util = require('util');

var path = require('path');

var shim;

var Y18N = /*#__PURE__*/function () {
  function Y18N(opts) {
    _classCallCheck(this, Y18N);

    // configurable options.
    opts = opts || {};
    this.directory = opts.directory || './locales';
    this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
    this.locale = opts.locale || 'en';
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true; // internal stuff.

    this.cache = Object.create(null);
    this.writeQueue = [];
  }

  _createClass(Y18N, [{
    key: "__",
    value: function __() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (typeof arguments[0] !== 'string') {
        return this._taggedLiteral.apply(this, [arguments[0]].concat(Array.prototype.slice.call(arguments)));
      }

      var str = args.shift();

      var cb = function cb() {}; // start with noop.


      if (typeof args[args.length - 1] === 'function') cb = args.pop();

      cb = cb || function () {}; // noop.


      if (!this.cache[this.locale]) this._readLocaleFile(); // we've observed a new string, update the language file.

      if (!this.cache[this.locale][str] && this.updateFiles) {
        this.cache[this.locale][str] = str; // include the current directory and locale,
        // since these values could change before the
        // write is performed.

        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb: cb
        });
      } else {
        cb();
      }

      return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
    }
  }, {
    key: "__n",
    value: function __n() {
      var args = Array.prototype.slice.call(arguments);
      var singular = args.shift();
      var plural = args.shift();
      var quantity = args.shift();

      var cb = function cb() {}; // start with noop.


      if (typeof args[args.length - 1] === 'function') cb = args.pop();
      if (!this.cache[this.locale]) this._readLocaleFile();
      var str = quantity === 1 ? singular : plural;

      if (this.cache[this.locale][singular]) {
        var entry = this.cache[this.locale][singular];
        str = entry[quantity === 1 ? 'one' : 'other'];
      } // we've observed a new string, update the language file.


      if (!this.cache[this.locale][singular] && this.updateFiles) {
        this.cache[this.locale][singular] = {
          one: singular,
          other: plural
        }; // include the current directory and locale,
        // since these values could change before the
        // write is performed.

        this._enqueueWrite({
          directory: this.directory,
          locale: this.locale,
          cb: cb
        });
      } else {
        cb();
      } // if a %d placeholder is provided, add quantity
      // to the arguments expanded by util.format.


      var values = [str];
      if (~str.indexOf('%d')) values.push(quantity);
      return shim.format.apply(shim.format, values.concat(args));
    }
  }, {
    key: "setLocale",
    value: function setLocale(locale) {
      this.locale = locale;
    }
  }, {
    key: "getLocale",
    value: function getLocale() {
      return this.locale;
    }
  }, {
    key: "updateLocale",
    value: function updateLocale(obj) {
      if (!this.cache[this.locale]) this._readLocaleFile();

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          this.cache[this.locale][key] = obj[key];
        }
      }
    }
  }, {
    key: "_taggedLiteral",
    value: function _taggedLiteral(parts) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var str = '';
      parts.forEach(function (part, i) {
        var arg = args[i + 1];
        str += part;

        if (typeof arg !== 'undefined') {
          str += '%s';
        }
      });
      return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
  }, {
    key: "_enqueueWrite",
    value: function _enqueueWrite(work) {
      this.writeQueue.push(work);
      if (this.writeQueue.length === 1) this._processWriteQueue();
    }
  }, {
    key: "_processWriteQueue",
    value: function _processWriteQueue() {
      var _this = this;

      var work = this.writeQueue[0]; // destructure the enqueued work.

      var directory = work.directory;
      var locale = work.locale;
      var cb = work.cb;

      var languageFile = this._resolveLocaleFile(directory, locale);

      var serializedLocale = JSON.stringify(this.cache[locale], null, 2);
      shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
        _this.writeQueue.shift();

        if (_this.writeQueue.length > 0) _this._processWriteQueue();
        cb(err);
      });
    }
  }, {
    key: "_readLocaleFile",
    value: function _readLocaleFile() {
      var localeLookup = {};

      var languageFile = this._resolveLocaleFile(this.directory, this.locale);

      try {
        // When using a bundler such as webpack, readFileSync may not be defined:
        if (shim.fs.readFileSync) {
          localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
        }
      } catch (err) {
        if (err instanceof SyntaxError) {
          err.message = 'syntax error in ' + languageFile;
        }

        if (err.code === 'ENOENT') localeLookup = {};else throw err;
      }

      this.cache[this.locale] = localeLookup;
    }
  }, {
    key: "_resolveLocaleFile",
    value: function _resolveLocaleFile(directory, locale) {
      var file = shim.resolve(directory, './', locale + '.json');

      if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
        // attempt fallback to language only
        var languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
        if (this._fileExistsSync(languageFile)) file = languageFile;
      }

      return file;
    }
  }, {
    key: "_fileExistsSync",
    value: function _fileExistsSync(file) {
      return shim.exists(file);
    }
  }]);

  return Y18N;
}();

function y18n$1(opts, _shim) {
  shim = _shim;
  var y18n = new Y18N(opts);
  return {
    __: y18n.__.bind(y18n),
    __n: y18n.__n.bind(y18n),
    setLocale: y18n.setLocale.bind(y18n),
    getLocale: y18n.getLocale.bind(y18n),
    updateLocale: y18n.updateLocale.bind(y18n),
    locale: y18n.locale
  };
}

var nodePlatformShim = {
  fs: {
    readFileSync: fs.readFileSync,
    writeFile: fs.writeFile
  },
  format: util.format,
  resolve: path.resolve,
  exists: function exists(file) {
    try {
      return fs.statSync(file).isFile();
    } catch (err) {
      return false;
    }
  }
};

var y18n = function y18n(opts) {
  return y18n$1(opts, nodePlatformShim);
};

module.exports = y18n;
        },
        map: {"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"fs":-19260817,"util":-19260817,"path":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@curlconverter/yargs-parser/build/index.cjs
      347: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _typeof = require("@babel/runtime/helpers/typeof");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var util = require('util');

var fs = require('fs');

var path = require('path');

function camelCase(str) {
  var isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();

  if (!isCamelCase) {
    str = str.toLowerCase();
  }

  if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
    return str;
  } else {
    var camelcase = '';
    var nextChrUpper = false;
    var leadingHyphens = str.match(/^-+/);

    for (var i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
      var chr = str.charAt(i);

      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }

      if (i !== 0 && (chr === '-' || chr === '_')) {
        nextChrUpper = true;
      } else if (chr !== '-' && chr !== '_') {
        camelcase += chr;
      }
    }

    return camelcase;
  }
}

function decamelize(str, joinString) {
  var lowercase = str.toLowerCase();
  joinString = joinString || '-';
  var notCamelcase = '';

  for (var i = 0; i < str.length; i++) {
    var chrLower = lowercase.charAt(i);
    var chrString = str.charAt(i);

    if (chrLower !== chrString && i > 0) {
      notCamelcase += "".concat(joinString).concat(lowercase.charAt(i));
    } else {
      notCamelcase += chrString;
    }
  }

  return notCamelcase;
}

function looksLikeNumber(x) {
  if (x === null || x === undefined) return false;
  if (typeof x === 'number') return true;
  if (/^0x[0-9a-f]+$/i.test(x)) return true;
  if (/^0[^.]/.test(x)) return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map(function (e) {
      return typeof e !== 'string' ? e + '' : e;
    });
  }

  argString = argString.trim();
  var i = 0;
  var prevC = null;
  var c = null;
  var opening = null;
  var args = [];

  for (var ii = 0; ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);

    if (c === ' ' && !opening) {
      if (!(prevC === ' ')) {
        i++;
      }

      continue;
    }

    var escaped = false;

    if (ii > 0) {
      var previousCharacterIndex = ii - 1;
      var previousCharacter = argString.charAt(previousCharacterIndex);
      escaped = previousCharacter === '\\';
    }

    if (c === opening && !escaped) {
      opening = null;
      continue;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
      if (!args[i]) args[i] = '';
      continue;
    }

    var nextCharacter = null;

    if (ii < argString.length - 1) {
      nextCharacter = argString.charAt(ii + 1);
    }

    if (c === '\\' && nextCharacter === opening) {
      continue;
    }

    if (!args[i]) args[i] = '';
    args[i] += c;
  }

  return args;
}

var DefaultValuesForTypeKey;

(function (DefaultValuesForTypeKey) {
  DefaultValuesForTypeKey["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey["STRING"] = "string";
  DefaultValuesForTypeKey["NUMBER"] = "number";
  DefaultValuesForTypeKey["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

var mixin;

var YargsParser = /*#__PURE__*/function () {
  function YargsParser(_mixin) {
    _classCallCheck(this, YargsParser);

    mixin = _mixin;
  }

  _createClass(YargsParser, [{
    key: "parse",
    value: function parse(argsInput, options) {
      var opts = Object.assign({
        alias: undefined,
        array: undefined,
        "boolean": undefined,
        config: undefined,
        configObjects: undefined,
        configuration: undefined,
        coerce: undefined,
        count: undefined,
        "default": undefined,
        envPrefix: undefined,
        narg: undefined,
        normalize: undefined,
        string: undefined,
        number: undefined,
        __: undefined,
        key: undefined
      }, options);
      var args = tokenizeArgString(argsInput);
      var aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
      var configuration = Object.assign({
        'boolean-negation': true,
        'camel-case-expansion': true,
        'combine-arrays': false,
        'dot-notation': true,
        'duplicate-arguments-array': true,
        'flatten-duplicate-arrays': true,
        'greedy-arrays': true,
        'halt-at-non-option': false,
        'nargs-eats-options': false,
        'negation-prefix': 'no-',
        'parse-numbers': true,
        'parse-positional-numbers': true,
        'populate--': false,
        'set-placeholder-key': false,
        'short-option-groups': true,
        'strip-aliased': false,
        'strip-dashed': false,
        'unknown-options-as-args': false
      }, opts.configuration);
      var defaults = Object.assign(Object.create(null), opts["default"]);
      var configObjects = opts.configObjects || [];
      var envPrefix = opts.envPrefix;
      var notFlagsOption = configuration['populate--'];
      var notFlagsArgv = notFlagsOption ? '--' : '_';
      var newAliases = Object.create(null);
      var defaulted = Object.create(null);

      var __ = opts.__ || mixin.format;

      var flags = {
        aliases: Object.create(null),
        arrays: Object.create(null),
        bools: Object.create(null),
        strings: Object.create(null),
        numbers: Object.create(null),
        counts: Object.create(null),
        normalize: Object.create(null),
        configs: Object.create(null),
        nargs: Object.create(null),
        coercions: Object.create(null),
        keys: []
      };
      var negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
      var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
      [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
        var key = _typeof(opt) === 'object' ? opt.key : opt;
        var assignment = Object.keys(opt).map(function (key) {
          var arrayFlagKeys = {
            "boolean": 'bools',
            string: 'strings',
            number: 'numbers'
          };
          return arrayFlagKeys[key];
        }).filter(Boolean).pop();

        if (assignment) {
          flags[assignment][key] = true;
        }

        flags.arrays[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts["boolean"] || []).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
        flags.numbers[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
        flags.counts[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
        flags.normalize[key] = true;
        flags.keys.push(key);
      });

      if (_typeof(opts.narg) === 'object') {
        Object.entries(opts.narg).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          if (typeof value === 'number') {
            flags.nargs[key] = value;
            flags.keys.push(key);
          }
        });
      }

      if (_typeof(opts.coerce) === 'object') {
        Object.entries(opts.coerce).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];

          if (typeof value === 'function') {
            flags.coercions[key] = value;
            flags.keys.push(key);
          }
        });
      }

      if (typeof opts.config !== 'undefined') {
        if (Array.isArray(opts.config) || typeof opts.config === 'string') {
          [].concat(opts.config).filter(Boolean).forEach(function (key) {
            flags.configs[key] = true;
          });
        } else if (_typeof(opts.config) === 'object') {
          Object.entries(opts.config).forEach(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
                key = _ref6[0],
                value = _ref6[1];

            if (typeof value === 'boolean' || typeof value === 'function') {
              flags.configs[key] = value;
            }
          });
        }
      }

      extendAliases(opts.key, aliases, opts["default"], flags.arrays);
      Object.keys(defaults).forEach(function (key) {
        (flags.aliases[key] || []).forEach(function (alias) {
          defaults[alias] = defaults[key];
        });
      });
      var error = null;
      checkConfiguration();
      var notFlags = [];
      var argv = Object.assign(Object.create(null), {
        _: []
      });
      var argvReturn = {};

      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var truncatedArg = arg.replace(/^-{3,}/, '---');
        var broken = void 0;
        var key = void 0;
        var letters = void 0;
        var m = void 0;
        var next = void 0;
        var value = void 0;
        if (!arg) continue;

        if (arg !== '--' && isUnknownOptionAsArg(arg)) {
          pushPositional(arg);
        } else if (truncatedArg.match(/---+(=|$)/)) {
          pushPositional(arg);
          continue;
        } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {
          m = arg.match(/^--?([^=]+)=([\s\S]*)$/);

          if (m !== null && Array.isArray(m) && m.length >= 3) {
            if (checkAllAliases(m[1], flags.arrays)) {
              i = eatArray(i, m[1], args, m[2]);
            } else if (checkAllAliases(m[1], flags.nargs) !== false) {
              i = eatNargs(i, m[1], args, m[2]);
            } else {
              setArg(m[1], m[2]);
            }
          }
        } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
          m = arg.match(negatedBoolean);

          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];
            setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
          }
        } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {
          m = arg.match(/^--?(.+)/);

          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];

            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args);
            } else {
              next = args[i + 1];

              if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          }
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/);

          if (m !== null && Array.isArray(m) && m.length >= 3) {
            setArg(m[1], m[2]);
          }
        } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
          next = args[i + 1];
          m = arg.match(/^-(.\..+)/);

          if (m !== null && Array.isArray(m) && m.length >= 2) {
            key = m[1];

            if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
          letters = arg.slice(1, -1).split('');
          broken = false;

          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);

            if (letters[j + 1] && letters[j + 1] === '=') {
              value = arg.slice(j + 3);
              key = letters[j];

              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args, value);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args, value);
              } else {
                setArg(key, value);
              }

              broken = true;
              break;
            }

            if (next === '-') {
              setArg(letters[j], next);
              continue;
            }

            if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
              setArg(letters[j], next);
              broken = true;
              break;
            }

            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], next);
              broken = true;
              break;
            } else {
              setArg(letters[j], defaultValue(letters[j]));
            }
          }

          key = arg.slice(-1)[0];

          if (!broken && key !== '-') {
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args);
            } else {
              next = args[i + 1];

              if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          }
        } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
          key = arg.slice(1);
          setArg(key, defaultValue(key));
        } else if (arg === '--') {
          notFlags = args.slice(i + 1);
          break;
        } else if (configuration['halt-at-non-option']) {
          notFlags = args.slice(i);
          break;
        } else {
          pushPositional(arg);
        }
      }

      applyEnvVars(argv, true);
      applyEnvVars(argv, false);
      setConfig(argv);
      setConfigObjects();
      applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
      applyCoercions(argv);
      if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);
      Object.keys(flags.counts).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) setArg(key, 0);
      });
      if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
      notFlags.forEach(function (key) {
        argv[notFlagsArgv].push(key);
      });

      if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
        Object.keys(argv).filter(function (key) {
          return key !== '--' && key.includes('-');
        }).forEach(function (key) {
          delete argv[key];
        });
      }

      if (configuration['strip-aliased']) {
        var _ref7;

        (_ref7 = []).concat.apply(_ref7, _toConsumableArray(Object.keys(aliases).map(function (k) {
          return aliases[k];
        }))).forEach(function (alias) {
          if (configuration['camel-case-expansion'] && alias.includes('-')) {
            delete argv[alias.split('.').map(function (prop) {
              return camelCase(prop);
            }).join('.')];
          }

          delete argv[alias];
        });
      }

      function pushPositional(arg) {
        var maybeCoercedNumber = maybeCoerceNumber('_', arg);

        if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
          argv._.push(maybeCoercedNumber);
        }
      }

      function eatNargs(i, key, args, argAfterEqualSign) {
        var ii;
        var toEat = checkAllAliases(key, flags.nargs);
        toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;

        if (toEat === 0) {
          if (!isUndefined(argAfterEqualSign)) {
            error = Error(__('Argument unexpected for: %s', key));
          }

          setArg(key, defaultValue(key));
          return i;
        }

        var available = isUndefined(argAfterEqualSign) ? 0 : 1;

        if (configuration['nargs-eats-options']) {
          if (args.length - (i + 1) + available < toEat) {
            error = Error(__('Not enough arguments following: %s', key));
          }

          available = toEat;
        } else {
          for (ii = i + 1; ii < args.length; ii++) {
            if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;
          }

          if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
        }

        var consumed = Math.min(available, toEat);

        if (!isUndefined(argAfterEqualSign) && consumed > 0) {
          setArg(key, argAfterEqualSign);
          consumed--;
        }

        for (ii = i + 1; ii < consumed + i + 1; ii++) {
          setArg(key, args[ii]);
        }

        return i + consumed;
      }

      function eatArray(i, key, args, argAfterEqualSign) {
        var argsToSet = [];
        var next = argAfterEqualSign || args[i + 1];
        var nargsCount = checkAllAliases(key, flags.nargs);

        if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
          argsToSet.push(true);
        } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
          if (defaults[key] !== undefined) {
            var defVal = defaults[key];
            argsToSet = Array.isArray(defVal) ? defVal : [defVal];
          }
        } else {
          if (!isUndefined(argAfterEqualSign)) {
            argsToSet.push(processValue(key, argAfterEqualSign));
          }

          for (var ii = i + 1; ii < args.length; ii++) {
            if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;
            next = args[ii];
            if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
            i = ii;
            argsToSet.push(processValue(key, next));
          }
        }

        if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
          error = Error(__('Not enough arguments following: %s', key));
        }

        setArg(key, argsToSet);
        return i;
      }

      function setArg(key, val) {
        if (/-/.test(key) && configuration['camel-case-expansion']) {
          var alias = key.split('.').map(function (prop) {
            return camelCase(prop);
          }).join('.');
          addNewAlias(key, alias);
        }

        var value = processValue(key, val);
        var splitKey = key.split('.');
        setKey(argv, splitKey, value);

        if (flags.aliases[key]) {
          flags.aliases[key].forEach(function (x) {
            var keyProperties = x.split('.');
            setKey(argv, keyProperties, value);
          });
        }

        if (splitKey.length > 1 && configuration['dot-notation']) {
          (flags.aliases[splitKey[0]] || []).forEach(function (x) {
            var keyProperties = x.split('.');
            var a = [].concat(splitKey);
            a.shift();
            keyProperties = keyProperties.concat(a);

            if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
              setKey(argv, keyProperties, value);
            }
          });
        }

        if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
          var keys = [key].concat(flags.aliases[key] || []);
          keys.forEach(function (key) {
            Object.defineProperty(argvReturn, key, {
              enumerable: true,
              get: function get() {
                return val;
              },
              set: function set(value) {
                val = typeof value === 'string' ? mixin.normalize(value) : value;
              }
            });
          });
        }
      }

      function addNewAlias(key, alias) {
        if (!(flags.aliases[key] && flags.aliases[key].length)) {
          flags.aliases[key] = [alias];
          newAliases[alias] = true;
        }

        if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
          addNewAlias(alias, key);
        }
      }

      function processValue(key, val) {
        if (typeof val === 'string' && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0]) {
          val = val.substring(1, val.length - 1);
        }

        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === 'string') val = val === 'true';
        }

        var value = Array.isArray(val) ? val.map(function (v) {
          return maybeCoerceNumber(key, v);
        }) : maybeCoerceNumber(key, val);

        if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
          value = increment();
        }

        if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
          if (Array.isArray(val)) value = val.map(function (val) {
            return mixin.normalize(val);
          });else value = mixin.normalize(val);
        }

        return value;
      }

      function maybeCoerceNumber(key, value) {
        if (!configuration['parse-positional-numbers'] && key === '_') return value;

        if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
          var shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat("".concat(value))));

          if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
            value = Number(value);
          }
        }

        return value;
      }

      function setConfig(argv) {
        var configLookup = Object.create(null);
        applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
        Object.keys(flags.configs).forEach(function (configKey) {
          var configPath = argv[configKey] || configLookup[configKey];

          if (configPath) {
            try {
              var config = null;
              var resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
              var resolveConfig = flags.configs[configKey];

              if (typeof resolveConfig === 'function') {
                try {
                  config = resolveConfig(resolvedConfigPath);
                } catch (e) {
                  config = e;
                }

                if (config instanceof Error) {
                  error = config;
                  return;
                }
              } else {
                config = mixin.require(resolvedConfigPath);
              }

              setConfigObject(config);
            } catch (ex) {
              if (ex.name === 'PermissionDenied') error = ex;else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));
            }
          }
        });
      }

      function setConfigObject(config, prev) {
        Object.keys(config).forEach(function (key) {
          var value = config[key];
          var fullKey = prev ? prev + '.' + key : key;

          if (_typeof(value) === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
            setConfigObject(value, fullKey);
          } else {
            if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {
              setArg(fullKey, value);
            }
          }
        });
      }

      function setConfigObjects() {
        if (typeof configObjects !== 'undefined') {
          configObjects.forEach(function (configObject) {
            setConfigObject(configObject);
          });
        }
      }

      function applyEnvVars(argv, configOnly) {
        if (typeof envPrefix === 'undefined') return;
        var prefix = typeof envPrefix === 'string' ? envPrefix : '';
        var env = mixin.env();
        Object.keys(env).forEach(function (envVar) {
          if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
            var keys = envVar.split('__').map(function (key, i) {
              if (i === 0) {
                key = key.substring(prefix.length);
              }

              return camelCase(key);
            });

            if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {
              setArg(keys.join('.'), env[envVar]);
            }
          }
        });
      }

      function applyCoercions(argv) {
        var coerce;
        var applied = new Set();
        Object.keys(argv).forEach(function (key) {
          if (!applied.has(key)) {
            coerce = checkAllAliases(key, flags.coercions);

            if (typeof coerce === 'function') {
              try {
                var _value = maybeCoerceNumber(key, coerce(argv[key]));

                [].concat(flags.aliases[key] || [], key).forEach(function (ali) {
                  applied.add(ali);
                  argv[ali] = _value;
                });
              } catch (err) {
                error = err;
              }
            }
          }
        });
      }

      function setPlaceholderKeys(argv) {
        flags.keys.forEach(function (key) {
          if (~key.indexOf('.')) return;
          if (typeof argv[key] === 'undefined') argv[key] = undefined;
        });
        return argv;
      }

      function applyDefaultsAndAliases(obj, aliases, defaults) {
        var canLog = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        Object.keys(defaults).forEach(function (key) {
          if (!hasKey(obj, key.split('.'))) {
            setKey(obj, key.split('.'), defaults[key]);
            if (canLog) defaulted[key] = true;
            (aliases[key] || []).forEach(function (x) {
              if (hasKey(obj, x.split('.'))) return;
              setKey(obj, x.split('.'), defaults[key]);
            });
          }
        });
      }

      function hasKey(obj, keys) {
        var o = obj;
        if (!configuration['dot-notation']) keys = [keys.join('.')];
        keys.slice(0, -1).forEach(function (key) {
          o = o[key] || {};
        });
        var key = keys[keys.length - 1];
        if (_typeof(o) !== 'object') return false;else return key in o;
      }

      function setKey(obj, keys, value) {
        var o = obj;
        if (!configuration['dot-notation']) keys = [keys.join('.')];
        keys.slice(0, -1).forEach(function (key) {
          key = sanitizeKey(key);

          if (_typeof(o) === 'object' && o[key] === undefined) {
            o[key] = {};
          }

          if (_typeof(o[key]) !== 'object' || Array.isArray(o[key])) {
            if (Array.isArray(o[key])) {
              o[key].push({});
            } else {
              o[key] = [o[key], {}];
            }

            o = o[key][o[key].length - 1];
          } else {
            o = o[key];
          }
        });
        var key = sanitizeKey(keys[keys.length - 1]);
        var isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
        var isValueArray = Array.isArray(value);
        var duplicate = configuration['duplicate-arguments-array'];

        if (!duplicate && checkAllAliases(key, flags.nargs)) {
          duplicate = true;

          if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
            o[key] = undefined;
          }
        }

        if (value === increment()) {
          o[key] = increment(o[key]);
        } else if (Array.isArray(o[key])) {
          if (duplicate && isTypeArray && isValueArray) {
            o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
          } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
            o[key] = value;
          } else {
            o[key] = o[key].concat([value]);
          }
        } else if (o[key] === undefined && isTypeArray) {
          o[key] = isValueArray ? value : [value];
        } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
          o[key] = [o[key], value];
        } else {
          o[key] = value;
        }
      }

      function extendAliases() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        args.forEach(function (obj) {
          Object.keys(obj || {}).forEach(function (key) {
            if (flags.aliases[key]) return;
            flags.aliases[key] = [].concat(aliases[key] || []);
            flags.aliases[key].concat(key).forEach(function (x) {
              if (/-/.test(x) && configuration['camel-case-expansion']) {
                var c = camelCase(x);

                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            });
            flags.aliases[key].concat(key).forEach(function (x) {
              if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                var c = decamelize(x, '-');

                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            });
            flags.aliases[key].forEach(function (x) {
              flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                return x !== y;
              }));
            });
          });
        });
      }

      function checkAllAliases(key, flag) {
        var toCheck = [].concat(flags.aliases[key] || [], key);
        var keys = Object.keys(flag);
        var setAlias = toCheck.find(function (key) {
          return keys.includes(key);
        });
        return setAlias ? flag[setAlias] : false;
      }

      function hasAnyFlag(key) {
        var flagsKeys = Object.keys(flags);
        var toCheck = [].concat(flagsKeys.map(function (k) {
          return flags[k];
        }));
        return toCheck.some(function (flag) {
          return Array.isArray(flag) ? flag.includes(key) : flag[key];
        });
      }

      function hasFlagsMatching(arg) {
        var _ref8;

        for (var _len2 = arguments.length, patterns = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          patterns[_key2 - 1] = arguments[_key2];
        }

        var toCheck = (_ref8 = []).concat.apply(_ref8, patterns);

        return toCheck.some(function (pattern) {
          var match = arg.match(pattern);
          return match && hasAnyFlag(match[1]);
        });
      }

      function hasAllShortFlags(arg) {
        if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
          return false;
        }

        var hasAllFlags = true;
        var next;
        var letters = arg.slice(1).split('');

        for (var _j = 0; _j < letters.length; _j++) {
          next = arg.slice(_j + 2);

          if (!hasAnyFlag(letters[_j])) {
            hasAllFlags = false;
            break;
          }

          if (letters[_j + 1] && letters[_j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[_j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[_j + 1] && letters[_j + 1].match(/\W/)) {
            break;
          }
        }

        return hasAllFlags;
      }

      function isUnknownOptionAsArg(arg) {
        return configuration['unknown-options-as-args'] && isUnknownOption(arg);
      }

      function isUnknownOption(arg) {
        arg = arg.replace(/^-{3,}/, '--');

        if (arg.match(negative)) {
          return false;
        }

        if (hasAllShortFlags(arg)) {
          return false;
        }

        var flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
        var normalFlag = /^-+([^=]+?)$/;
        var flagEndingInHyphen = /^-+([^=]+?)-$/;
        var flagEndingInDigits = /^-+([^=]+?\d+)$/;
        var flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
        return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
      }

      function defaultValue(key) {
        if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && "".concat(key) in defaults) {
          return defaults[key];
        } else {
          return defaultForType(guessType(key));
        }
      }

      function defaultForType(type) {
        var _def;

        var def = (_def = {}, _defineProperty(_def, DefaultValuesForTypeKey.BOOLEAN, true), _defineProperty(_def, DefaultValuesForTypeKey.STRING, ''), _defineProperty(_def, DefaultValuesForTypeKey.NUMBER, undefined), _defineProperty(_def, DefaultValuesForTypeKey.ARRAY, []), _def);
        return def[type];
      }

      function guessType(key) {
        var type = DefaultValuesForTypeKey.BOOLEAN;
        if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;
        return type;
      }

      function isUndefined(num) {
        return num === undefined;
      }

      function checkConfiguration() {
        Object.keys(flags.counts).find(function (key) {
          if (checkAllAliases(key, flags.arrays)) {
            error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
            return true;
          } else if (checkAllAliases(key, flags.nargs)) {
            error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
            return true;
          }

          return false;
        });
      }

      return {
        aliases: Object.assign({}, flags.aliases),
        argv: Object.assign(argvReturn, argv),
        configuration: configuration,
        defaulted: Object.assign({}, defaulted),
        error: error,
        newAliases: Object.assign({}, newAliases)
      };
    }
  }]);

  return YargsParser;
}();

function combineAliases(aliases) {
  var aliasArrays = [];
  var combined = Object.create(null);
  var change = true;
  Object.keys(aliases).forEach(function (key) {
    aliasArrays.push([].concat(aliases[key], key));
  });

  while (change) {
    change = false;

    for (var i = 0; i < aliasArrays.length; i++) {
      var _loop = function _loop(ii) {
        var intersect = aliasArrays[i].filter(function (v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });

        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          return "break";
        }
      };

      for (var ii = i + 1; ii < aliasArrays.length; ii++) {
        var _ret = _loop(ii);

        if (_ret === "break") break;
      }
    }
  }

  aliasArrays.forEach(function (aliasArray) {
    aliasArray = aliasArray.filter(function (v, i, self) {
      return self.indexOf(v) === i;
    });
    var lastAlias = aliasArray.pop();

    if (lastAlias !== undefined && typeof lastAlias === 'string') {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}

function increment(orig) {
  return orig !== undefined ? orig + 1 : 1;
}

function sanitizeKey(key) {
  if (key === '__proto__') return '___proto___';
  return key;
}

var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 10;

if (process && process.version) {
  var major = Number(process.version.match(/v([^.]+)/)[1]);

  if (major < minNodeVersion) {
    throw Error("yargs parser supports a minimum Node.js version of ".concat(minNodeVersion, ". Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions"));
  }
}

var _env = process ? process.env : {};

var parser = new YargsParser({
  cwd: process.cwd,
  env: function env() {
    return _env;
  },
  format: util.format,
  normalize: path.normalize,
  resolve: path.resolve,
  require: function (_require) {
    function require(_x) {
      return _require.apply(this, arguments);
    }

    require.toString = function () {
      return _require.toString();
    };

    return require;
  }(function (path) {
    if (typeof require !== 'undefined') {
      return require(path);
    } else if (path.match(/\.json$/)) {
      return fs.readFileSync(path, 'utf8');
    } else {
      throw Error('only .json config files are supported in ESM');
    }
  })
});

var yargsParser = function Parser(args, opts) {
  var result = parser.parse(args.slice(), opts);
  return result.argv;
};

yargsParser.detailed = function (args, opts) {
  return parser.parse(args.slice(), opts);
};

yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
module.exports = yargsParser;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/slicedToArray":120,"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"util":-19260817,"fs":-19260817,"path":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@curlconverter/yargs/node_modules/cliui/build/index.cjs
      348: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var align = {
  right: alignRight,
  center: alignCenter
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;

var UI = /*#__PURE__*/function () {
  function UI(opts) {
    _classCallCheck(this, UI);

    var _a;

    this.width = opts.width;
    this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
    this.rows = [];
  }

  _createClass(UI, [{
    key: "span",
    value: function span() {
      var cols = this.div.apply(this, arguments);
      cols.span = true;
    }
  }, {
    key: "resetOutput",
    value: function resetOutput() {
      this.rows = [];
    }
  }, {
    key: "div",
    value: function div() {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args.length === 0) {
        this.div('');
      }

      if (this.wrap && this.shouldApplyLayoutDSL.apply(this, args) && typeof args[0] === 'string') {
        return this.applyLayoutDSL(args[0]);
      }

      var cols = args.map(function (arg) {
        if (typeof arg === 'string') {
          return _this.colFromString(arg);
        }

        return arg;
      });
      this.rows.push(cols);
      return cols;
    }
  }, {
    key: "shouldApplyLayoutDSL",
    value: function shouldApplyLayoutDSL() {
      return arguments.length === 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string' && /[\t\n]/.test(arguments.length <= 0 ? undefined : arguments[0]);
    }
  }, {
    key: "applyLayoutDSL",
    value: function applyLayoutDSL(str) {
      var _this2 = this;

      var rows = str.split('\n').map(function (row) {
        return row.split('\t');
      });
      var leftColumnWidth = 0; // simple heuristic for layout, make sure the
      // second column lines up along the left-hand.
      // don't allow the first column to take up more
      // than 50% of the screen.

      rows.forEach(function (columns) {
        if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
          leftColumnWidth = Math.min(Math.floor(_this2.width * 0.5), mixin.stringWidth(columns[0]));
        }
      }); // generate a table:
      //  replacing ' ' with padding calculations.
      //  using the algorithmically generated width.

      rows.forEach(function (columns) {
        _this2.div.apply(_this2, _toConsumableArray(columns.map(function (r, i) {
          return {
            text: r.trim(),
            padding: _this2.measurePadding(r),
            width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
          };
        })));
      });
      return this.rows[this.rows.length - 1];
    }
  }, {
    key: "colFromString",
    value: function colFromString(text) {
      return {
        text: text,
        padding: this.measurePadding(text)
      };
    }
  }, {
    key: "measurePadding",
    value: function measurePadding(str) {
      // measure padding without ansi escape codes
      var noAnsi = mixin.stripAnsi(str);
      return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
  }, {
    key: "toString",
    value: function toString() {
      var _this3 = this;

      var lines = [];
      this.rows.forEach(function (row) {
        _this3.rowToString(row, lines);
      }); // don't display any lines with the
      // hidden flag set.

      return lines.filter(function (line) {
        return !line.hidden;
      }).map(function (line) {
        return line.text;
      }).join('\n');
    }
  }, {
    key: "rowToString",
    value: function rowToString(row, lines) {
      var _this4 = this;

      this.rasterize(row).forEach(function (rrow, r) {
        var str = '';
        rrow.forEach(function (col, c) {
          var width = row[c].width; // the width with padding.

          var wrapWidth = _this4.negatePadding(row[c]); // the width without padding.


          var ts = col; // temporary string used during alignment/padding.

          if (wrapWidth > mixin.stringWidth(col)) {
            ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
          } // align the string within its column.


          if (row[c].align && row[c].align !== 'left' && _this4.wrap) {
            var fn = align[row[c].align];
            ts = fn(ts, wrapWidth);

            if (mixin.stringWidth(ts) < wrapWidth) {
              ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
            }
          } // apply border and padding to string.


          var padding = row[c].padding || [0, 0, 0, 0];

          if (padding[left]) {
            str += ' '.repeat(padding[left]);
          }

          str += addBorder(row[c], ts, '| ');
          str += ts;
          str += addBorder(row[c], ts, ' |');

          if (padding[right]) {
            str += ' '.repeat(padding[right]);
          } // if prior row is span, try to render the
          // current row on the prior line.


          if (r === 0 && lines.length > 0) {
            str = _this4.renderInline(str, lines[lines.length - 1]);
          }
        }); // remove trailing whitespace.

        lines.push({
          text: str.replace(/ +$/, ''),
          span: row.span
        });
      });
      return lines;
    } // if the full 'source' can render in
    // the target line, do so.

  }, {
    key: "renderInline",
    value: function renderInline(source, previousLine) {
      var match = source.match(/^ */);
      var leadingWhitespace = match ? match[0].length : 0;
      var target = previousLine.text;
      var targetTextWidth = mixin.stringWidth(target.trimRight());

      if (!previousLine.span) {
        return source;
      } // if we're not applying wrapping logic,
      // just always append to the span.


      if (!this.wrap) {
        previousLine.hidden = true;
        return target + source;
      }

      if (leadingWhitespace < targetTextWidth) {
        return source;
      }

      previousLine.hidden = true;
      return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
  }, {
    key: "rasterize",
    value: function rasterize(row) {
      var _this5 = this;

      var rrows = [];
      var widths = this.columnWidths(row);
      var wrapped; // word wrap all columns, and create
      // a data-structure that is easy to rasterize.

      row.forEach(function (col, c) {
        // leave room for left and right padding.
        col.width = widths[c];

        if (_this5.wrap) {
          wrapped = mixin.wrap(col.text, _this5.negatePadding(col), {
            hard: true
          }).split('\n');
        } else {
          wrapped = col.text.split('\n');
        }

        if (col.border) {
          wrapped.unshift('.' + '-'.repeat(_this5.negatePadding(col) + 2) + '.');
          wrapped.push("'" + '-'.repeat(_this5.negatePadding(col) + 2) + "'");
        } // add top and bottom padding.


        if (col.padding) {
          var _wrapped, _wrapped2;

          (_wrapped = wrapped).unshift.apply(_wrapped, _toConsumableArray(new Array(col.padding[top] || 0).fill('')));

          (_wrapped2 = wrapped).push.apply(_wrapped2, _toConsumableArray(new Array(col.padding[bottom] || 0).fill('')));
        }

        wrapped.forEach(function (str, r) {
          if (!rrows[r]) {
            rrows.push([]);
          }

          var rrow = rrows[r];

          for (var i = 0; i < c; i++) {
            if (rrow[i] === undefined) {
              rrow.push('');
            }
          }

          rrow.push(str);
        });
      });
      return rrows;
    }
  }, {
    key: "negatePadding",
    value: function negatePadding(col) {
      var wrapWidth = col.width || 0;

      if (col.padding) {
        wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
      }

      if (col.border) {
        wrapWidth -= 4;
      }

      return wrapWidth;
    }
  }, {
    key: "columnWidths",
    value: function columnWidths(row) {
      if (!this.wrap) {
        return row.map(function (col) {
          return col.width || mixin.stringWidth(col.text);
        });
      }

      var unset = row.length;
      var remainingWidth = this.width; // column widths can be set in config.

      var widths = row.map(function (col) {
        if (col.width) {
          unset--;
          remainingWidth -= col.width;
          return col.width;
        }

        return undefined;
      }); // any unset widths should be calculated.

      var unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
      return widths.map(function (w, i) {
        if (w === undefined) {
          return Math.max(unsetWidth, _minWidth(row[i]));
        }

        return w;
      });
    }
  }]);

  return UI;
}();

function addBorder(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return '';
    }

    if (ts.trim().length !== 0) {
      return style;
    }

    return '  ';
  }

  return '';
} // calculates the minimum width of
// a column, based on padding preferences.


function _minWidth(col) {
  var padding = col.padding || [];
  var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);

  if (col.border) {
    return minWidth + 4;
  }

  return minWidth;
}

function getWindowWidth() {
  /* istanbul ignore next: depends on terminal */
  if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }

  return 80;
}

function alignRight(str, width) {
  str = str.trim();
  var strWidth = mixin.stringWidth(str);

  if (strWidth < width) {
    return ' '.repeat(width - strWidth) + str;
  }

  return str;
}

function alignCenter(str, width) {
  str = str.trim();
  var strWidth = mixin.stringWidth(str);
  /* istanbul ignore next */

  if (strWidth >= width) {
    return str;
  }

  return ' '.repeat(width - strWidth >> 1) + str;
}

var mixin;

function cliui(opts, _mixin) {
  mixin = _mixin;
  return new UI({
    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
  });
} // Bootstrap cliui with CommonJS dependencies:


var stringWidth = require('string-width');

var stripAnsi = require('strip-ansi');

var wrap = require('wrap-ansi');

function ui(opts) {
  return cliui(opts, {
    stringWidth: stringWidth,
    stripAnsi: stripAnsi,
    wrap: wrap
  });
}

module.exports = ui;
        },
        map: {"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"string-width":352,"strip-ansi":380,"wrap-ansi":381}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/escalade/sync/index.js
      349: {
        factory: (module, exports, require) => {
          var _require = require('path'),
    dirname = _require.dirname,
    resolve = _require.resolve;

var _require2 = require('fs'),
    readdirSync = _require2.readdirSync,
    statSync = _require2.statSync;

module.exports = function (start, callback) {
  var dir = resolve('.', start);
  var tmp,
      stats = statSync(dir);

  if (!stats.isDirectory()) {
    dir = dirname(dir);
  }

  while (true) {
    tmp = callback(dir, readdirSync(dir));
    if (tmp) return resolve(dir, tmp);
    dir = dirname(tmp = dir);
    if (tmp === dir) break;
  }
};
        },
        map: {"path":-19260817,"fs":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/get-caller-file/index.js
      350: {
        factory: (module, exports, require) => {
          "use strict"; // Call this function in a another function to find out the file from
// which that function was called from. (Inspects the v8 stack trace)
//
// Inspired by http://stackoverflow.com/questions/13227489

var _typeof = require("@babel/runtime/helpers/typeof");

module.exports = function getCallerFile(position) {
  if (position === void 0) {
    position = 2;
  }

  if (position >= Error.stackTraceLimit) {
    throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');
  }

  var oldPrepareStackTrace = Error.prepareStackTrace;

  Error.prepareStackTrace = function (_, stack) {
    return stack;
  };

  var stack = new Error().stack;
  Error.prepareStackTrace = oldPrepareStackTrace;

  if (stack !== null && _typeof(stack) === 'object') {
    // stack[0] holds this file
    // stack[1] holds where this function was called
    // stack[2] holds the file we're interested in
    return stack[position] ? stack[position].getFileName() : undefined;
  }
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/require-directory/index.js
      351: {
        factory: (module, exports, require) => {
          'use strict';

var fs = require('fs'),
    join = require('path').join,
    resolve = require('path').resolve,
    dirname = require('path').dirname,
    defaultOptions = {
  extensions: ['js', 'json', 'coffee'],
  recurse: true,
  rename: function rename(name) {
    return name;
  },
  visit: function visit(obj) {
    return obj;
  }
};

function checkFileInclusion(path, filename, options) {
  return (// verify file has valid extension
    new RegExp('\\.(' + options.extensions.join('|') + ')$', 'i').test(filename) && // if options.include is a RegExp, evaluate it and make sure the path passes
    !(options.include && options.include instanceof RegExp && !options.include.test(path)) && // if options.include is a function, evaluate it and make sure the path passes
    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) && // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && // if options.exclude is a function, evaluate it and make sure the path doesn't pass
    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))
  );
}

function requireDirectory(m, path, options) {
  var retval = {}; // path is optional

  if (path && !options && typeof path !== 'string') {
    options = path;
    path = null;
  } // default options


  options = options || {};

  for (var prop in defaultOptions) {
    if (typeof options[prop] === 'undefined') {
      options[prop] = defaultOptions[prop];
    }
  } // if no path was passed in, assume the equivelant of __dirname from caller
  // otherwise, resolve path relative to the equivalent of __dirname


  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path); // get the path of each file in specified directory, append to current tree node, recurse

  fs.readdirSync(path).forEach(function (filename) {
    var joined = join(path, filename),
        files,
        key,
        obj;

    if (fs.statSync(joined).isDirectory() && options.recurse) {
      // this node is a directory; recurse
      files = requireDirectory(m, joined, options); // exclude empty directories

      if (Object.keys(files).length) {
        retval[options.rename(filename, joined, filename)] = files;
      }
    } else {
      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
        // hash node key shouldn't include file extension
        key = filename.substring(0, filename.lastIndexOf('.'));
        obj = m.require(joined);
        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
      }
    }
  });
  return retval;
}

module.exports = requireDirectory;
module.exports.defaults = defaultOptions;
        },
        map: {"fs":-19260817,"path":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/string-width/index.js
      352: {
        factory: (module, exports, require) => {
          'use strict';

var stripAnsi = require('strip-ansi');

var isFullwidthCodePoint = require('is-fullwidth-code-point');

var emojiRegex = require('emoji-regex');

var stringWidth = function stringWidth(string) {
  if (typeof string !== 'string' || string.length === 0) {
    return 0;
  }

  string = stripAnsi(string);

  if (string.length === 0) {
    return 0;
  }

  string = string.replace(emojiRegex(), '  ');
  var width = 0;

  for (var i = 0; i < string.length; i++) {
    var code = string.codePointAt(i); // Ignore control characters

    if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
      continue;
    } // Ignore combining characters


    if (code >= 0x300 && code <= 0x36F) {
      continue;
    } // Surrogates


    if (code > 0xFFFF) {
      i++;
    }

    width += isFullwidthCodePoint(code) ? 2 : 1;
  }

  return width;
};

module.exports = stringWidth; // TODO: remove this in the next major version

module.exports["default"] = stringWidth;
        },
        map: {"strip-ansi":380,"is-fullwidth-code-point":382,"emoji-regex":383}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/asap/raw.js
      353: {
        factory: (module, exports, require) => {
          "use strict";

var domain; // The domain module is executed on demand

var hasSetImmediate = typeof setImmediate === "function"; // Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.

module.exports = rawAsap;

function rawAsap(task) {
  if (!queue.length) {
    requestFlush();
    flushing = true;
  } // Avoids a function call


  queue[queue.length] = task;
}

var queue = []; // Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.

var flushing = false; // The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.

var index = 0; // If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.

var capacity = 1024; // The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.

function flush() {
  while (index < queue.length) {
    var currentIndex = index; // Advance the index before calling the task. This ensures that we will
    // begin flushing on the next task the task throws an error.

    index = index + 1;
    queue[currentIndex].call(); // Prevent leaking memory for long chains of recursive calls to `asap`.
    // If we call `asap` within tasks scheduled by `asap`, the queue will
    // grow, but to avoid an O(n) walk for every task we execute, we don't
    // shift tasks off the queue after they have been executed.
    // Instead, we periodically shift 1024 tasks off the queue.

    if (index > capacity) {
      // Manually shift all values starting at the index back to the
      // beginning of the queue.
      for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
        queue[scan] = queue[scan + index];
      }

      queue.length -= index;
      index = 0;
    }
  }

  queue.length = 0;
  index = 0;
  flushing = false;
}

rawAsap.requestFlush = requestFlush;

function requestFlush() {
  // Ensure flushing is not bound to any domain.
  // It is not sufficient to exit the domain, because domains exist on a stack.
  // To execute code outside of any domain, the following dance is necessary.
  var parentDomain = process.domain;

  if (parentDomain) {
    if (!domain) {
      // Lazy execute the domain module.
      // Only employed if the user elects to use domains.
      domain = require("domain");
    }

    domain.active = process.domain = null;
  } // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
  // cannot handle recursion.
  // `requestFlush` will only be called recursively from `asap.js`, to resume
  // flushing after an error is thrown into a domain.
  // Conveniently, `setImmediate` was introduced in the same version
  // `process.nextTick` started throwing recursion errors.


  if (flushing && hasSetImmediate) {
    setImmediate(flush);
  } else {
    process.nextTick(flush);
  }

  if (parentDomain) {
    domain.active = process.domain = parentDomain;
  }
}
        },
        map: {"domain":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/nunjucks/src/precompiled-loader.js
      354: {
        factory: (module, exports, require) => {
          'use strict';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var Loader = require('./loader');

var PrecompiledLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(PrecompiledLoader, _Loader);

  function PrecompiledLoader(compiledTemplates) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.precompiled = compiledTemplates || {};
    return _this;
  }

  var _proto = PrecompiledLoader.prototype;

  _proto.getSource = function getSource(name) {
    if (this.precompiled[name]) {
      return {
        src: {
          type: 'code',
          obj: this.precompiled[name]
        },
        path: name
      };
    }

    return null;
  };

  return PrecompiledLoader;
}(Loader);

module.exports = {
  PrecompiledLoader: PrecompiledLoader
};
        },
        map: {"./loader":202}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/chokidar/index.js
      355: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _assertThisInitialized = require("@babel/runtime/helpers/assertThisInitialized");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _typeof = require("@babel/runtime/helpers/typeof");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var fs = require('fs');

var sysPath = require('path');

var _require2 = require('util'),
    promisify = _require2.promisify;

var readdirp = require('readdirp');

var anymatch = require('anymatch')["default"];

var globParent = require('glob-parent');

var isGlob = require('is-glob');

var braces = require('braces');

var normalizePath = require('normalize-path');

var NodeFsHandler = require('./lib/nodefs-handler');

var FsEventsHandler = require('./lib/fsevents-handler');

var _require3 = require('./lib/constants'),
    EV_ALL = _require3.EV_ALL,
    EV_READY = _require3.EV_READY,
    EV_ADD = _require3.EV_ADD,
    EV_CHANGE = _require3.EV_CHANGE,
    EV_UNLINK = _require3.EV_UNLINK,
    EV_ADD_DIR = _require3.EV_ADD_DIR,
    EV_UNLINK_DIR = _require3.EV_UNLINK_DIR,
    EV_RAW = _require3.EV_RAW,
    EV_ERROR = _require3.EV_ERROR,
    STR_CLOSE = _require3.STR_CLOSE,
    STR_END = _require3.STR_END,
    BACK_SLASH_RE = _require3.BACK_SLASH_RE,
    DOUBLE_SLASH_RE = _require3.DOUBLE_SLASH_RE,
    SLASH_OR_BACK_SLASH_RE = _require3.SLASH_OR_BACK_SLASH_RE,
    DOT_RE = _require3.DOT_RE,
    REPLACER_RE = _require3.REPLACER_RE,
    SLASH = _require3.SLASH,
    SLASH_SLASH = _require3.SLASH_SLASH,
    BRACE_START = _require3.BRACE_START,
    BANG = _require3.BANG,
    ONE_DOT = _require3.ONE_DOT,
    TWO_DOTS = _require3.TWO_DOTS,
    GLOBSTAR = _require3.GLOBSTAR,
    SLASH_GLOBSTAR = _require3.SLASH_GLOBSTAR,
    ANYMATCH_OPTS = _require3.ANYMATCH_OPTS,
    STRING_TYPE = _require3.STRING_TYPE,
    FUNCTION_TYPE = _require3.FUNCTION_TYPE,
    EMPTY_STR = _require3.EMPTY_STR,
    EMPTY_FN = _require3.EMPTY_FN,
    isWindows = _require3.isWindows,
    isMacos = _require3.isMacos;

var stat = promisify(fs.stat);
var readdir = promisify(fs.readdir);
/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */

/**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */

var arrify = function arrify() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return Array.isArray(value) ? value : [value];
};

var flatten = function flatten(list) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  list.forEach(function (item) {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

var unifyPaths = function unifyPaths(paths_) {
  /**
   * @type {Array<String>}
   */
  var paths = flatten(arrify(paths_));

  if (!paths.every(function (p) {
    return _typeof(p) === STRING_TYPE;
  })) {
    throw new TypeError("Non-string provided as watch path: ".concat(paths));
  }

  return paths.map(normalizePathToUnix);
}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path


var toUnix = function toUnix(string) {
  var str = string.replace(BACK_SLASH_RE, SLASH);
  var prepend = false;

  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }

  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }

  if (prepend) {
    str = SLASH + str;
  }

  return str;
}; // Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why


var normalizePathToUnix = function normalizePathToUnix(path) {
  return toUnix(sysPath.normalize(toUnix(path)));
};

var normalizeIgnored = function normalizeIgnored() {
  var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;
  return function (path) {
    if (_typeof(path) !== STRING_TYPE) return path;
    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
  };
};

var getAbsolutePath = function getAbsolutePath(path, cwd) {
  if (sysPath.isAbsolute(path)) {
    return path;
  }

  if (path.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path.slice(1));
  }

  return sysPath.join(cwd, path);
};

var undef = function undef(opts, key) {
  return opts[key] === undefined;
};
/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */


var DirEntry = /*#__PURE__*/function () {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  function DirEntry(dir, removeWatcher) {
    _classCallCheck(this, DirEntry);

    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type {Set<Path>} */

    this.items = new Set();
  }

  _createClass(DirEntry, [{
    key: "add",
    value: function add(item) {
      var items = this.items;
      if (!items) return;
      if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
    }
  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(item) {
        var items, dir;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                items = this.items;

                if (items) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                items["delete"](item);

                if (!(items.size > 0)) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return");

              case 6:
                dir = this.path;
                _context.prev = 7;
                _context.next = 10;
                return readdir(dir);

              case 10:
                _context.next = 15;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](7);

                if (this._removeWatcher) {
                  this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
                }

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 12]]);
      }));

      function remove(_x) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
  }, {
    key: "has",
    value: function has(item) {
      var items = this.items;
      if (!items) return;
      return items.has(item);
    }
    /**
     * @returns {Array<String>}
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      var items = this.items;
      if (!items) return;
      return _toConsumableArray(items.values());
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.items.clear();
      delete this.path;
      delete this._removeWatcher;
      delete this.items;
      Object.freeze(this);
    }
  }]);

  return DirEntry;
}();

var STAT_METHOD_F = 'stat';
var STAT_METHOD_L = 'lstat';

var WatchHelper = /*#__PURE__*/function () {
  function WatchHelper(path, watchPath, follow, fsw) {
    _classCallCheck(this, WatchHelper);

    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type {object|boolean} */

    if (path === EMPTY_STR) this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? undefined : false;
    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach(function (parts) {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }

  _createClass(WatchHelper, [{
    key: "checkGlobSymlink",
    value: function checkGlobSymlink(entry) {
      // only need to resolve once
      // first entry should always have entry.parentDir === EMPTY_STR
      if (this.globSymlink === undefined) {
        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {
          realPath: entry.fullParentDir,
          linkPath: this.fullWatchPath
        };
      }

      if (this.globSymlink) {
        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
      }

      return entry.fullPath;
    }
  }, {
    key: "entryPath",
    value: function entryPath(entry) {
      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
    }
  }, {
    key: "filterPath",
    value: function filterPath(entry) {
      var stats = entry.stats;
      if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
      var resolvedPath = this.entryPath(entry);
      var matchesGlob = this.hasGlob && _typeof(this.globFilter) === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
    }
  }, {
    key: "getDirParts",
    value: function getDirParts(path) {
      var _this = this;

      if (!this.hasGlob) return [];
      var parts = [];
      var expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
      expandedPath.forEach(function (path) {
        parts.push(sysPath.relative(_this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
      });
      return parts;
    }
  }, {
    key: "filterDir",
    value: function filterDir(entry) {
      if (this.hasGlob) {
        var entryParts = this.getDirParts(this.checkGlobSymlink(entry));
        var globstar = false;
        this.unmatchedGlob = !this.dirParts.some(function (parts) {
          return parts.every(function (part, i) {
            if (part === GLOBSTAR) globstar = true;
            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
          });
        });
      }

      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
    }
  }]);

  return WatchHelper;
}();
/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */


var FSWatcher = /*#__PURE__*/function (_EventEmitter) {
  _inherits(FSWatcher, _EventEmitter);

  var _super = _createSuper(FSWatcher);

  // Not indenting methods for history sake; for now.
  function FSWatcher(_opts) {
    var _this2;

    _classCallCheck(this, FSWatcher);

    _this2 = _super.call(this);
    var opts = {};
    if (_opts) Object.assign(opts, _opts); // for frozen objects

    /** @type {Map<String, DirEntry>} */

    _this2._watched = new Map();
    /** @type {Map<String, Array>} */

    _this2._closers = new Map();
    /** @type {Set<String>} */

    _this2._ignoredPaths = new Set();
    /** @type {Map<ThrottleType, Map>} */

    _this2._throttled = new Map();
    /** @type {Map<Path, String|Boolean>} */

    _this2._symlinkPaths = new Map();
    _this2._streams = new Set();
    _this2.closed = false; // Set up default options.

    if (undef(opts, 'persistent')) opts.persistent = true;
    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
    if (undef(opts, 'interval')) opts.interval = 100;
    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.

    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.

    var canUseFsEvents = FsEventsHandler.canUse();
    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.
    // Other platforms use non-polling fs_watch.

    if (undef(opts, 'usePolling') && !opts.useFsEvents) {
      opts.usePolling = isMacos;
    } // Global override (useful for end-developers that need to force polling for all
    // instances of chokidar, regardless of usage/dependency depth)


    var envPoll = process.env.CHOKIDAR_USEPOLLING;

    if (envPoll !== undefined) {
      var envLower = envPoll.toLowerCase();

      if (envLower === 'false' || envLower === '0') {
        opts.usePolling = false;
      } else if (envLower === 'true' || envLower === '1') {
        opts.usePolling = true;
      } else {
        opts.usePolling = !!envLower;
      }
    }

    var envInterval = process.env.CHOKIDAR_INTERVAL;

    if (envInterval) {
      opts.interval = Number.parseInt(envInterval, 10);
    } // Editor atomic write normalization enabled by default with fs.watch


    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
    if (opts.atomic) _this2._pendingUnlinks = new Map();
    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;
    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
    var awf = opts.awaitWriteFinish;

    if (awf) {
      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
      if (!awf.pollInterval) awf.pollInterval = 100;
      _this2._pendingWrites = new Map();
    }

    if (opts.ignored) opts.ignored = arrify(opts.ignored);
    var readyCalls = 0;

    _this2._emitReady = function () {
      readyCalls++;

      if (readyCalls >= _this2._readyCount) {
        _this2._emitReady = EMPTY_FN;
        _this2._readyEmitted = true; // use process.nextTick to allow time for listener to be bound

        process.nextTick(function () {
          return _this2.emit(EV_READY);
        });
      }
    };

    _this2._emitRaw = function () {
      var _this3;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_this3 = _this2).emit.apply(_this3, [EV_RAW].concat(args));
    };

    _this2._readyEmitted = false;
    _this2.options = opts; // Initialize with proper watcher.

    if (opts.useFsEvents) {
      _this2._fsEventsHandler = new FsEventsHandler(_assertThisInitialized(_this2));
    } else {
      _this2._nodeFsHandler = new NodeFsHandler(_assertThisInitialized(_this2));
    } // You’re frozen when your heart’s not open.


    Object.freeze(opts);
    return _this2;
  } // Public methods

  /**
   * Adds paths to be watched on an existing FSWatcher instance
   * @param {Path|Array<Path>} paths_
   * @param {String=} _origAdd private; for handling non-existent paths to be watched
   * @param {Boolean=} _internal private; indicates a non-user add
   * @returns {FSWatcher} for chaining
   */


  _createClass(FSWatcher, [{
    key: "add",
    value: function add(paths_, _origAdd, _internal) {
      var _this4 = this;

      var _this$options = this.options,
          cwd = _this$options.cwd,
          disableGlobbing = _this$options.disableGlobbing;
      this.closed = false;
      var paths = unifyPaths(paths_);

      if (cwd) {
        paths = paths.map(function (path) {
          var absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob

          if (disableGlobbing || !isGlob(path)) {
            return absPath;
          }

          return normalizePath(absPath);
        });
      } // set aside negated glob strings


      paths = paths.filter(function (path) {
        if (path.startsWith(BANG)) {
          _this4._ignoredPaths.add(path.slice(1));

          return false;
        } // if a path is being added that was previously ignored, stop ignoring it


        _this4._ignoredPaths["delete"](path);

        _this4._ignoredPaths["delete"](path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn
        // to make ignoredPaths changes effective


        _this4._userIgnored = undefined;
        return true;
      });

      if (this.options.useFsEvents && this._fsEventsHandler) {
        if (!this._readyCount) this._readyCount = paths.length;
        if (this.options.persistent) this._readyCount *= 2;
        paths.forEach(function (path) {
          return _this4._fsEventsHandler._addToFsEvents(path);
        });
      } else {
        if (!this._readyCount) this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map( /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path) {
            var res;
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return _this4._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);

                  case 2:
                    res = _context2.sent;
                    if (res) _this4._emitReady();
                    return _context2.abrupt("return", res);

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          return function (_x2) {
            return _ref.apply(this, arguments);
          };
        }())).then(function (results) {
          if (_this4.closed) return;
          results.filter(function (item) {
            return item;
          }).forEach(function (item) {
            _this4.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          });
        });
      }

      return this;
    }
    /**
     * Close watchers or start ignoring events from specified paths.
     * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
     * @returns {FSWatcher} for chaining
    */

  }, {
    key: "unwatch",
    value: function unwatch(paths_) {
      var _this5 = this;

      if (this.closed) return this;
      var paths = unifyPaths(paths_);
      var cwd = this.options.cwd;
      paths.forEach(function (path) {
        // convert to absolute path unless relative path already matches
        if (!sysPath.isAbsolute(path) && !_this5._closers.has(path)) {
          if (cwd) path = sysPath.join(cwd, path);
          path = sysPath.resolve(path);
        }

        _this5._closePath(path);

        _this5._ignoredPaths.add(path);

        if (_this5._watched.has(path)) {
          _this5._ignoredPaths.add(path + SLASH_GLOBSTAR);
        } // reset the cached userIgnored anymatch fn
        // to make ignoredPaths changes effective


        _this5._userIgnored = undefined;
      });
      return this;
    }
    /**
     * Close watchers and remove all listeners from watched paths.
     * @returns {Promise<void>}.
    */

  }, {
    key: "close",
    value: function close() {
      var _this6 = this;

      if (this.closed) return this._closePromise;
      this.closed = true; // Memory management.

      this.removeAllListeners();
      var closers = [];

      this._closers.forEach(function (closerList) {
        return closerList.forEach(function (closer) {
          var promise = closer();
          if (promise instanceof Promise) closers.push(promise);
        });
      });

      this._streams.forEach(function (stream) {
        return stream.destroy();
      });

      this._userIgnored = undefined;
      this._readyCount = 0;
      this._readyEmitted = false;

      this._watched.forEach(function (dirent) {
        return dirent.dispose();
      });

      ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(function (key) {
        _this6["_".concat(key)].clear();
      });
      this._closePromise = closers.length ? Promise.all(closers).then(function () {
        return undefined;
      }) : Promise.resolve();
      return this._closePromise;
    }
    /**
     * Expose list of watched paths
     * @returns {Object} for chaining
    */

  }, {
    key: "getWatched",
    value: function getWatched() {
      var _this7 = this;

      var watchList = {};

      this._watched.forEach(function (entry, dir) {
        var key = _this7.options.cwd ? sysPath.relative(_this7.options.cwd, dir) : dir;
        watchList[key || ONE_DOT] = entry.getChildren().sort();
      });

      return watchList;
    }
  }, {
    key: "emitWithAll",
    value: function emitWithAll(event, args) {
      this.emit.apply(this, _toConsumableArray(args));
      if (event !== EV_ERROR) this.emit.apply(this, [EV_ALL].concat(_toConsumableArray(args)));
    } // Common helpers
    // --------------

    /**
     * Normalize and emit events.
     * Calling _emit DOES NOT MEAN emit() would be called!
     * @param {EventName} event Type of event
     * @param {Path} path File or directory path
     * @param {*=} val1 arguments to be passed with event
     * @param {*=} val2
     * @param {*=} val3
     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */

  }, {
    key: "_emit",
    value: function () {
      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(event, path, val1, val2, val3) {
        var _this8 = this;

        var opts, args, awf, pw, awfEmit, isThrottled, fullPath, stats;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.closed) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                opts = this.options;
                if (isWindows) path = sysPath.normalize(path);
                if (opts.cwd) path = sysPath.relative(opts.cwd, path);
                /** @type Array<any> */

                args = [event, path];
                if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);
                awf = opts.awaitWriteFinish;

                if (!(awf && (pw = this._pendingWrites.get(path)))) {
                  _context3.next = 11;
                  break;
                }

                pw.lastChange = new Date();
                return _context3.abrupt("return", this);

              case 11:
                if (!opts.atomic) {
                  _context3.next = 17;
                  break;
                }

                if (!(event === EV_UNLINK)) {
                  _context3.next = 16;
                  break;
                }

                this._pendingUnlinks.set(path, args);

                setTimeout(function () {
                  _this8._pendingUnlinks.forEach(function (entry, path) {
                    _this8.emit.apply(_this8, _toConsumableArray(entry));

                    _this8.emit.apply(_this8, [EV_ALL].concat(_toConsumableArray(entry)));

                    _this8._pendingUnlinks["delete"](path);
                  });
                }, typeof opts.atomic === 'number' ? opts.atomic : 100);
                return _context3.abrupt("return", this);

              case 16:
                if (event === EV_ADD && this._pendingUnlinks.has(path)) {
                  event = args[0] = EV_CHANGE;

                  this._pendingUnlinks["delete"](path);
                }

              case 17:
                if (!(awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted)) {
                  _context3.next = 21;
                  break;
                }

                awfEmit = function awfEmit(err, stats) {
                  if (err) {
                    event = args[0] = EV_ERROR;
                    args[1] = err;

                    _this8.emitWithAll(event, args);
                  } else if (stats) {
                    // if stats doesn't exist the file must have been deleted
                    if (args.length > 2) {
                      args[2] = stats;
                    } else {
                      args.push(stats);
                    }

                    _this8.emitWithAll(event, args);
                  }
                };

                this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);

                return _context3.abrupt("return", this);

              case 21:
                if (!(event === EV_CHANGE)) {
                  _context3.next = 25;
                  break;
                }

                isThrottled = !this._throttle(EV_CHANGE, path, 50);

                if (!isThrottled) {
                  _context3.next = 25;
                  break;
                }

                return _context3.abrupt("return", this);

              case 25:
                if (!(opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE))) {
                  _context3.next = 38;
                  break;
                }

                fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
                _context3.prev = 27;
                _context3.next = 30;
                return stat(fullPath);

              case 30:
                stats = _context3.sent;
                _context3.next = 35;
                break;

              case 33:
                _context3.prev = 33;
                _context3.t0 = _context3["catch"](27);

              case 35:
                if (!(!stats || this.closed)) {
                  _context3.next = 37;
                  break;
                }

                return _context3.abrupt("return");

              case 37:
                args.push(stats);

              case 38:
                this.emitWithAll(event, args);
                return _context3.abrupt("return", this);

              case 40:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[27, 33]]);
      }));

      function _emit(_x3, _x4, _x5, _x6, _x7) {
        return _emit2.apply(this, arguments);
      }

      return _emit;
    }()
    /**
     * Common handler for errors
     * @param {Error} error
     * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */

  }, {
    key: "_handleError",
    value: function _handleError(error) {
      var code = error && error.code;

      if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {
        this.emit(EV_ERROR, error);
      }

      return error || this.closed;
    }
    /**
     * Helper utility for throttling
     * @param {ThrottleType} actionType type being throttled
     * @param {Path} path being acted upon
     * @param {Number} timeout duration of time to suppress duplicate actions
     * @returns {Object|false} tracking object or false if action should be suppressed
     */

  }, {
    key: "_throttle",
    value: function _throttle(actionType, path, timeout) {
      if (!this._throttled.has(actionType)) {
        this._throttled.set(actionType, new Map());
      }
      /** @type {Map<Path, Object>} */


      var action = this._throttled.get(actionType);
      /** @type {Object} */


      var actionPath = action.get(path);

      if (actionPath) {
        actionPath.count++;
        return false;
      }

      var timeoutObject;

      var clear = function clear() {
        var item = action.get(path);
        var count = item ? item.count : 0;
        action["delete"](path);
        clearTimeout(timeoutObject);
        if (item) clearTimeout(item.timeoutObject);
        return count;
      };

      timeoutObject = setTimeout(clear, timeout);
      var thr = {
        timeoutObject: timeoutObject,
        clear: clear,
        count: 0
      };
      action.set(path, thr);
      return thr;
    }
  }, {
    key: "_incrReadyCount",
    value: function _incrReadyCount() {
      return this._readyCount++;
    }
    /**
     * Awaits write operation to finish.
     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
     * @param {Path} path being acted upon
     * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
     * @param {EventName} event
     * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
     */

  }, {
    key: "_awaitWriteFinish",
    value: function _awaitWriteFinish(path, threshold, event, awfEmit) {
      var _this9 = this;

      var timeoutHandler;
      var fullPath = path;

      if (this.options.cwd && !sysPath.isAbsolute(path)) {
        fullPath = sysPath.join(this.options.cwd, path);
      }

      var now = new Date();

      var awaitWriteFinish = function awaitWriteFinish(prevStat) {
        fs.stat(fullPath, function (err, curStat) {
          if (err || !_this9._pendingWrites.has(path)) {
            if (err && err.code !== 'ENOENT') awfEmit(err);
            return;
          }

          var now = Number(new Date());

          if (prevStat && curStat.size !== prevStat.size) {
            _this9._pendingWrites.get(path).lastChange = now;
          }

          var pw = _this9._pendingWrites.get(path);

          var df = now - pw.lastChange;

          if (df >= threshold) {
            _this9._pendingWrites["delete"](path);

            awfEmit(undefined, curStat);
          } else {
            timeoutHandler = setTimeout(awaitWriteFinish, _this9.options.awaitWriteFinish.pollInterval, curStat);
          }
        });
      };

      if (!this._pendingWrites.has(path)) {
        this._pendingWrites.set(path, {
          lastChange: now,
          cancelWait: function cancelWait() {
            _this9._pendingWrites["delete"](path);

            clearTimeout(timeoutHandler);
            return event;
          }
        });

        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
      }
    }
  }, {
    key: "_getGlobIgnored",
    value: function _getGlobIgnored() {
      return _toConsumableArray(this._ignoredPaths.values());
    }
    /**
     * Determines whether user has asked to ignore this path.
     * @param {Path} path filepath or dir
     * @param {fs.Stats=} stats result of fs.stat
     * @returns {Boolean}
     */

  }, {
    key: "_isIgnored",
    value: function _isIgnored(path, stats) {
      if (this.options.atomic && DOT_RE.test(path)) return true;

      if (!this._userIgnored) {
        var cwd = this.options.cwd;
        var ign = this.options.ignored;
        var ignored = ign && ign.map(normalizeIgnored(cwd));
        var paths = arrify(ignored).filter(function (path) {
          return _typeof(path) === STRING_TYPE && !isGlob(path);
        }).map(function (path) {
          return path + SLASH_GLOBSTAR;
        });

        var list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);

        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
      }

      return this._userIgnored([path, stats]);
    }
  }, {
    key: "_isntIgnored",
    value: function _isntIgnored(path, stat) {
      return !this._isIgnored(path, stat);
    }
    /**
     * Provides a set of common helpers and properties relating to symlink and glob handling.
     * @param {Path} path file, directory, or glob pattern being watched
     * @param {Number=} depth at any depth > 0, this isn't a glob
     * @returns {WatchHelper} object containing helpers for this path
     */

  }, {
    key: "_getWatchHelpers",
    value: function _getWatchHelpers(path, depth) {
      var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
      var follow = this.options.followSymlinks;
      return new WatchHelper(path, watchPath, follow, this);
    } // Directory helpers
    // -----------------

    /**
     * Provides directory tracking objects
     * @param {String} directory path of the directory
     * @returns {DirEntry} the directory's tracking object
     */

  }, {
    key: "_getWatchedDir",
    value: function _getWatchedDir(directory) {
      if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
      var dir = sysPath.resolve(directory);
      if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
      return this._watched.get(dir);
    } // File helpers
    // ------------

    /**
     * Check for read permissions.
     * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
     * @param {fs.Stats} stats - object, result of fs_stat
     * @returns {Boolean} indicates whether the file can be read
    */

  }, {
    key: "_hasReadPermissions",
    value: function _hasReadPermissions(stats) {
      if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint

      var md = stats && Number.parseInt(stats.mode, 10);
      var st = md & 511;
      var it = Number.parseInt(st.toString(8)[0], 10);
      return Boolean(4 & it);
    }
    /**
     * Handles emitting unlink events for
     * files and directories, and via recursion, for
     * files and directories within directories that are unlinked
     * @param {String} directory within which the following item is located
     * @param {String} item      base path of item/directory
     * @returns {void}
    */

  }, {
    key: "_remove",
    value: function _remove(directory, item, isDirectory) {
      var _this10 = this;

      // if what is being deleted is a directory, get that directory's paths
      // for recursive deleting and cleaning of watched object
      // if it is not a directory, nestedDirectoryChildren will be empty array
      var path = sysPath.join(directory, item);
      var fullPath = sysPath.resolve(path);
      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously
      // via multiple paths (such as _handleFile and _handleDir)

      if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return

      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
        this.add(directory, item, true);
      } // This will create a new entry in the watched object in either case
      // so we got to do the directory check beforehand


      var wp = this._getWatchedDir(path);

      var nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.

      nestedDirectoryChildren.forEach(function (nested) {
        return _this10._remove(path, nested);
      }); // Check if item was on the watched list and remove it

      var parent = this._getWatchedDir(directory);

      var wasTracked = parent.has(item);
      parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks
      // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
      // but never removed from the map in case the path was deleted.
      // This leads to an incorrect state if the path was recreated:
      // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553

      if (this._symlinkPaths.has(fullPath)) {
        this._symlinkPaths["delete"](fullPath);
      } // If we wait for this file to be fully written, cancel the wait.


      var relPath = path;
      if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);

      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
        var event = this._pendingWrites.get(relPath).cancelWait();

        if (event === EV_ADD) return;
      } // The Entry will either be a directory that just got removed
      // or a bogus entry to a file, in either case we have to remove it


      this._watched["delete"](path);

      this._watched["delete"](fullPath);

      var eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name

      if (!this.options.useFsEvents) {
        this._closePath(path);
      }
    }
    /**
     * Closes all watchers for a path
     * @param {Path} path
     */

  }, {
    key: "_closePath",
    value: function _closePath(path) {
      this._closeFile(path);

      var dir = sysPath.dirname(path);

      this._getWatchedDir(dir).remove(sysPath.basename(path));
    }
    /**
     * Closes only file-specific watchers
     * @param {Path} path
     */

  }, {
    key: "_closeFile",
    value: function _closeFile(path) {
      var closers = this._closers.get(path);

      if (!closers) return;
      closers.forEach(function (closer) {
        return closer();
      });

      this._closers["delete"](path);
    }
    /**
     *
     * @param {Path} path
     * @param {Function} closer
     */

  }, {
    key: "_addPathCloser",
    value: function _addPathCloser(path, closer) {
      if (!closer) return;

      var list = this._closers.get(path);

      if (!list) {
        list = [];

        this._closers.set(path, list);
      }

      list.push(closer);
    }
  }, {
    key: "_readdirp",
    value: function _readdirp(root, opts) {
      var _this11 = this;

      if (this.closed) return;

      var options = _objectSpread({
        type: EV_ALL,
        alwaysStat: true,
        lstat: true
      }, opts);

      var stream = readdirp(root, options);

      this._streams.add(stream);

      stream.once(STR_CLOSE, function () {
        stream = undefined;
      });
      stream.once(STR_END, function () {
        if (stream) {
          _this11._streams["delete"](stream);

          stream = undefined;
        }
      });
      return stream;
    }
  }]);

  return FSWatcher;
}(EventEmitter); // Export FSWatcher class


exports.FSWatcher = FSWatcher;
/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */

var watch = function watch(paths, options) {
  var watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
};

exports.watch = watch;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/assertThisInitialized":41,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/typeof":12,"events":-19260817,"fs":-19260817,"path":-19260817,"util":-19260817,"readdirp":384,"anymatch":385,"glob-parent":386,"is-glob":387,"braces":388,"normalize-path":389,"./lib/nodefs-handler":390,"./lib/fsevents-handler":391,"./lib/constants":392}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/object-keys/isArguments.js
      356: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';

  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && _typeof(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }

  return isArgs;
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/object-keys/implementation.js
      357: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var keysShim;

if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;

  var isArgs = require('./isArguments'); // eslint-disable-line global-require


  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };

  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };

  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }

    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }

    return false;
  }();

  var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }

    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };

  keysShim = function keys(object) {
    var isObject = object !== null && _typeof(object) === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];

    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }

    var skipProto = hasProtoEnumBug && isFunction;

    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }

    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }

    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }

    return theKeys;
  };
}

module.exports = keysShim;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./isArguments":356}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/5/CheckObjectCoercible.js
      358: {
        factory: (module, exports, require) => {
          'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = GetIntrinsic('%TypeError%'); // http://262.ecma-international.org/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value, optMessage) {
  if (value == null) {
    throw new $TypeError(optMessage || 'Cannot call method on ' + value);
  }

  return value;
};
        },
        map: {"get-intrinsic":266}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-regex/index.js
      359: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var callBound = require('call-bind/callBound');

var hasToStringTag = require('has-tostringtag/shams')();

var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
  has = callBound('Object.prototype.hasOwnProperty');
  $exec = callBound('RegExp.prototype.exec');
  isRegexMarker = {};

  var throwRegexMarker = function throwRegexMarker() {
    throw isRegexMarker;
  };

  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };

  if (_typeof(Symbol.toPrimitive) === 'symbol') {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';
module.exports = hasToStringTag // eslint-disable-next-line consistent-return
? function isRegex(value) {
  if (!value || _typeof(value) !== 'object') {
    return false;
  }

  var descriptor = gOPD(value, 'lastIndex');
  var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');

  if (!hasLastIndexDataProperty) {
    return false;
  }

  try {
    $exec(value, badStringifier);
  } catch (e) {
    return e === isRegexMarker;
  }
} : function isRegex(value) {
  // In older browsers, typeof regex incorrectly returns 'function'
  if (!value || _typeof(value) !== 'object' && typeof value !== 'function') {
    return false;
  }

  return $toString(value) === regexClass;
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"call-bind/callBound":267,"has-tostringtag/shams":393}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/2019/ToBoolean.js
      360: {
        factory: (module, exports, require) => {
          'use strict'; // http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) {
  return !!value;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/5/ToInteger.js
      361: {
        factory: (module, exports, require) => {
          'use strict';

var abs = require('./abs');

var floor = require('./floor');

var ToNumber = require('./ToNumber');

var $isNaN = require('../helpers/isNaN');

var $isFinite = require('../helpers/isFinite');

var $sign = require('../helpers/sign'); // http://262.ecma-international.org/5.1/#sec-9.4


module.exports = function ToInteger(value) {
  var number = ToNumber(value);

  if ($isNaN(number)) {
    return 0;
  }

  if (number === 0 || !$isFinite(number)) {
    return number;
  }

  return $sign(number) * floor(abs(number));
};
        },
        map: {"./abs":394,"./floor":395,"./ToNumber":396,"../helpers/isNaN":397,"../helpers/isFinite":398,"../helpers/sign":399}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/2019/ToNumber.js
      362: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var GetIntrinsic = require('get-intrinsic');

var $TypeError = GetIntrinsic('%TypeError%');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bind/callBound');

var regexTester = require('../helpers/regexTester');

var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ["\x85", "\u200B", "\uFFFE"].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex); // whitespace from: https://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324

var ws = ["\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003", "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028", "\u2029\uFEFF"].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var $replace = callBound('String.prototype.replace');

var $trim = function $trim(value) {
  return $replace(value, trimRegex, '');
};

var ToPrimitive = require('./ToPrimitive'); // https://ecma-international.org/ecma-262/6.0/#sec-tonumber


module.exports = function ToNumber(argument) {
  var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);

  if (_typeof(value) === 'symbol') {
    throw new $TypeError('Cannot convert a Symbol value to a number');
  }

  if (typeof value === 'string') {
    if (isBinary(value)) {
      return ToNumber($parseInteger($strSlice(value, 2), 2));
    } else if (isOctal(value)) {
      return ToNumber($parseInteger($strSlice(value, 2), 8));
    } else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
      return NaN;
    }

    var trimmed = $trim(value);

    if (trimmed !== value) {
      return ToNumber(trimmed);
    }
  }

  return $Number(value);
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"get-intrinsic":266,"call-bind/callBound":267,"../helpers/regexTester":400,"../helpers/isPrimitive":401,"./ToPrimitive":402}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Unescaper.js
      363: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var Pattern, Unescaper, Utils;
Utils = require('./Utils');
Pattern = require('./Pattern');

Unescaper = function () {
  function Unescaper() {}

  Unescaper.PATTERN_ESCAPED_CHARACTER = new Pattern('\\\\([0abt\tnvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');

  Unescaper.unescapeSingleQuotedString = function (value) {
    return value.replace(/\'\'/g, '\'');
  };

  Unescaper.unescapeDoubleQuotedString = function (value) {
    if (this._unescapeCallback == null) {
      this._unescapeCallback = function (_this) {
        return function (str) {
          return _this.unescapeCharacter(str);
        };
      }(this);
    }

    return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
  };

  Unescaper.unescapeCharacter = function (value) {
    var ch;
    ch = String.fromCharCode;

    switch (value.charAt(1)) {
      case '0':
        return ch(0);

      case 'a':
        return ch(7);

      case 'b':
        return ch(8);

      case 't':
        return "\t";

      case "\t":
        return "\t";

      case 'n':
        return "\n";

      case 'v':
        return ch(11);

      case 'f':
        return ch(12);

      case 'r':
        return ch(13);

      case 'e':
        return ch(27);

      case ' ':
        return ' ';

      case '"':
        return '"';

      case '/':
        return '/';

      case '\\':
        return '\\';

      case 'N':
        return ch(0x0085);

      case '_':
        return ch(0x00A0);

      case 'L':
        return ch(0x2028);

      case 'P':
        return ch(0x2029);

      case 'x':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));

      case 'u':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));

      case 'U':
        return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));

      default:
        return '';
    }
  };

  return Unescaper;
}();

module.exports = Unescaper;
        },
        map: {"./Utils":222,"./Pattern":304}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Escaper.js
      364: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var Escaper, Pattern;
Pattern = require('./Pattern');

Escaper = function () {
  var ch;

  function Escaper() {}

  Escaper.LIST_ESCAPEES = ['\\', '\\\\', '\\"', '"', "\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", "\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", (ch = String.fromCharCode)(0x0085), ch(0x00A0), ch(0x2028), ch(0x2029)];
  Escaper.LIST_ESCAPED = ['\\\\', '\\"', '\\"', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];

  Escaper.MAPPING_ESCAPEES_TO_ESCAPED = function () {
    var i, j, mapping, ref;
    mapping = {};

    for (i = j = 0, ref = Escaper.LIST_ESCAPEES.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      mapping[Escaper.LIST_ESCAPEES[i]] = Escaper.LIST_ESCAPED[i];
    }

    return mapping;
  }();

  Escaper.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern('[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9');
  Escaper.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper.LIST_ESCAPEES.join('|').split('\\').join('\\\\'));
  Escaper.PATTERN_SINGLE_QUOTING = new Pattern('[\\s\'":{}[\\],&*#?]|^[-?|<>=!%@`]');

  Escaper.requiresDoubleQuoting = function (value) {
    return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
  };

  Escaper.escapeWithDoubleQuotes = function (value) {
    var result;
    result = this.PATTERN_MAPPING_ESCAPEES.replace(value, function (_this) {
      return function (str) {
        return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
      };
    }(this));
    return '"' + result + '"';
  };

  Escaper.requiresSingleQuoting = function (value) {
    return this.PATTERN_SINGLE_QUOTING.test(value);
  };

  Escaper.escapeWithSingleQuotes = function (value) {
    return "'" + value.replace(/'/g, "''") + "'";
  };

  return Escaper;
}();

module.exports = Escaper;
        },
        map: {"./Pattern":304}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/yamljs/lib/Exception/DumpException.js
      365: {
        factory: (module, exports, require) => {
          // Generated by CoffeeScript 1.12.4
var DumpException,
    extend = function extend(child, parent) {
  for (var key in parent) {
    if (hasProp.call(parent, key)) child[key] = parent[key];
  }

  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
  child.__super__ = parent.prototype;
  return child;
},
    hasProp = {}.hasOwnProperty;

DumpException = function (superClass) {
  extend(DumpException, superClass);

  function DumpException(message, parsedLine, snippet) {
    this.message = message;
    this.parsedLine = parsedLine;
    this.snippet = snippet;
  }

  DumpException.prototype.toString = function () {
    if (this.parsedLine != null && this.snippet != null) {
      return '<DumpException> ' + this.message + ' (line ' + this.parsedLine + ': \'' + this.snippet + '\')';
    } else {
      return '<DumpException> ' + this.message;
    }
  };

  return DumpException;
}(Error);

module.exports = DumpException;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_assocIndexOf.js
      366: {
        factory: (module, exports, require) => {
          var eq = require('./eq');
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;
        },
        map: {"./eq":230}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_mapCacheClear.js
      367: {
        factory: (module, exports, require) => {
          var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;
        },
        map: {"./_Hash":403,"./_ListCache":224,"./_Map":234}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_mapCacheDelete.js
      368: {
        factory: (module, exports, require) => {
          var getMapData = require('./_getMapData');
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;
        },
        map: {"./_getMapData":404}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_mapCacheGet.js
      369: {
        factory: (module, exports, require) => {
          var getMapData = require('./_getMapData');
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;
        },
        map: {"./_getMapData":404}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_mapCacheHas.js
      370: {
        factory: (module, exports, require) => {
          var getMapData = require('./_getMapData');
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;
        },
        map: {"./_getMapData":404}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_mapCacheSet.js
      371: {
        factory: (module, exports, require) => {
          var getMapData = require('./_getMapData');
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;
        },
        map: {"./_getMapData":404}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsNative.js
      372: {
        factory: (module, exports, require) => {
          var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;
        },
        map: {"./isFunction":324,"./_isMasked":405,"./isObject":158,"./_toSource":239}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getValue.js
      373: {
        factory: (module, exports, require) => {
          /**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsTypedArray.js
      374: {
        factory: (module, exports, require) => {
          var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;
        },
        map: {"./_baseGetTag":238,"./isLength":271,"./isObjectLike":262}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/has-symbols/shams.js
      375: {
        factory: (module, exports, require) => {
          'use strict';
/* eslint complexity: [2, 18], max-statements: [2, 33] */

var _typeof = require("@babel/runtime/helpers/typeof");

module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (_typeof(Symbol.iterator) === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/function-bind/implementation.js
      376: {
        factory: (module, exports, require) => {
          'use strict';
/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slice.call(arguments, 1);
  var bound;

  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_baseIsEqualDeep.js
      377: {
        factory: (module, exports, require) => {
          var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;
        },
        map: {"./_Stack":143,"./_equalArrays":406,"./_equalByTag":407,"./_equalObjects":408,"./_getTag":152,"./isArray":99,"./isBuffer":156,"./isTypedArray":322}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/isexe/index.js
      378: {
        factory: (module, exports, require) => {
          var fs = require('fs');

var core;

if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = require('./windows.js');
} else {
  core = require('./mode.js');
}

module.exports = isexe;
isexe.sync = sync;

function isexe(path, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided');
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er);
        } else {
          resolve(is);
        }
      });
    });
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null;
        is = false;
      }
    }

    cb(er, is);
  });
}

function sync(path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {});
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false;
    } else {
      throw er;
    }
  }
}
        },
        map: {"fs":-19260817,"./windows.js":409,"./mode.js":410}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/clipboardy/node_modules/shebang-regex/index.js
      379: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = /^#!.*/;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/strip-ansi/index.js
      380: {
        factory: (module, exports, require) => {
          'use strict';

var ansiRegex = require('ansi-regex');

module.exports = function (string) {
  return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
};
        },
        map: {"ansi-regex":411}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/@curlconverter/yargs/node_modules/wrap-ansi/index.js
      381: {
        factory: (module, exports, require) => {
          'use strict';

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var stringWidth = require('string-width');

var stripAnsi = require('strip-ansi');

var ansiStyles = require('ansi-styles');

var ESCAPES = new Set(["\x1B", "\x9B"]);
var END_CODE = 39;
var ANSI_ESCAPE_BELL = "\x07";
var ANSI_CSI = '[';
var ANSI_OSC = ']';
var ANSI_SGR_TERMINATOR = 'm';
var ANSI_ESCAPE_LINK = "".concat(ANSI_OSC, "8;;");

var wrapAnsi = function wrapAnsi(code) {
  return "".concat(ESCAPES.values().next().value).concat(ANSI_CSI).concat(code).concat(ANSI_SGR_TERMINATOR);
};

var wrapAnsiHyperlink = function wrapAnsiHyperlink(uri) {
  return "".concat(ESCAPES.values().next().value).concat(ANSI_ESCAPE_LINK).concat(uri).concat(ANSI_ESCAPE_BELL);
}; // Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes


var wordLengths = function wordLengths(string) {
  return string.split(' ').map(function (character) {
    return stringWidth(character);
  });
}; // Wrap a long word across multiple rows
// Ansi escape codes do not count towards length


var wrapWord = function wrapWord(rows, word, columns) {
  var characters = _toConsumableArray(word);

  var isInsideEscape = false;
  var isInsideLinkEscape = false;
  var visible = stringWidth(stripAnsi(rows[rows.length - 1]));

  var _iterator = _createForOfIteratorHelper(characters.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          index = _step$value[0],
          character = _step$value[1];

      var characterLength = stringWidth(character);

      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }

      if (ESCAPES.has(character)) {
        isInsideEscape = true;
        isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
      }

      if (isInsideEscape) {
        if (isInsideLinkEscape) {
          if (character === ANSI_ESCAPE_BELL) {
            isInsideEscape = false;
            isInsideLinkEscape = false;
          }
        } else if (character === ANSI_SGR_TERMINATOR) {
          isInsideEscape = false;
        }

        continue;
      }

      visible += characterLength;

      if (visible === columns && index < characters.length - 1) {
        rows.push('');
        visible = 0;
      }
    } // It's possible that the last row we copy over is only
    // ansi escape characters, handle this edge-case

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
    rows[rows.length - 2] += rows.pop();
  }
}; // Trims spaces from a string ignoring invisible sequences


var stringVisibleTrimSpacesRight = function stringVisibleTrimSpacesRight(string) {
  var words = string.split(' ');
  var last = words.length;

  while (last > 0) {
    if (stringWidth(words[last - 1]) > 0) {
      break;
    }

    last--;
  }

  if (last === words.length) {
    return string;
  }

  return words.slice(0, last).join(' ') + words.slice(last).join('');
}; // The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length


var exec = function exec(string, columns) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.trim !== false && string.trim() === '') {
    return '';
  }

  var returnValue = '';
  var escapeCode;
  var escapeUrl;
  var lengths = wordLengths(string);
  var rows = [''];

  var _iterator2 = _createForOfIteratorHelper(string.split(' ').entries()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          index = _step2$value[0],
          word = _step2$value[1];

      if (options.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimStart();
      }

      var rowLength = stringWidth(rows[rows.length - 1]);

      if (index !== 0) {
        if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
          // If we start with a new word but the current row length equals the length of the columns, add a new row
          rows.push('');
          rowLength = 0;
        }

        if (rowLength > 0 || options.trim === false) {
          rows[rows.length - 1] += ' ';
          rowLength++;
        }
      } // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'


      if (options.hard && lengths[index] > columns) {
        var remainingColumns = columns - rowLength;
        var breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
        var breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);

        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push('');
        }

        wrapWord(rows, word, columns);
        continue;
      }

      if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }

        rows.push('');
      }

      if (rowLength + lengths[index] > columns && options.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }

      rows[rows.length - 1] += word;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  if (options.trim !== false) {
    rows = rows.map(stringVisibleTrimSpacesRight);
  }

  var pre = _toConsumableArray(rows.join('\n'));

  var _iterator3 = _createForOfIteratorHelper(pre.entries()),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          _index = _step3$value[0],
          character = _step3$value[1];

      returnValue += character;

      if (ESCAPES.has(character)) {
        var _ref = new RegExp("(?:\\".concat(ANSI_CSI, "(?<code>\\d+)m|\\").concat(ANSI_ESCAPE_LINK, "(?<uri>.*)").concat(ANSI_ESCAPE_BELL, ")")).exec(pre.slice(_index).join('')) || {
          groups: {}
        },
            groups = _ref.groups;

        if (groups.code !== undefined) {
          var _code = Number.parseFloat(groups.code);

          escapeCode = _code === END_CODE ? undefined : _code;
        } else if (groups.uri !== undefined) {
          escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
        }
      }

      var code = ansiStyles.codes.get(Number(escapeCode));

      if (pre[_index + 1] === '\n') {
        if (escapeUrl) {
          returnValue += wrapAnsiHyperlink('');
        }

        if (escapeCode && code) {
          returnValue += wrapAnsi(code);
        }
      } else if (character === '\n') {
        if (escapeCode && code) {
          returnValue += wrapAnsi(escapeCode);
        }

        if (escapeUrl) {
          returnValue += wrapAnsiHyperlink(escapeUrl);
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return returnValue;
}; // For each newline, invoke the method separately


module.exports = function (string, columns, options) {
  return String(string).normalize().replace(/\r\n/g, '\n').split('\n').map(function (line) {
    return exec(line, columns, options);
  }).join('\n');
};
        },
        map: {"@babel/runtime/helpers/slicedToArray":120,"@babel/runtime/helpers/toConsumableArray":35,"string-width":352,"strip-ansi":380,"ansi-styles":412}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-fullwidth-code-point/index.js
      382: {
        factory: (module, exports, require) => {
          /* eslint-disable yoda */
'use strict';

var isFullwidthCodePoint = function isFullwidthCodePoint(codePoint) {
  if (Number.isNaN(codePoint)) {
    return false;
  } // Code points are derived from:
  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


  if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
  codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
  0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
  0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
  0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
  0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
  0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
  0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
  0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
  0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
    return true;
  }

  return false;
};

module.exports = isFullwidthCodePoint;
module.exports["default"] = isFullwidthCodePoint;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/emoji-regex/index.js
      383: {
        factory: (module, exports, require) => {
          "use strict";

module.exports = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/readdirp/index.js
      384: {
        factory: (module, exports, require) => {
          'use strict';

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _typeof = require("@babel/runtime/helpers/typeof");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _inherits = require("@babel/runtime/helpers/inherits");

var _possibleConstructorReturn = require("@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("@babel/runtime/helpers/getPrototypeOf");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var fs = require('fs');

var _require = require('stream'),
    Readable = _require.Readable;

var sysPath = require('path');

var _require2 = require('util'),
    promisify = _require2.promisify;

var picomatch = require('picomatch');

var readdir = promisify(fs.readdir);
var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var realpath = promisify(fs.realpath);
/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */

var BANG = '!';
var NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);
var FILE_TYPE = 'files';
var DIR_TYPE = 'directories';
var FILE_DIR_TYPE = 'files_directories';
var EVERYTHING_TYPE = 'all';
var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

var isNormalFlowError = function isNormalFlowError(error) {
  return NORMAL_FLOW_ERRORS.has(error.code);
};

var normalizeFilter = function normalizeFilter(filter) {
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') {
    var glob = picomatch(filter.trim());
    return function (entry) {
      return glob(entry.basename);
    };
  }

  if (Array.isArray(filter)) {
    var positive = [];
    var negative = [];

    var _iterator = _createForOfIteratorHelper(filter),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;
        var trimmed = item.trim();

        if (trimmed.charAt(0) === BANG) {
          negative.push(picomatch(trimmed.slice(1)));
        } else {
          positive.push(picomatch(trimmed));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (negative.length > 0) {
      if (positive.length > 0) {
        return function (entry) {
          return positive.some(function (f) {
            return f(entry.basename);
          }) && !negative.some(function (f) {
            return f(entry.basename);
          });
        };
      }

      return function (entry) {
        return !negative.some(function (f) {
          return f(entry.basename);
        });
      };
    }

    return function (entry) {
      return positive.some(function (f) {
        return f(entry.basename);
      });
    };
  }
};

var ReaddirpStream = /*#__PURE__*/function (_Readable) {
  _inherits(ReaddirpStream, _Readable);

  var _super = _createSuper(ReaddirpStream);

  function ReaddirpStream() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ReaddirpStream);

    _this = _super.call(this, {
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark || 4096
    });

    var opts = _objectSpread(_objectSpread({}, ReaddirpStream.defaultOptions), options);

    var root = opts.root,
        type = opts.type;
    _this._fileFilter = normalizeFilter(opts.fileFilter);
    _this._directoryFilter = normalizeFilter(opts.directoryFilter);
    var statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).

    if (process.platform === 'win32' && stat.length === 3) {
      _this._stat = function (path) {
        return statMethod(path, {
          bigint: true
        });
      };
    } else {
      _this._stat = statMethod;
    }

    _this._maxDepth = opts.depth;
    _this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsEverything = type === EVERYTHING_TYPE;
    _this._root = sysPath.resolve(root);
    _this._isDirent = 'Dirent' in fs && !opts.alwaysStat;
    _this._statsProp = _this._isDirent ? 'dirent' : 'stats';
    _this._rdOptions = {
      encoding: 'utf8',
      withFileTypes: _this._isDirent
    }; // Launch stream with one parent, the root dir.

    _this.parents = [_this._exploreDir(root, 1)];
    _this.reading = false;
    _this.parent = undefined;
    return _this;
  }

  _createClass(ReaddirpStream, [{
    key: "_read",
    value: function () {
      var _read2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(batch) {
        var _this2 = this;

        var _loop, _ret;

        return _regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.reading) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                this.reading = true;
                _context2.prev = 3;
                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
                  var _ref, path, depth, _ref$files, files, slice, _iterator2, _step2, entry, entryType, parent;

                  return _regeneratorRuntime.wrap(function _loop$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _ref = _this2.parent || {}, path = _ref.path, depth = _ref.depth, _ref$files = _ref.files, files = _ref$files === void 0 ? [] : _ref$files;

                          if (!(files.length > 0)) {
                            _context.next = 30;
                            break;
                          }

                          slice = files.splice(0, batch).map(function (dirent) {
                            return _this2._formatEntry(dirent, path);
                          });
                          _context.t0 = _createForOfIteratorHelper;
                          _context.next = 6;
                          return Promise.all(slice);

                        case 6:
                          _context.t1 = _context.sent;
                          _iterator2 = (0, _context.t0)(_context.t1);
                          _context.prev = 8;

                          _iterator2.s();

                        case 10:
                          if ((_step2 = _iterator2.n()).done) {
                            _context.next = 20;
                            break;
                          }

                          entry = _step2.value;

                          if (!_this2.destroyed) {
                            _context.next = 14;
                            break;
                          }

                          return _context.abrupt("return", {
                            v: void 0
                          });

                        case 14:
                          _context.next = 16;
                          return _this2._getEntryType(entry);

                        case 16:
                          entryType = _context.sent;

                          if (entryType === 'directory' && _this2._directoryFilter(entry)) {
                            if (depth <= _this2._maxDepth) {
                              _this2.parents.push(_this2._exploreDir(entry.fullPath, depth + 1));
                            }

                            if (_this2._wantsDir) {
                              _this2.push(entry);

                              batch--;
                            }
                          } else if ((entryType === 'file' || _this2._includeAsFile(entry)) && _this2._fileFilter(entry)) {
                            if (_this2._wantsFile) {
                              _this2.push(entry);

                              batch--;
                            }
                          }

                        case 18:
                          _context.next = 10;
                          break;

                        case 20:
                          _context.next = 25;
                          break;

                        case 22:
                          _context.prev = 22;
                          _context.t2 = _context["catch"](8);

                          _iterator2.e(_context.t2);

                        case 25:
                          _context.prev = 25;

                          _iterator2.f();

                          return _context.finish(25);

                        case 28:
                          _context.next = 39;
                          break;

                        case 30:
                          parent = _this2.parents.pop();

                          if (parent) {
                            _context.next = 34;
                            break;
                          }

                          _this2.push(null);

                          return _context.abrupt("return", "break");

                        case 34:
                          _context.next = 36;
                          return parent;

                        case 36:
                          _this2.parent = _context.sent;

                          if (!_this2.destroyed) {
                            _context.next = 39;
                            break;
                          }

                          return _context.abrupt("return", {
                            v: void 0
                          });

                        case 39:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _loop, null, [[8, 22, 25, 28]]);
                });

              case 5:
                if (!(!this.destroyed && batch > 0)) {
                  _context2.next = 14;
                  break;
                }

                return _context2.delegateYield(_loop(), "t0", 7);

              case 7:
                _ret = _context2.t0;

                if (!(_ret === "break")) {
                  _context2.next = 10;
                  break;
                }

                return _context2.abrupt("break", 14);

              case 10:
                if (!(_typeof(_ret) === "object")) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", _ret.v);

              case 12:
                _context2.next = 5;
                break;

              case 14:
                _context2.next = 19;
                break;

              case 16:
                _context2.prev = 16;
                _context2.t1 = _context2["catch"](3);
                this.destroy(_context2.t1);

              case 19:
                _context2.prev = 19;
                this.reading = false;
                return _context2.finish(19);

              case 22:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee, this, [[3, 16, 19, 22]]);
      }));

      function _read(_x) {
        return _read2.apply(this, arguments);
      }

      return _read;
    }()
  }, {
    key: "_exploreDir",
    value: function () {
      var _exploreDir2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, depth) {
        var files;
        return _regeneratorRuntime.wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return readdir(path, this._rdOptions);

              case 3:
                files = _context3.sent;
                _context3.next = 9;
                break;

              case 6:
                _context3.prev = 6;
                _context3.t0 = _context3["catch"](0);

                this._onError(_context3.t0);

              case 9:
                return _context3.abrupt("return", {
                  files: files,
                  depth: depth,
                  path: path
                });

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2, this, [[0, 6]]);
      }));

      function _exploreDir(_x2, _x3) {
        return _exploreDir2.apply(this, arguments);
      }

      return _exploreDir;
    }()
  }, {
    key: "_formatEntry",
    value: function () {
      var _formatEntry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(dirent, path) {
        var entry, basename, fullPath;
        return _regeneratorRuntime.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                basename = this._isDirent ? dirent.name : dirent;
                fullPath = sysPath.resolve(sysPath.join(path, basename));
                entry = {
                  path: sysPath.relative(this._root, fullPath),
                  fullPath: fullPath,
                  basename: basename
                };

                if (!this._isDirent) {
                  _context4.next = 8;
                  break;
                }

                _context4.t0 = dirent;
                _context4.next = 11;
                break;

              case 8:
                _context4.next = 10;
                return this._stat(fullPath);

              case 10:
                _context4.t0 = _context4.sent;

              case 11:
                entry[this._statsProp] = _context4.t0;
                _context4.next = 17;
                break;

              case 14:
                _context4.prev = 14;
                _context4.t1 = _context4["catch"](0);

                this._onError(_context4.t1);

              case 17:
                return _context4.abrupt("return", entry);

              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3, this, [[0, 14]]);
      }));

      function _formatEntry(_x4, _x5) {
        return _formatEntry2.apply(this, arguments);
      }

      return _formatEntry;
    }()
  }, {
    key: "_onError",
    value: function _onError(err) {
      if (isNormalFlowError(err) && !this.destroyed) {
        this.emit('warn', err);
      } else {
        this.destroy(err);
      }
    }
  }, {
    key: "_getEntryType",
    value: function () {
      var _getEntryType2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(entry) {
        var stats, full, entryRealPath, entryRealPathStats, len;
        return _regeneratorRuntime.wrap(function _callee4$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // entry may be undefined, because a warning or an error were emitted
                // and the statsProp is undefined
                stats = entry && entry[this._statsProp];

                if (stats) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return");

              case 3:
                if (!stats.isFile()) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt("return", 'file');

              case 5:
                if (!stats.isDirectory()) {
                  _context5.next = 7;
                  break;
                }

                return _context5.abrupt("return", 'directory');

              case 7:
                if (!(stats && stats.isSymbolicLink())) {
                  _context5.next = 28;
                  break;
                }

                full = entry.fullPath;
                _context5.prev = 9;
                _context5.next = 12;
                return realpath(full);

              case 12:
                entryRealPath = _context5.sent;
                _context5.next = 15;
                return lstat(entryRealPath);

              case 15:
                entryRealPathStats = _context5.sent;

                if (!entryRealPathStats.isFile()) {
                  _context5.next = 18;
                  break;
                }

                return _context5.abrupt("return", 'file');

              case 18:
                if (!entryRealPathStats.isDirectory()) {
                  _context5.next = 23;
                  break;
                }

                len = entryRealPath.length;

                if (!(full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep)) {
                  _context5.next = 22;
                  break;
                }

                return _context5.abrupt("return", this._onError(new Error("Circular symlink detected: \"".concat(full, "\" points to \"").concat(entryRealPath, "\""))));

              case 22:
                return _context5.abrupt("return", 'directory');

              case 23:
                _context5.next = 28;
                break;

              case 25:
                _context5.prev = 25;
                _context5.t0 = _context5["catch"](9);

                this._onError(_context5.t0);

              case 28:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee4, this, [[9, 25]]);
      }));

      function _getEntryType(_x6) {
        return _getEntryType2.apply(this, arguments);
      }

      return _getEntryType;
    }()
  }, {
    key: "_includeAsFile",
    value: function _includeAsFile(entry) {
      var stats = entry && entry[this._statsProp];
      return stats && this._wantsEverything && !stats.isDirectory();
    }
  }], [{
    key: "defaultOptions",
    get: function get() {
      return {
        root: '.',

        /* eslint-disable no-unused-vars */
        fileFilter: function fileFilter(path) {
          return true;
        },
        directoryFilter: function directoryFilter(path) {
          return true;
        },

        /* eslint-enable no-unused-vars */
        type: FILE_TYPE,
        lstat: false,
        depth: 2147483648,
        alwaysStat: false
      };
    }
  }]);

  return ReaddirpStream;
}(Readable);
/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */


var readdirp = function readdirp(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var type = options.entryType || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility

  if (type) options.type = type;

  if (!root) {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error("readdirp: Invalid type passed. Use one of ".concat(ALL_TYPES.join(', ')));
  }

  options.root = root;
  return new ReaddirpStream(options);
};

var readdirpPromise = function readdirpPromise(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var files = [];
    readdirp(root, options).on('data', function (entry) {
      return files.push(entry);
    }).on('end', function () {
      return resolve(files);
    }).on('error', function (error) {
      return reject(error);
    });
  });
};

readdirp.promise = readdirpPromise;
readdirp.ReaddirpStream = ReaddirpStream;
readdirp["default"] = readdirp;
module.exports = readdirp;
        },
        map: {"@babel/runtime/regenerator":2,"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/getPrototypeOf":18,"fs":-19260817,"stream":-19260817,"path":-19260817,"util":-19260817,"picomatch":413}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/anymatch/index.js
      385: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var picomatch = require('picomatch');

var normalizePath = require('normalize-path');
/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */


var BANG = '!';
var DEFAULT_OPTIONS = {
  returnIndex: false
};

var arrify = function arrify(item) {
  return Array.isArray(item) ? item : [item];
};
/**
 * @param {AnymatchPattern} matcher
 * @param {object} options
 * @returns {AnymatchFn}
 */


var createPattern = function createPattern(matcher, options) {
  if (typeof matcher === 'function') {
    return matcher;
  }

  if (typeof matcher === 'string') {
    var glob = picomatch(matcher, options);
    return function (string) {
      return matcher === string || glob(string);
    };
  }

  if (matcher instanceof RegExp) {
    return function (string) {
      return matcher.test(string);
    };
  }

  return function (string) {
    return false;
  };
};
/**
 * @param {Array<Function>} patterns
 * @param {Array<Function>} negPatterns
 * @param {String|Array} args
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */


var matchPatterns = function matchPatterns(patterns, negPatterns, args, returnIndex) {
  var isList = Array.isArray(args);

  var _path = isList ? args[0] : args;

  if (!isList && typeof _path !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));
  }

  var path = normalizePath(_path);

  for (var index = 0; index < negPatterns.length; index++) {
    var nglob = negPatterns[index];

    if (nglob(path)) {
      return returnIndex ? -1 : false;
    }
  }

  var applied = isList && [path].concat(args.slice(1));

  for (var _index = 0; _index < patterns.length; _index++) {
    var pattern = patterns[_index];

    if (isList ? pattern.apply(void 0, _toConsumableArray(applied)) : pattern(path)) {
      return returnIndex ? _index : true;
    }
  }

  return returnIndex ? -1 : false;
};
/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
 * @param {object} options
 * @returns {boolean|number|Function}
 */


var anymatch = function anymatch(matchers, testString) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }

  var opts = typeof options === 'boolean' ? {
    returnIndex: options
  } : options;
  var returnIndex = opts.returnIndex || false; // Early cache for matchers.

  var mtchers = arrify(matchers);
  var negatedGlobs = mtchers.filter(function (item) {
    return typeof item === 'string' && item.charAt(0) === BANG;
  }).map(function (item) {
    return item.slice(1);
  }).map(function (item) {
    return picomatch(item, opts);
  });
  var patterns = mtchers.filter(function (item) {
    return typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG;
  }).map(function (matcher) {
    return createPattern(matcher, opts);
  });

  if (testString == null) {
    return function (testString) {
      var ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
  }

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};

anymatch["default"] = anymatch;
module.exports = anymatch;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"picomatch":413,"normalize-path":389}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/glob-parent/index.js
      386: {
        factory: (module, exports, require) => {
          'use strict';

var isGlob = require('is-glob');

var pathPosixDirname = require('path').posix.dirname;

var isWin32 = require('os').platform() === 'win32';
var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */

module.exports = function globParent(str, opts) {
  var options = Object.assign({
    flipBackslashes: true
  }, opts); // flip windows path separators

  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  } // special case for strings ending in enclosure containing path separator


  if (enclosure.test(str)) {
    str += slash;
  } // preserves full path in case of trailing path separator


  str += 'a'; // remove path parts that are globby

  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str)); // remove escape chars and return result


  return str.replace(escaped, '$1');
};
        },
        map: {"is-glob":387,"path":-19260817,"os":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-glob/index.js
      387: {
        factory: (module, exports, require) => {
          /*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isExtglob = require('is-extglob');

var chars = {
  '{': '}',
  '(': ')',
  '[': ']'
};

var strictCheck = function strictCheck(str) {
  if (str[0] === '!') {
    return true;
  }

  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;

  while (index < str.length) {
    if (str[index] === '*') {
      return true;
    }

    if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
      return true;
    }

    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf(']', index);
      }

      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }

        backSlashIndex = str.indexOf('\\', index);

        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }

    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
      closeCurlyIndex = str.indexOf('}', index);

      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf('\\', index);

        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }

    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
      closeParenIndex = str.indexOf(')', index);

      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf('\\', index);

        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }

    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf('|', index);
      }

      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
        closeParenIndex = str.indexOf(')', pipeIndex);

        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf('\\', pipeIndex);

          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);

        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }

  return false;
};

var relaxedCheck = function relaxedCheck(str) {
  if (str[0] === '!') {
    return true;
  }

  var index = 0;

  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);

        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }

  return false;
};

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var check = strictCheck; // optionally relax check

  if (options && options.strict === false) {
    check = relaxedCheck;
  }

  return check(str);
};
        },
        map: {"is-extglob":414}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/braces/index.js
      388: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var stringify = require('./lib/stringify');

var compile = require('./lib/compile');

var expand = require('./lib/expand');

var parse = require('./lib/parse');
/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */


var braces = function braces(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var output = [];

  if (Array.isArray(input)) {
    var _iterator = _createForOfIteratorHelper(input),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var pattern = _step.value;
        var result = braces.create(pattern, options);

        if (Array.isArray(result)) {
          var _output;

          (_output = output).push.apply(_output, _toConsumableArray(result));
        } else {
          output.push(result);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = _toConsumableArray(new Set(output));
  }

  return output;
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */


braces.parse = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return parse(input, options);
};
/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces.stringify = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }

  return stringify(input, options);
};
/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces.compile = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  return compile(input, options);
};
/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces.expand = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  var result = expand(input, options); // filter out empty strings if specified

  if (options.noempty === true) {
    result = result.filter(Boolean);
  } // filter out duplicates if specified


  if (options.nodupes === true) {
    result = _toConsumableArray(new Set(result));
  }

  return result;
};
/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces.create = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (input === '' || input.length < 3) {
    return [input];
  }

  return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
};
/**
 * Expose "braces"
 */


module.exports = braces;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"./lib/stringify":415,"./lib/compile":416,"./lib/expand":417,"./lib/parse":418}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/normalize-path/index.js
      389: {
        factory: (module, exports, require) => {
          /*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
module.exports = function (path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';
  var len = path.length;
  if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces

  var prefix = '';

  if (len > 4 && path[3] === '\\') {
    var ch = path[2];

    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);

  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }

  return prefix + segs.join('/');
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/chokidar/lib/nodefs-handler.js
      390: {
        factory: (module, exports, require) => {
          'use strict';

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var fs = require('fs');

var sysPath = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var isBinaryPath = require('is-binary-path');

var _require2 = require('./constants'),
    isWindows = _require2.isWindows,
    isLinux = _require2.isLinux,
    EMPTY_FN = _require2.EMPTY_FN,
    EMPTY_STR = _require2.EMPTY_STR,
    KEY_LISTENERS = _require2.KEY_LISTENERS,
    KEY_ERR = _require2.KEY_ERR,
    KEY_RAW = _require2.KEY_RAW,
    HANDLER_KEYS = _require2.HANDLER_KEYS,
    EV_CHANGE = _require2.EV_CHANGE,
    EV_ADD = _require2.EV_ADD,
    EV_ADD_DIR = _require2.EV_ADD_DIR,
    EV_ERROR = _require2.EV_ERROR,
    STR_DATA = _require2.STR_DATA,
    STR_END = _require2.STR_END,
    BRACE_START = _require2.BRACE_START,
    STAR = _require2.STAR;

var THROTTLE_MODE_WATCH = 'watch';
var open = promisify(fs.open);
var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var close = promisify(fs.close);
var fsrealpath = promisify(fs.realpath);
var statMethods = {
  lstat: lstat,
  stat: stat
}; // TODO: emit errors properly. Example: EMFILE on Macos.

var foreach = function foreach(val, fn) {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

var addAndConvert = function addAndConvert(main, prop, item) {
  var container = main[prop];

  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }

  container.add(item);
};

var clearItem = function clearItem(cont) {
  return function (key) {
    var set = cont[key];

    if (set instanceof Set) {
      set.clear();
    } else {
      delete cont[key];
    }
  };
};

var delFromSet = function delFromSet(main, prop, item) {
  var container = main[prop];

  if (container instanceof Set) {
    container["delete"](item);
  } else if (container === item) {
    delete main[prop];
  }
};

var isEmptySet = function isEmptySet(val) {
  return val instanceof Set ? val.size === 0 : !val;
};
/**
 * @typedef {String} Path
 */
// fs_watch helpers
// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */


var FsWatchInstances = new Map();
/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */

function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  var handleEvent = function handleEvent(rawEvent, evPath) {
    listener(path);
    emitRaw(rawEvent, evPath, {
      watchedPath: path
    }); // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)

    if (evPath && path !== evPath) {
      fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
    }
  };

  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}
/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */


var fsWatchBroadcast = function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
  var cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], function (listener) {
    listener(val1, val2, val3);
  });
};
/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */


var setFsWatchListener = function setFsWatchListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      errHandler = handlers.errHandler,
      rawEmitter = handlers.rawEmitter;
  var cont = FsWatchInstances.get(fullPath);
  /** @type {fs.FSWatcher=} */

  var watcher;

  if (!options.persistent) {
    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
    return watcher.close.bind(watcher);
  }

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here
    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
    if (!watcher) return;
    watcher.on(EV_ERROR, /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(error) {
        var broadcastErr, fd;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
                cont.watcherUnusable = true; // documented since Node 10.4.1
                // Workaround for https://github.com/joyent/node/issues/4337

                if (!(isWindows && error.code === 'EPERM')) {
                  _context.next = 16;
                  break;
                }

                _context.prev = 3;
                _context.next = 6;
                return open(path, 'r');

              case 6:
                fd = _context.sent;
                _context.next = 9;
                return close(fd);

              case 9:
                broadcastErr(error);
                _context.next = 14;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](3);

              case 14:
                _context.next = 17;
                break;

              case 16:
                broadcastErr(error);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 12]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher: watcher
    };
    FsWatchInstances.set(fullPath, cont);
  } // const index = cont.listeners.indexOf(listener);
  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left


  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);

    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close(); // }

      FsWatchInstances["delete"](fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
}; // fs_watchFile helpers
// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)


var FsWatchFileInstances = new Map();
/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */

var setFsWatchFileListener = function setFsWatchFileListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      rawEmitter = handlers.rawEmitter;
  var cont = FsWatchFileInstances.get(fullPath);
  /* eslint-disable no-unused-vars, prefer-destructuring */

  var listeners = new Set();
  var rawEmitters = new Set();
  var copts = cont && cont.options;

  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = undefined;
  }
  /* eslint-enable no-unused-vars, prefer-destructuring */


  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options: options,
      watcher: fs.watchFile(fullPath, options, function (curr, prev) {
        foreach(cont.rawEmitters, function (rawEmitter) {
          rawEmitter(EV_CHANGE, fullPath, {
            curr: curr,
            prev: prev
          });
        });
        var currmtime = curr.mtimeMs;

        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, function (listener) {
            return listener(path, curr);
          });
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  } // const index = cont.listeners.indexOf(listener);
  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.


  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);

    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances["delete"](fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};
/**
 * @mixin
 */


var NodeFsHandler = /*#__PURE__*/function () {
  /**
   * @param {import("../index").FSWatcher} fsW
   */
  function NodeFsHandler(fsW) {
    _classCallCheck(this, NodeFsHandler);

    this.fsw = fsW;

    this._boundHandleError = function (error) {
      return fsW._handleError(error);
    };
  }
  /**
   * Watch file for changes with fs_watchFile or fs_watch.
   * @param {String} path to file or dir
   * @param {Function} listener on fs change
   * @returns {Function} closer for the watcher instance
   */


  _createClass(NodeFsHandler, [{
    key: "_watchWithNodeFs",
    value: function _watchWithNodeFs(path, listener) {
      var opts = this.fsw.options;
      var directory = sysPath.dirname(path);
      var basename = sysPath.basename(path);

      var parent = this.fsw._getWatchedDir(directory);

      parent.add(basename);
      var absolutePath = sysPath.resolve(path);
      var options = {
        persistent: opts.persistent
      };
      if (!listener) listener = EMPTY_FN;
      var closer;

      if (opts.usePolling) {
        options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
        closer = setFsWatchFileListener(path, absolutePath, options, {
          listener: listener,
          rawEmitter: this.fsw._emitRaw
        });
      } else {
        closer = setFsWatchListener(path, absolutePath, options, {
          listener: listener,
          errHandler: this._boundHandleError,
          rawEmitter: this.fsw._emitRaw
        });
      }

      return closer;
    }
    /**
     * Watch a file and emit add event if warranted.
     * @param {Path} file Path
     * @param {fs.Stats} stats result of fs_stat
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @returns {Function} closer for the watcher instance
     */

  }, {
    key: "_handleFile",
    value: function _handleFile(file, stats, initialAdd) {
      var _this = this;

      if (this.fsw.closed) {
        return;
      }

      var dirname = sysPath.dirname(file);
      var basename = sysPath.basename(file);

      var parent = this.fsw._getWatchedDir(dirname); // stats is always present


      var prevStats = stats; // if the file is already being watched, do nothing

      if (parent.has(basename)) return;

      var listener = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, newStats) {
          var _newStats, at, mt, _at, _mt;

          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (_this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt("return");

                case 2:
                  if (!(!newStats || newStats.mtimeMs === 0)) {
                    _context2.next = 20;
                    break;
                  }

                  _context2.prev = 3;
                  _context2.next = 6;
                  return stat(file);

                case 6:
                  _newStats = _context2.sent;

                  if (!_this.fsw.closed) {
                    _context2.next = 9;
                    break;
                  }

                  return _context2.abrupt("return");

                case 9:
                  // Check that change event was not fired because of changed only accessTime.
                  at = _newStats.atimeMs;
                  mt = _newStats.mtimeMs;

                  if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                    _this.fsw._emit(EV_CHANGE, file, _newStats);
                  }

                  if (isLinux && prevStats.ino !== _newStats.ino) {
                    _this.fsw._closeFile(path);

                    prevStats = _newStats;

                    _this.fsw._addPathCloser(path, _this._watchWithNodeFs(file, listener));
                  } else {
                    prevStats = _newStats;
                  }

                  _context2.next = 18;
                  break;

                case 15:
                  _context2.prev = 15;
                  _context2.t0 = _context2["catch"](3);

                  // Fix issues where mtime is null but file is still present
                  _this.fsw._remove(dirname, basename);

                case 18:
                  _context2.next = 21;
                  break;

                case 20:
                  if (parent.has(basename)) {
                    // Check that change event was not fired because of changed only accessTime.
                    _at = newStats.atimeMs;
                    _mt = newStats.mtimeMs;

                    if (!_at || _at <= _mt || _mt !== prevStats.mtimeMs) {
                      _this.fsw._emit(EV_CHANGE, file, newStats);
                    }

                    prevStats = newStats;
                  }

                case 21:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[3, 15]]);
        }));

        return function listener(_x2, _x3) {
          return _ref2.apply(this, arguments);
        };
      }(); // kick off the watcher


      var closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to


      if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
        if (!this.fsw._throttle(EV_ADD, file, 0)) return;

        this.fsw._emit(EV_ADD, file, stats);
      }

      return closer;
    }
    /**
     * Handle symlinks encountered while reading a dir.
     * @param {Object} entry returned by readdirp
     * @param {String} directory path of dir being read
     * @param {String} path of this item
     * @param {String} item basename of this item
     * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
     */

  }, {
    key: "_handleSymlink",
    value: function () {
      var _handleSymlink2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(entry, directory, path, item) {
        var full, dir, linkPath;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.fsw.closed) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                full = entry.fullPath;
                dir = this.fsw._getWatchedDir(directory);

                if (this.fsw.options.followSymlinks) {
                  _context3.next = 14;
                  break;
                }

                // watch symlink directly (don't follow) and detect changes
                this.fsw._incrReadyCount();

                _context3.next = 8;
                return fsrealpath(path);

              case 8:
                linkPath = _context3.sent;

                if (!this.fsw.closed) {
                  _context3.next = 11;
                  break;
                }

                return _context3.abrupt("return");

              case 11:
                if (dir.has(item)) {
                  if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                    this.fsw._symlinkPaths.set(full, linkPath);

                    this.fsw._emit(EV_CHANGE, path, entry.stats);
                  }
                } else {
                  dir.add(item);

                  this.fsw._symlinkPaths.set(full, linkPath);

                  this.fsw._emit(EV_ADD, path, entry.stats);
                }

                this.fsw._emitReady();

                return _context3.abrupt("return", true);

              case 14:
                if (!this.fsw._symlinkPaths.has(full)) {
                  _context3.next = 16;
                  break;
                }

                return _context3.abrupt("return", true);

              case 16:
                this.fsw._symlinkPaths.set(full, true);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _handleSymlink(_x4, _x5, _x6, _x7) {
        return _handleSymlink2.apply(this, arguments);
      }

      return _handleSymlink;
    }()
  }, {
    key: "_handleRead",
    value: function _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
      var _this2 = this;

      // Normalize the directory name on Windows
      directory = sysPath.join(directory, EMPTY_STR);

      if (!wh.hasGlob) {
        throttler = this.fsw._throttle('readdir', directory, 1000);
        if (!throttler) return;
      }

      var previous = this.fsw._getWatchedDir(wh.path);

      var current = new Set();

      var stream = this.fsw._readdirp(directory, {
        fileFilter: function fileFilter(entry) {
          return wh.filterPath(entry);
        },
        directoryFilter: function directoryFilter(entry) {
          return wh.filterDir(entry);
        },
        depth: 0
      }).on(STR_DATA, /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(entry) {
          var item, path;
          return _regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (!_this2.fsw.closed) {
                    _context4.next = 3;
                    break;
                  }

                  stream = undefined;
                  return _context4.abrupt("return");

                case 3:
                  item = entry.path;
                  path = sysPath.join(directory, item);
                  current.add(item);
                  _context4.t0 = entry.stats.isSymbolicLink();

                  if (!_context4.t0) {
                    _context4.next = 11;
                    break;
                  }

                  _context4.next = 10;
                  return _this2._handleSymlink(entry, directory, path, item);

                case 10:
                  _context4.t0 = _context4.sent;

                case 11:
                  if (!_context4.t0) {
                    _context4.next = 13;
                    break;
                  }

                  return _context4.abrupt("return");

                case 13:
                  if (!_this2.fsw.closed) {
                    _context4.next = 16;
                    break;
                  }

                  stream = undefined;
                  return _context4.abrupt("return");

                case 16:
                  // Files that present in current directory snapshot
                  // but absent in previous are added to watch list and
                  // emit `add` event.
                  if (item === target || !target && !previous.has(item)) {
                    _this2.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse


                    path = sysPath.join(dir, sysPath.relative(dir, path));

                    _this2._addToNodeFs(path, initialAdd, wh, depth + 1);
                  }

                case 17:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x8) {
          return _ref3.apply(this, arguments);
        };
      }()).on(EV_ERROR, this._boundHandleError);

      return new Promise(function (resolve) {
        return stream.once(STR_END, function () {
          if (_this2.fsw.closed) {
            stream = undefined;
            return;
          }

          var wasThrottled = throttler ? throttler.clear() : false;
          resolve(); // Files that absent in current directory snapshot
          // but present in previous emit `remove` event
          // and are removed from @watched[directory].

          previous.getChildren().filter(function (item) {
            return item !== directory && !current.has(item) && ( // in case of intersecting globs;
            // a path may have been filtered out of this readdir, but
            // shouldn't be removed because it matches a different glob
            !wh.hasGlob || wh.filterPath({
              fullPath: sysPath.resolve(directory, item)
            }));
          }).forEach(function (item) {
            _this2.fsw._remove(directory, item);
          });
          stream = undefined; // one more time for any missed in case changes came in extremely quickly

          if (wasThrottled) _this2._handleRead(directory, false, wh, target, dir, depth, throttler);
        });
      });
    }
    /**
     * Read directory to add / remove files from `@watched` list and re-read it on change.
     * @param {String} dir fs path
     * @param {fs.Stats} stats
     * @param {Boolean} initialAdd
     * @param {Number} depth relative to user-supplied path
     * @param {String} target child path targeted for watch
     * @param {Object} wh Common watch helpers for this path
     * @param {String} realpath
     * @returns {Promise<Function>} closer for the watcher instance.
     */

  }, {
    key: "_handleDir",
    value: function () {
      var _handleDir2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(dir, stats, initialAdd, depth, target, wh, realpath) {
        var _this3 = this;

        var parentDir, tracked, throttler, closer, oDepth;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
                tracked = parentDir.has(sysPath.basename(dir));

                if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
                  if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
                } // ensure dir is tracked (harmless if redundant)


                parentDir.add(sysPath.basename(dir));

                this.fsw._getWatchedDir(dir);

                oDepth = this.fsw.options.depth;

                if (!((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath))) {
                  _context5.next = 13;
                  break;
                }

                if (target) {
                  _context5.next = 12;
                  break;
                }

                _context5.next = 10;
                return this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);

              case 10:
                if (!this.fsw.closed) {
                  _context5.next = 12;
                  break;
                }

                return _context5.abrupt("return");

              case 12:
                closer = this._watchWithNodeFs(dir, function (dirPath, stats) {
                  // if current directory is removed, do nothing
                  if (stats && stats.mtimeMs === 0) return;

                  _this3._handleRead(dirPath, false, wh, target, dir, depth, throttler);
                });

              case 13:
                return _context5.abrupt("return", closer);

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _handleDir(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
        return _handleDir2.apply(this, arguments);
      }

      return _handleDir;
    }()
    /**
     * Handle added file, directory, or glob pattern.
     * Delegates call to _handleFile / _handleDir after checks.
     * @param {String} path to file or ir
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @param {Object} priorWh depth relative to user-supplied path
     * @param {Number} depth Child path actually targeted for watch
     * @param {String=} target Child path actually targeted for watch
     * @returns {Promise}
     */

  }, {
    key: "_addToNodeFs",
    value: function () {
      var _addToNodeFs2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(path, initialAdd, priorWh, depth, target) {
        var ready, wh, stats, follow, closer, absPath, targetPath, _targetPath, parent;

        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                ready = this.fsw._emitReady;

                if (!(this.fsw._isIgnored(path) || this.fsw.closed)) {
                  _context6.next = 4;
                  break;
                }

                ready();
                return _context6.abrupt("return", false);

              case 4:
                wh = this.fsw._getWatchHelpers(path, depth);

                if (!wh.hasGlob && priorWh) {
                  wh.hasGlob = priorWh.hasGlob;
                  wh.globFilter = priorWh.globFilter;

                  wh.filterPath = function (entry) {
                    return priorWh.filterPath(entry);
                  };

                  wh.filterDir = function (entry) {
                    return priorWh.filterDir(entry);
                  };
                } // evaluate what is at the path we're being asked to watch


                _context6.prev = 6;
                _context6.next = 9;
                return statMethods[wh.statMethod](wh.watchPath);

              case 9:
                stats = _context6.sent;

                if (!this.fsw.closed) {
                  _context6.next = 12;
                  break;
                }

                return _context6.abrupt("return");

              case 12:
                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                  _context6.next = 15;
                  break;
                }

                ready();
                return _context6.abrupt("return", false);

              case 15:
                follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);

                if (!stats.isDirectory()) {
                  _context6.next = 36;
                  break;
                }

                absPath = sysPath.resolve(path);

                if (!follow) {
                  _context6.next = 24;
                  break;
                }

                _context6.next = 21;
                return fsrealpath(path);

              case 21:
                _context6.t0 = _context6.sent;
                _context6.next = 25;
                break;

              case 24:
                _context6.t0 = path;

              case 25:
                targetPath = _context6.t0;

                if (!this.fsw.closed) {
                  _context6.next = 28;
                  break;
                }

                return _context6.abrupt("return");

              case 28:
                _context6.next = 30;
                return this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);

              case 30:
                closer = _context6.sent;

                if (!this.fsw.closed) {
                  _context6.next = 33;
                  break;
                }

                return _context6.abrupt("return");

              case 33:
                // preserve this symlink's target path
                if (absPath !== targetPath && targetPath !== undefined) {
                  this.fsw._symlinkPaths.set(absPath, targetPath);
                }

                _context6.next = 59;
                break;

              case 36:
                if (!stats.isSymbolicLink()) {
                  _context6.next = 58;
                  break;
                }

                if (!follow) {
                  _context6.next = 43;
                  break;
                }

                _context6.next = 40;
                return fsrealpath(path);

              case 40:
                _context6.t1 = _context6.sent;
                _context6.next = 44;
                break;

              case 43:
                _context6.t1 = path;

              case 44:
                _targetPath = _context6.t1;

                if (!this.fsw.closed) {
                  _context6.next = 47;
                  break;
                }

                return _context6.abrupt("return");

              case 47:
                parent = sysPath.dirname(wh.watchPath);

                this.fsw._getWatchedDir(parent).add(wh.watchPath);

                this.fsw._emit(EV_ADD, wh.watchPath, stats);

                _context6.next = 52;
                return this._handleDir(parent, stats, initialAdd, depth, path, wh, _targetPath);

              case 52:
                closer = _context6.sent;

                if (!this.fsw.closed) {
                  _context6.next = 55;
                  break;
                }

                return _context6.abrupt("return");

              case 55:
                // preserve this symlink's target path
                if (_targetPath !== undefined) {
                  this.fsw._symlinkPaths.set(sysPath.resolve(path), _targetPath);
                }

                _context6.next = 59;
                break;

              case 58:
                closer = this._handleFile(wh.watchPath, stats, initialAdd);

              case 59:
                ready();

                this.fsw._addPathCloser(path, closer);

                return _context6.abrupt("return", false);

              case 64:
                _context6.prev = 64;
                _context6.t2 = _context6["catch"](6);

                if (!this.fsw._handleError(_context6.t2)) {
                  _context6.next = 69;
                  break;
                }

                ready();
                return _context6.abrupt("return", path);

              case 69:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[6, 64]]);
      }));

      function _addToNodeFs(_x16, _x17, _x18, _x19, _x20) {
        return _addToNodeFs2.apply(this, arguments);
      }

      return _addToNodeFs;
    }()
  }]);

  return NodeFsHandler;
}();

module.exports = NodeFsHandler;
        },
        map: {"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"fs":-19260817,"path":-19260817,"util":-19260817,"is-binary-path":419,"./constants":392}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/chokidar/lib/fsevents-handler.js
      391: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _typeof = require("@babel/runtime/helpers/typeof");

var _regeneratorRuntime = require("@babel/runtime/regenerator");

var _asyncToGenerator = require("@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("@babel/runtime/helpers/classCallCheck");

var _createClass = require("@babel/runtime/helpers/createClass");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var fs = require('fs');

var sysPath = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var fsevents;

try {
  fsevents = require('fsevents');
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  var mtch = process.version.match(/v(\d+)\.(\d+)/);

  if (mtch && mtch[1] && mtch[2]) {
    var maj = Number.parseInt(mtch[1], 10);
    var min = Number.parseInt(mtch[2], 10);

    if (maj === 8 && min < 16) {
      fsevents = undefined;
    }
  }
}

var _require2 = require('./constants'),
    EV_ADD = _require2.EV_ADD,
    EV_CHANGE = _require2.EV_CHANGE,
    EV_ADD_DIR = _require2.EV_ADD_DIR,
    EV_UNLINK = _require2.EV_UNLINK,
    EV_ERROR = _require2.EV_ERROR,
    STR_DATA = _require2.STR_DATA,
    STR_END = _require2.STR_END,
    FSEVENT_CREATED = _require2.FSEVENT_CREATED,
    FSEVENT_MODIFIED = _require2.FSEVENT_MODIFIED,
    FSEVENT_DELETED = _require2.FSEVENT_DELETED,
    FSEVENT_MOVED = _require2.FSEVENT_MOVED,
    FSEVENT_UNKNOWN = _require2.FSEVENT_UNKNOWN,
    FSEVENT_TYPE_FILE = _require2.FSEVENT_TYPE_FILE,
    FSEVENT_TYPE_DIRECTORY = _require2.FSEVENT_TYPE_DIRECTORY,
    FSEVENT_TYPE_SYMLINK = _require2.FSEVENT_TYPE_SYMLINK,
    ROOT_GLOBSTAR = _require2.ROOT_GLOBSTAR,
    DIR_SUFFIX = _require2.DIR_SUFFIX,
    DOT_SLASH = _require2.DOT_SLASH,
    FUNCTION_TYPE = _require2.FUNCTION_TYPE,
    EMPTY_FN = _require2.EMPTY_FN,
    IDENTITY_FN = _require2.IDENTITY_FN;

var Depth = function Depth(value) {
  return isNaN(value) ? {} : {
    depth: value
  };
};

var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var realpath = promisify(fs.realpath);
var statMethods = {
  stat: stat,
  lstat: lstat
};
/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */
// fsevents instance helper functions

/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */

var FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start
// consolidating going forward

var consolidateThreshhold = 10;
var wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);
/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */

var createFSEventsInstance = function createFSEventsInstance(path, callback) {
  var stop = fsevents.watch(path, callback);
  return {
    stop: stop
  };
};
/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */


function setFSEventsListener(path, realPath, listener, rawEmitter) {
  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
  var parentPath = sysPath.dirname(watchPath);
  var cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.

  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  var resolvedPath = sysPath.resolve(path);
  var hasSymlink = resolvedPath !== realPath;

  var filteredListener = function filteredListener(fullPath, flags, info) {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);
  }; // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match


  var watchedParent = false;

  var _iterator = _createForOfIteratorHelper(FSEventsWatchers.keys()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var watchedPath = _step.value;

      if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
        watchPath = watchedPath;
        cont = FSEventsWatchers.get(watchPath);
        watchedParent = true;
        break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter: rawEmitter,
      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
        if (!cont.listeners.size) return;
        var info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(function (list) {
          list(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  } // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left


  return function () {
    var lst = cont.listeners;
    lst["delete"](filteredListener);

    if (!lst.size) {
      FSEventsWatchers["delete"](watchPath);
      if (cont.watcher) return cont.watcher.stop().then(function () {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
} // Decide whether or not we should start a new higher-level
// parent watcher


var couldConsolidate = function couldConsolidate(path) {
  var count = 0;

  var _iterator2 = _createForOfIteratorHelper(FSEventsWatchers.keys()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var watchPath = _step2.value;

      if (watchPath.indexOf(path) === 0) {
        count++;

        if (count >= consolidateThreshhold) {
          return true;
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return false;
}; // returns boolean indicating whether fsevents can be used


var canUse = function canUse() {
  return fsevents && FSEventsWatchers.size < 128;
}; // determines subdirectory traversal levels from root to path


var calcDepth = function calcDepth(path, root) {
  var i = 0;

  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) {
    i++;
  }

  return i;
}; // returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat


var sameTypes = function sameTypes(info, stats) {
  return info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
};
/**
 * @mixin
 */


var FsEventsHandler = /*#__PURE__*/function () {
  /**
   * @param {import('../index').FSWatcher} fsw
   */
  function FsEventsHandler(fsw) {
    _classCallCheck(this, FsEventsHandler);

    this.fsw = fsw;
  }

  _createClass(FsEventsHandler, [{
    key: "checkIgnored",
    value: function checkIgnored(path, stats) {
      var ipaths = this.fsw._ignoredPaths;

      if (this.fsw._isIgnored(path, stats)) {
        ipaths.add(path);

        if (stats && stats.isDirectory()) {
          ipaths.add(path + ROOT_GLOBSTAR);
        }

        return true;
      }

      ipaths["delete"](path);
      ipaths["delete"](path + ROOT_GLOBSTAR);
    }
  }, {
    key: "addOrChange",
    value: function addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      var event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
      this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }, {
    key: "checkExists",
    value: function () {
      var _checkExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        var stats;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return stat(path);

              case 3:
                stats = _context.sent;

                if (!this.fsw.closed) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return");

              case 6:
                if (sameTypes(info, stats)) {
                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }

                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);

                if (_context.t0.code === 'EACCES') {
                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 9]]);
      }));

      function checkExists(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {
        return _checkExists.apply(this, arguments);
      }

      return checkExists;
    }()
  }, {
    key: "handleEvent",
    value: function handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      if (this.fsw.closed || this.checkIgnored(path)) return;

      if (event === EV_UNLINK) {
        var isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files

        if (isDirectory || watchedDir.has(item)) {
          this.fsw._remove(parent, item, isDirectory);
        }
      } else {
        if (event === EV_ADD) {
          // track new directories
          if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
            // push symlinks back to the top of the stack to get handled
            var curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;
            return this._addToFsEvents(path, false, true, curDepth);
          } // track new paths
          // (other than symlinks being followed, which will be tracked soon)


          this.fsw._getWatchedDir(parent).add(item);
        }
        /**
         * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
         */


        var eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;

        this.fsw._emit(eventName, path);

        if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
      }
    }
    /**
     * Handle symlinks encountered during directory scan
     * @param {String} watchPath  - file/dir path to be watched with fsevents
     * @param {String} realPath   - real path (in case of symlinks)
     * @param {Function} transform  - path transformer
     * @param {Function} globFilter - path filter in case a glob pattern was provided
     * @returns {Function} closer for the watcher instance
    */

  }, {
    key: "_watchWithFsEvents",
    value: function _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
      var _this = this;

      if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
      var opts = this.fsw.options;

      var watchCallback = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fullPath, flags, info) {
          var path, parent, item, watchedDir, stats;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!_this.fsw.closed) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt("return");

                case 2:
                  if (!(opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)) {
                    _context2.next = 4;
                    break;
                  }

                  return _context2.abrupt("return");

                case 4:
                  path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));

                  if (!(globFilter && !globFilter(path))) {
                    _context2.next = 7;
                    break;
                  }

                  return _context2.abrupt("return");

                case 7:
                  // ensure directories are tracked
                  parent = sysPath.dirname(path);
                  item = sysPath.basename(path);
                  watchedDir = _this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted

                  if (!(wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN)) {
                    _context2.next = 30;
                    break;
                  }

                  if (!(_typeof(opts.ignored) === FUNCTION_TYPE)) {
                    _context2.next = 27;
                    break;
                  }

                  _context2.prev = 12;
                  _context2.next = 15;
                  return stat(path);

                case 15:
                  stats = _context2.sent;
                  _context2.next = 20;
                  break;

                case 18:
                  _context2.prev = 18;
                  _context2.t0 = _context2["catch"](12);

                case 20:
                  if (!_this.fsw.closed) {
                    _context2.next = 22;
                    break;
                  }

                  return _context2.abrupt("return");

                case 22:
                  if (!_this.checkIgnored(path, stats)) {
                    _context2.next = 24;
                    break;
                  }

                  return _context2.abrupt("return");

                case 24:
                  if (sameTypes(info, stats)) {
                    _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                  } else {
                    _this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                  }

                  _context2.next = 28;
                  break;

                case 27:
                  _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);

                case 28:
                  _context2.next = 35;
                  break;

                case 30:
                  _context2.t1 = info.event;
                  _context2.next = _context2.t1 === FSEVENT_CREATED ? 33 : _context2.t1 === FSEVENT_MODIFIED ? 33 : _context2.t1 === FSEVENT_DELETED ? 34 : _context2.t1 === FSEVENT_MOVED ? 34 : 35;
                  break;

                case 33:
                  return _context2.abrupt("return", _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts));

                case 34:
                  return _context2.abrupt("return", _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts));

                case 35:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[12, 18]]);
        }));

        return function watchCallback(_x9, _x10, _x11) {
          return _ref.apply(this, arguments);
        };
      }();

      var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);

      this.fsw._emitReady();

      return closer;
    }
    /**
     * Handle symlinks encountered during directory scan
     * @param {String} linkPath path to symlink
     * @param {String} fullPath absolute path to the symlink
     * @param {Function} transform pre-existing path transformer
     * @param {Number} curDepth level of subdirectories traversed to where symlink is
     * @returns {Promise<void>}
     */

  }, {
    key: "_handleFsEventsSymlink",
    value: function () {
      var _handleFsEventsSymlink2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(linkPath, fullPath, transform, curDepth) {
        var linkTarget;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                this.fsw._symlinkPaths.set(fullPath, true);

                this.fsw._incrReadyCount();

                _context3.prev = 4;
                _context3.next = 7;
                return realpath(linkPath);

              case 7:
                linkTarget = _context3.sent;

                if (!this.fsw.closed) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return");

              case 10:
                if (!this.fsw._isIgnored(linkTarget)) {
                  _context3.next = 12;
                  break;
                }

                return _context3.abrupt("return", this.fsw._emitReady());

              case 12:
                this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform
                // that causes emitted paths to incorporate the link's path


                this._addToFsEvents(linkTarget || linkPath, function (path) {
                  var aliasedPath = linkPath;

                  if (linkTarget && linkTarget !== DOT_SLASH) {
                    aliasedPath = path.replace(linkTarget, linkPath);
                  } else if (path !== DOT_SLASH) {
                    aliasedPath = sysPath.join(linkPath, path);
                  }

                  return transform(aliasedPath);
                }, false, curDepth);

                _context3.next = 20;
                break;

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3["catch"](4);

                if (!this.fsw._handleError(_context3.t0)) {
                  _context3.next = 20;
                  break;
                }

                return _context3.abrupt("return", this.fsw._emitReady());

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[4, 16]]);
      }));

      function _handleFsEventsSymlink(_x12, _x13, _x14, _x15) {
        return _handleFsEventsSymlink2.apply(this, arguments);
      }

      return _handleFsEventsSymlink;
    }()
    /**
     *
     * @param {Path} newPath
     * @param {fs.Stats} stats
     */

  }, {
    key: "emitAdd",
    value: function emitAdd(newPath, stats, processPath, opts, forceAdd) {
      var pp = processPath(newPath);
      var isDir = stats.isDirectory();

      var dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));

      var base = sysPath.basename(pp); // ensure empty dirs get tracked

      if (isDir) this.fsw._getWatchedDir(pp);
      if (dirObj.has(base)) return;
      dirObj.add(base);

      if (!opts.ignoreInitial || forceAdd === true) {
        this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
      }
    }
  }, {
    key: "initWatch",
    value: function initWatch(realPath, path, wh, processPath) {
      if (this.fsw.closed) return;

      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);

      this.fsw._addPathCloser(path, closer);
    }
    /**
     * Handle added path with fsevents
     * @param {String} path file/dir path or glob pattern
     * @param {Function|Boolean=} transform converts working path to what the user expects
     * @param {Boolean=} forceAdd ensure add is emitted
     * @param {Number=} priorDepth Level of subdirectories already traversed.
     * @returns {Promise<void>}
     */

  }, {
    key: "_addToFsEvents",
    value: function () {
      var _addToFsEvents2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path, transform, forceAdd, priorDepth) {
        var _this2 = this;

        var opts, processPath, wh, stats, realPath;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.fsw.closed) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return");

              case 2:
                opts = this.fsw.options;
                processPath = _typeof(transform) === FUNCTION_TYPE ? transform : IDENTITY_FN;
                wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch

                _context4.prev = 5;
                _context4.next = 8;
                return statMethods[wh.statMethod](wh.watchPath);

              case 8:
                stats = _context4.sent;

                if (!this.fsw.closed) {
                  _context4.next = 11;
                  break;
                }

                return _context4.abrupt("return");

              case 11:
                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                  _context4.next = 13;
                  break;
                }

                throw null;

              case 13:
                if (!stats.isDirectory()) {
                  _context4.next = 20;
                  break;
                }

                // emit addDir unless this is a glob parent
                if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting

                if (!(priorDepth && priorDepth > opts.depth)) {
                  _context4.next = 17;
                  break;
                }

                return _context4.abrupt("return");

              case 17:
                // scan the contents of the dir
                this.fsw._readdirp(wh.watchPath, _objectSpread({
                  fileFilter: function fileFilter(entry) {
                    return wh.filterPath(entry);
                  },
                  directoryFilter: function directoryFilter(entry) {
                    return wh.filterDir(entry);
                  }
                }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, function (entry) {
                  // need to check filterPath on dirs b/c filterDir is less restrictive
                  if (_this2.fsw.closed) {
                    return;
                  }

                  if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
                  var joinedPath = sysPath.join(wh.watchPath, entry.path);
                  var fullPath = entry.fullPath;

                  if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                    // preserve the current depth here since it can't be derived from
                    // real paths past the symlink
                    var curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

                    _this2._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                  } else {
                    _this2.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                  }
                }).on(EV_ERROR, EMPTY_FN).on(STR_END, function () {
                  _this2.fsw._emitReady();
                });

                _context4.next = 22;
                break;

              case 20:
                this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);

                this.fsw._emitReady();

              case 22:
                _context4.next = 27;
                break;

              case 24:
                _context4.prev = 24;
                _context4.t0 = _context4["catch"](5);

                if (!_context4.t0 || this.fsw._handleError(_context4.t0)) {
                  // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
                  this.fsw._emitReady();

                  this.fsw._emitReady();
                }

              case 27:
                if (!(opts.persistent && forceAdd !== true)) {
                  _context4.next = 41;
                  break;
                }

                if (!(_typeof(transform) === FUNCTION_TYPE)) {
                  _context4.next = 32;
                  break;
                }

                // realpath has already been resolved
                this.initWatch(undefined, path, wh, processPath);
                _context4.next = 41;
                break;

              case 32:
                _context4.prev = 32;
                _context4.next = 35;
                return realpath(wh.watchPath);

              case 35:
                realPath = _context4.sent;
                _context4.next = 40;
                break;

              case 38:
                _context4.prev = 38;
                _context4.t1 = _context4["catch"](32);

              case 40:
                this.initWatch(realPath, path, wh, processPath);

              case 41:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[5, 24], [32, 38]]);
      }));

      function _addToFsEvents(_x16, _x17, _x18, _x19) {
        return _addToFsEvents2.apply(this, arguments);
      }

      return _addToFsEvents;
    }()
  }]);

  return FsEventsHandler;
}();

module.exports = FsEventsHandler;
module.exports.canUse = canUse;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/typeof":12,"@babel/runtime/regenerator":2,"@babel/runtime/helpers/asyncToGenerator":3,"@babel/runtime/helpers/classCallCheck":14,"@babel/runtime/helpers/createClass":15,"fs":-19260817,"path":-19260817,"util":-19260817,"fsevents":420,"./constants":392}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/chokidar/lib/constants.js
      392: {
        factory: (module, exports, require) => {
          'use strict';

var _require = require('path'),
    sep = _require.sep;

var _process = process,
    platform = _process.platform;
exports.EV_ALL = 'all';
exports.EV_READY = 'ready';
exports.EV_ADD = 'add';
exports.EV_CHANGE = 'change';
exports.EV_ADD_DIR = 'addDir';
exports.EV_UNLINK = 'unlink';
exports.EV_UNLINK_DIR = 'unlinkDir';
exports.EV_RAW = 'raw';
exports.EV_ERROR = 'error';
exports.STR_DATA = 'data';
exports.STR_END = 'end';
exports.STR_CLOSE = 'close';
exports.FSEVENT_CREATED = 'created';
exports.FSEVENT_MODIFIED = 'modified';
exports.FSEVENT_DELETED = 'deleted';
exports.FSEVENT_MOVED = 'moved';
exports.FSEVENT_CLONED = 'cloned';
exports.FSEVENT_UNKNOWN = 'unknown';
exports.FSEVENT_TYPE_FILE = 'file';
exports.FSEVENT_TYPE_DIRECTORY = 'directory';
exports.FSEVENT_TYPE_SYMLINK = 'symlink';
exports.KEY_LISTENERS = 'listeners';
exports.KEY_ERR = 'errHandlers';
exports.KEY_RAW = 'rawEmitters';
exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
exports.DOT_SLASH = ".".concat(sep);
exports.BACK_SLASH_RE = /\\/g;
exports.DOUBLE_SLASH_RE = /\/\//;
exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
exports.REPLACER_RE = /^\.[/\\]/;
exports.SLASH = '/';
exports.SLASH_SLASH = '//';
exports.BRACE_START = '{';
exports.BANG = '!';
exports.ONE_DOT = '.';
exports.TWO_DOTS = '..';
exports.STAR = '*';
exports.GLOBSTAR = '**';
exports.ROOT_GLOBSTAR = '/**/*';
exports.SLASH_GLOBSTAR = '/**';
exports.DIR_SUFFIX = 'Dir';
exports.ANYMATCH_OPTS = {
  dot: true
};
exports.STRING_TYPE = 'string';
exports.FUNCTION_TYPE = 'function';
exports.EMPTY_STR = '';

exports.EMPTY_FN = function () {};

exports.IDENTITY_FN = function (val) {
  return val;
};

exports.isWindows = platform === 'win32';
exports.isMacos = platform === 'darwin';
exports.isLinux = platform === 'linux';
        },
        map: {"path":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/has-tostringtag/shams.js
      393: {
        factory: (module, exports, require) => {
          'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
  return hasSymbols() && !!Symbol.toStringTag;
};
        },
        map: {"has-symbols/shams":375}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/5/abs.js
      394: {
        factory: (module, exports, require) => {
          'use strict';

var GetIntrinsic = require('get-intrinsic');

var $abs = GetIntrinsic('%Math.abs%'); // http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
  return $abs(x);
};
        },
        map: {"get-intrinsic":266}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/5/floor.js
      395: {
        factory: (module, exports, require) => {
          'use strict'; // var modulo = require('./modulo');

var $floor = Math.floor; // http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
  // return x - modulo(x, 1);
  return $floor(x);
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/5/ToNumber.js
      396: {
        factory: (module, exports, require) => {
          'use strict';

var ToPrimitive = require('./ToPrimitive'); // http://262.ecma-international.org/5.1/#sec-9.3


module.exports = function ToNumber(value) {
  var prim = ToPrimitive(value, Number);

  if (typeof prim !== 'string') {
    return +prim; // eslint-disable-line no-implicit-coercion
  } // eslint-disable-next-line no-control-regex


  var trimmed = prim.replace(/^[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+|[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+$/g, '');

  if (/^0[ob]|^[+-]0x/.test(trimmed)) {
    return NaN;
  }

  return +trimmed; // eslint-disable-line no-implicit-coercion
};
        },
        map: {"./ToPrimitive":421}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/helpers/isNaN.js
      397: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = Number.isNaN || function isNaN(a) {
  return a !== a;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/helpers/isFinite.js
      398: {
        factory: (module, exports, require) => {
          'use strict';

var $isNaN = Number.isNaN || function (a) {
  return a !== a;
};

module.exports = Number.isFinite || function (x) {
  return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/helpers/sign.js
      399: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function sign(number) {
  return number >= 0 ? 1 : -1;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/helpers/regexTester.js
      400: {
        factory: (module, exports, require) => {
          'use strict';

var GetIntrinsic = require('get-intrinsic');

var $test = GetIntrinsic('RegExp.prototype.test');

var callBind = require('call-bind');

module.exports = function regexTester(regex) {
  return callBind($test, regex);
};
        },
        map: {"get-intrinsic":266,"call-bind":296}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/helpers/isPrimitive.js
      401: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

module.exports = function isPrimitive(value) {
  return value === null || typeof value !== 'function' && _typeof(value) !== 'object';
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/2019/ToPrimitive.js
      402: {
        factory: (module, exports, require) => {
          'use strict';

var toPrimitive = require('es-to-primitive/es2015'); // https://ecma-international.org/ecma-262/6.0/#sec-toprimitive


module.exports = function ToPrimitive(input) {
  if (arguments.length > 1) {
    return toPrimitive(input, arguments[1]);
  }

  return toPrimitive(input);
};
        },
        map: {"es-to-primitive/es2015":422}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_Hash.js
      403: {
        factory: (module, exports, require) => {
          var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;
        },
        map: {"./_hashClear":423,"./_hashDelete":424,"./_hashGet":425,"./_hashHas":426,"./_hashSet":427}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_getMapData.js
      404: {
        factory: (module, exports, require) => {
          var isKeyable = require('./_isKeyable');
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;
        },
        map: {"./_isKeyable":428}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_isMasked.js
      405: {
        factory: (module, exports, require) => {
          var coreJsData = require('./_coreJsData');
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;
        },
        map: {"./_coreJsData":429}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_equalArrays.js
      406: {
        factory: (module, exports, require) => {
          var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;
        },
        map: {"./_SetCache":430,"./_arraySome":431,"./_cacheHas":432}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_equalByTag.js
      407: {
        factory: (module, exports, require) => {
          var _Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;
        },
        map: {"./_Symbol":316,"./_Uint8Array":319,"./eq":230,"./_equalArrays":406,"./_mapToArray":433,"./_setToArray":434}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_equalObjects.js
      408: {
        factory: (module, exports, require) => {
          var getAllKeys = require('./_getAllKeys');
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;
        },
        map: {"./_getAllKeys":151}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/isexe/windows.js
      409: {
        factory: (module, exports, require) => {
          module.exports = isexe;
isexe.sync = sync;

var fs = require('fs');

function checkPathExt(path, options) {
  var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;

  if (!pathext) {
    return true;
  }

  pathext = pathext.split(';');

  if (pathext.indexOf('') !== -1) {
    return true;
  }

  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase();

    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true;
    }
  }

  return false;
}

function checkStat(stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false;
  }

  return checkPathExt(path, options);
}

function isexe(path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options));
  });
}

function sync(path, options) {
  return checkStat(fs.statSync(path), path, options);
}
        },
        map: {"fs":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/isexe/mode.js
      410: {
        factory: (module, exports, require) => {
          module.exports = isexe;
isexe.sync = sync;

var fs = require('fs');

function isexe(path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options));
  });
}

function sync(path, options) {
  return checkStat(fs.statSync(path), options);
}

function checkStat(stat, options) {
  return stat.isFile() && checkMode(stat, options);
}

function checkMode(stat, options) {
  var mod = stat.mode;
  var uid = stat.uid;
  var gid = stat.gid;
  var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
  var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
  var u = parseInt('100', 8);
  var g = parseInt('010', 8);
  var o = parseInt('001', 8);
  var ug = u | g;
  var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
  return ret;
}
        },
        map: {"fs":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/ansi-regex/index.js
      411: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$onlyFirst = _ref.onlyFirst,
      onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

  var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
  return new RegExp(pattern, onlyFirst ? undefined : 'g');
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/ansi-styles/index.js
      412: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var wrapAnsi16 = function wrapAnsi16(fn, offset) {
  return function () {
    var code = fn.apply(void 0, arguments);
    return "\x1B[".concat(code + offset, "m");
  };
};

var wrapAnsi256 = function wrapAnsi256(fn, offset) {
  return function () {
    var code = fn.apply(void 0, arguments);
    return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
  };
};

var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
  return function () {
    var rgb = fn.apply(void 0, arguments);
    return "\x1B[".concat(38 + offset, ";2;").concat(rgb[0], ";").concat(rgb[1], ";").concat(rgb[2], "m");
  };
};

var ansi2ansi = function ansi2ansi(n) {
  return n;
};

var rgb2rgb = function rgb2rgb(r, g, b) {
  return [r, g, b];
};

var setLazyProperty = function setLazyProperty(object, property, _get) {
  Object.defineProperty(object, property, {
    get: function get() {
      var value = _get();

      Object.defineProperty(object, property, {
        value: value,
        enumerable: true,
        configurable: true
      });
      return value;
    },
    enumerable: true,
    configurable: true
  });
};
/** @type {typeof import('color-convert')} */


var colorConvert;

var makeDynamicStyles = function makeDynamicStyles(wrap, targetSpace, identity, isBackground) {
  if (colorConvert === undefined) {
    colorConvert = require('color-convert');
  }

  var offset = isBackground ? 10 : 0;
  var styles = {};

  for (var _i = 0, _Object$entries = Object.entries(colorConvert); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        sourceSpace = _Object$entries$_i[0],
        suite = _Object$entries$_i[1];

    var name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;

    if (sourceSpace === targetSpace) {
      styles[name] = wrap(identity, offset);
    } else if (_typeof(suite) === 'object') {
      styles[name] = wrap(suite[targetSpace], offset);
    }
  }

  return styles;
};

function assembleStyles() {
  var codes = new Map();
  var styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  }; // Alias bright black as gray (and grey)

  styles.color.gray = styles.color.blackBright;
  styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
  styles.color.grey = styles.color.blackBright;
  styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

  for (var _i2 = 0, _Object$entries2 = Object.entries(styles); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        groupName = _Object$entries2$_i[0],
        group = _Object$entries2$_i[1];

    for (var _i3 = 0, _Object$entries3 = Object.entries(group); _i3 < _Object$entries3.length; _i3++) {
      var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
          styleName = _Object$entries3$_i[0],
          style = _Object$entries3$_i[1];

      styles[styleName] = {
        open: "\x1B[".concat(style[0], "m"),
        close: "\x1B[".concat(style[1], "m")
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }

    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }

  Object.defineProperty(styles, 'codes', {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  setLazyProperty(styles.color, 'ansi', function () {
    return makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false);
  });
  setLazyProperty(styles.color, 'ansi256', function () {
    return makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false);
  });
  setLazyProperty(styles.color, 'ansi16m', function () {
    return makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false);
  });
  setLazyProperty(styles.bgColor, 'ansi', function () {
    return makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true);
  });
  setLazyProperty(styles.bgColor, 'ansi256', function () {
    return makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true);
  });
  setLazyProperty(styles.bgColor, 'ansi16m', function () {
    return makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true);
  });
  return styles;
} // Make the export immutable


Object.defineProperty(module, 'exports', {
  enumerable: true,
  get: assembleStyles
});
        },
        map: {"@babel/runtime/helpers/typeof":12,"@babel/runtime/helpers/slicedToArray":120,"color-convert":435}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/picomatch/index.js
      413: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = require('./lib/picomatch');
        },
        map: {"./lib/picomatch":436}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-extglob/index.js
      414: {
        factory: (module, exports, require) => {
          /*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;

  while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/braces/lib/stringify.js
      415: {
        factory: (module, exports, require) => {
          'use strict';

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var utils = require('./utils');

module.exports = function (ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var stringify = function stringify(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    var invalidNode = node.invalid === true && options.escapeInvalid === true;
    var output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }

      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      var _iterator = _createForOfIteratorHelper(node.nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          output += stringify(child);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return output;
  };

  return stringify(ast);
};
        },
        map: {"./utils":437}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/braces/lib/compile.js
      416: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var fill = require('fill-range');

var utils = require('./utils');

var compile = function compile(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var walk = function walk(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var invalidBlock = utils.isInvalidBrace(parent);
    var invalidNode = node.invalid === true && options.escapeInvalid === true;
    var invalid = invalidBlock === true || invalidNode === true;
    var prefix = options.escapeInvalid === true ? '\\' : '';
    var output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }

    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? prefix + node.value : '(';
    }

    if (node.type === 'close') {
      return invalid ? prefix + node.value : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      var args = utils.reduce(node.nodes);
      var range = fill.apply(void 0, _toConsumableArray(args).concat([_objectSpread(_objectSpread({}, options), {}, {
        wrap: false,
        toRegex: true
      })]));

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? "(".concat(range, ")") : range;
      }
    }

    if (node.nodes) {
      var _iterator = _createForOfIteratorHelper(node.nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          output += walk(child, node);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return output;
  };

  return walk(ast);
};

module.exports = compile;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/toConsumableArray":35,"fill-range":438,"./utils":437}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/braces/lib/expand.js
      417: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var fill = require('fill-range');

var stringify = require('./stringify');

var utils = require('./utils');

var append = function append() {
  var queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var result = [];
  queue = [].concat(queue);
  stash = [].concat(stash);
  if (!stash.length) return queue;

  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(function (ele) {
      return "{".concat(ele, "}");
    }) : stash;
  }

  var _iterator = _createForOfIteratorHelper(queue),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;

      if (Array.isArray(item)) {
        var _iterator2 = _createForOfIteratorHelper(item),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var value = _step2.value;
            result.push(append(value, stash, enclose));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        var _iterator3 = _createForOfIteratorHelper(stash),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var ele = _step3.value;
            if (enclose === true && typeof ele === 'string') ele = "{".concat(ele, "}");
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return utils.flatten(result);
};

var expand = function expand(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  var walk = function walk(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    node.queue = [];
    var p = parent;
    var q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      var args = utils.reduce(node.nodes);

      if (utils.exceedsLimit.apply(utils, _toConsumableArray(args).concat([options.step, rangeLimit]))) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      var range = fill.apply(void 0, _toConsumableArray(args).concat([options]));

      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    var enclose = utils.encloseBrace(node);
    var queue = node.queue;
    var block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (var i = 0; i < node.nodes.length; i++) {
      var child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"fill-range":438,"./stringify":415,"./utils":437}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/braces/lib/parse.js
      418: {
        factory: (module, exports, require) => {
          'use strict';

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var stringify = require('./stringify');
/**
 * Constants
 */


var _require = require('./constants'),
    MAX_LENGTH = _require.MAX_LENGTH,
    CHAR_BACKSLASH = _require.CHAR_BACKSLASH,
    CHAR_BACKTICK = _require.CHAR_BACKTICK,
    CHAR_COMMA = _require.CHAR_COMMA,
    CHAR_DOT = _require.CHAR_DOT,
    CHAR_LEFT_PARENTHESES = _require.CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES = _require.CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE = _require.CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE = _require.CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET = _require.CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET = _require.CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE = _require.CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE = _require.CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE = _require.CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE = _require.CHAR_ZERO_WIDTH_NOBREAK_SPACE;
/**
 * parse
 */


var parse = function parse(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  var opts = options || {};
  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  if (input.length > max) {
    throw new SyntaxError("Input length (".concat(input.length, "), exceeds max characters (").concat(max, ")"));
  }

  var ast = {
    type: 'root',
    input: input,
    nodes: []
  };
  var stack = [ast];
  var block = ast;
  var prev = ast;
  var brackets = 0;
  var length = input.length;
  var index = 0;
  var depth = 0;
  var value;
  var memo = {};
  /**
   * Helpers
   */

  var advance = function advance() {
    return input[index++];
  };

  var push = function push(node) {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({
    type: 'bos'
  });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();
    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }
    /**
     * Escaped chars
     */


    if (value === CHAR_BACKSLASH) {
      push({
        type: 'text',
        value: (options.keepEscaping ? value : '') + advance()
      });
      continue;
    }
    /**
     * Right square bracket (literal): ']'
     */


    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({
        type: 'text',
        value: '\\' + value
      });
      continue;
    }
    /**
     * Left square bracket: '['
     */


    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;
      var closed = true;
      var next = void 0;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({
        type: 'text',
        value: value
      });
      continue;
    }
    /**
     * Parentheses
     */


    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({
        type: 'paren',
        nodes: []
      });
      stack.push(block);
      push({
        type: 'text',
        value: value
      });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({
          type: 'text',
          value: value
        });
        continue;
      }

      block = stack.pop();
      push({
        type: 'text',
        value: value
      });
      block = stack[stack.length - 1];
      continue;
    }
    /**
     * Quotes: '|"|`
     */


    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      var open = value;

      var _next = void 0;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (_next = advance())) {
        if (_next === CHAR_BACKSLASH) {
          value += _next + advance();
          continue;
        }

        if (_next === open) {
          if (options.keepQuotes === true) value += _next;
          break;
        }

        value += _next;
      }

      push({
        type: 'text',
        value: value
      });
      continue;
    }
    /**
     * Left curly brace: '{'
     */


    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;
      var dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      var brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar: dollar,
        depth: depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };
      block = push(brace);
      stack.push(block);
      push({
        type: 'open',
        value: value
      });
      continue;
    }
    /**
     * Right curly brace: '}'
     */


    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({
          type: 'text',
          value: value
        });
        continue;
      }

      var type = 'close';
      block = stack.pop();
      block.close = true;
      push({
        type: type,
        value: value
      });
      depth--;
      block = stack[stack.length - 1];
      continue;
    }
    /**
     * Comma: ','
     */


    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;

        var _open = block.nodes.shift();

        block.nodes = [_open, {
          type: 'text',
          value: stringify(block)
        }];
      }

      push({
        type: 'comma',
        value: value
      });
      block.commas++;
      continue;
    }
    /**
     * Dot: '.'
     */


    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      var siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({
          type: 'text',
          value: value
        });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();
        var before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({
        type: 'dot',
        value: value
      });
      continue;
    }
    /**
     * Text
     */


    push({
      type: 'text',
      value: value
    });
  } // Mark imbalanced braces and brackets as invalid


  do {
    block = stack.pop();

    if (block.type !== 'root') {
      var _parent$nodes;

      block.nodes.forEach(function (node) {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      }); // get the location of the block on parent.nodes (block's siblings)

      var parent = stack[stack.length - 1];

      var _index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes


      (_parent$nodes = parent.nodes).splice.apply(_parent$nodes, [_index, 1].concat(_toConsumableArray(block.nodes)));
    }
  } while (stack.length > 0);

  push({
    type: 'eos'
  });
  return ast;
};

module.exports = parse;
        },
        map: {"@babel/runtime/helpers/toConsumableArray":35,"./stringify":415,"./constants":439}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-binary-path/index.js
      419: {
        factory: (module, exports, require) => {
          'use strict';

var path = require('path');

var binaryExtensions = require('binary-extensions');

var extensions = new Set(binaryExtensions);

module.exports = function (filePath) {
  return extensions.has(path.extname(filePath).slice(1).toLowerCase());
};
        },
        map: {"path":-19260817,"binary-extensions":440}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/fsevents/fsevents.js
      420: {
        factory: (module, exports, require) => {
          /*
 ** © 2020 by Philipp Dunkel, Ben Noordhuis, Elan Shankar, Paul Miller
 ** Licensed under MIT License.
 */

/* jshint node:true */
"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

if (process.platform !== "darwin") {
  throw new Error("Module 'fsevents' is not compatible with platform '".concat(process.platform, "'"));
}

var Native = require("./fsevents.node");

var events = Native.constants;

function watch(path, since, handler) {
  if (typeof path !== "string") {
    throw new TypeError("fsevents argument 1 must be a string and not a ".concat(_typeof(path)));
  }

  if ("function" === typeof since && "undefined" === typeof handler) {
    handler = since;
    since = Native.flags.SinceNow;
  }

  if (typeof since !== "number") {
    throw new TypeError("fsevents argument 2 must be a number and not a ".concat(_typeof(since)));
  }

  if (typeof handler !== "function") {
    throw new TypeError("fsevents argument 3 must be a function and not a ".concat(_typeof(handler)));
  }

  var instance = Native.start(Native.global, path, since, handler);
  if (!instance) throw new Error("could not watch: ".concat(path));
  return function () {
    var result = instance ? Promise.resolve(instance).then(Native.stop) : Promise.resolve(undefined);
    instance = undefined;
    return result;
  };
}

function getInfo(path, flags) {
  return {
    path: path,
    flags: flags,
    event: getEventType(flags),
    type: getFileType(flags),
    changes: getFileChanges(flags)
  };
}

function getFileType(flags) {
  if (events.ItemIsFile & flags) return "file";
  if (events.ItemIsDir & flags) return "directory";
  if (events.ItemIsSymlink & flags) return "symlink";
}

function anyIsTrue(obj) {
  for (var key in obj) {
    if (obj[key]) return true;
  }

  return false;
}

function getEventType(flags) {
  if (events.ItemRemoved & flags) return "deleted";
  if (events.ItemRenamed & flags) return "moved";
  if (events.ItemCreated & flags) return "created";
  if (events.ItemModified & flags) return "modified";
  if (events.RootChanged & flags) return "root-changed";
  if (events.ItemCloned & flags) return "cloned";
  if (anyIsTrue(flags)) return "modified";
  return "unknown";
}

function getFileChanges(flags) {
  return {
    inode: !!(events.ItemInodeMetaMod & flags),
    finder: !!(events.ItemFinderInfoMod & flags),
    access: !!(events.ItemChangeOwner & flags),
    xattrs: !!(events.ItemXattrMod & flags)
  };
}

exports.watch = watch;
exports.getInfo = getInfo;
exports.constants = events;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./fsevents.node":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-abstract/5/ToPrimitive.js
      421: {
        factory: (module, exports, require) => {
          'use strict'; // http://262.ecma-international.org/5.1/#sec-9.1

module.exports = require('es-to-primitive/es5');
        },
        map: {"es-to-primitive/es5":441}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-to-primitive/es2015.js
      422: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var hasSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable');

var isDate = require('is-date-object');

var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
  if (typeof O === 'undefined' || O === null) {
    throw new TypeError('Cannot call method on ' + O);
  }

  if (typeof hint !== 'string' || hint !== 'number' && hint !== 'string') {
    throw new TypeError('hint must be "string" or "number"');
  }

  var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
  var method, result, i;

  for (i = 0; i < methodNames.length; ++i) {
    method = O[methodNames[i]];

    if (isCallable(method)) {
      result = method.call(O);

      if (isPrimitive(result)) {
        return result;
      }
    }
  }

  throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
  var func = O[P];

  if (func !== null && typeof func !== 'undefined') {
    if (!isCallable(func)) {
      throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
    }

    return func;
  }

  return void 0;
}; // http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive


module.exports = function ToPrimitive(input) {
  if (isPrimitive(input)) {
    return input;
  }

  var hint = 'default';

  if (arguments.length > 1) {
    if (arguments[1] === String) {
      hint = 'string';
    } else if (arguments[1] === Number) {
      hint = 'number';
    }
  }

  var exoticToPrim;

  if (hasSymbols) {
    if (Symbol.toPrimitive) {
      exoticToPrim = GetMethod(input, Symbol.toPrimitive);
    } else if (isSymbol(input)) {
      exoticToPrim = Symbol.prototype.valueOf;
    }
  }

  if (typeof exoticToPrim !== 'undefined') {
    var result = exoticToPrim.call(input, hint);

    if (isPrimitive(result)) {
      return result;
    }

    throw new TypeError('unable to convert exotic object to primitive');
  }

  if (hint === 'default' && (isDate(input) || isSymbol(input))) {
    hint = 'string';
  }

  return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"./helpers/isPrimitive":442,"is-callable":443,"is-date-object":444,"is-symbol":445}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_hashClear.js
      423: {
        factory: (module, exports, require) => {
          var nativeCreate = require('./_nativeCreate');
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;
        },
        map: {"./_nativeCreate":446}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_hashDelete.js
      424: {
        factory: (module, exports, require) => {
          /**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_hashGet.js
      425: {
        factory: (module, exports, require) => {
          var nativeCreate = require('./_nativeCreate');
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;
        },
        map: {"./_nativeCreate":446}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_hashHas.js
      426: {
        factory: (module, exports, require) => {
          var nativeCreate = require('./_nativeCreate');
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;
        },
        map: {"./_nativeCreate":446}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_hashSet.js
      427: {
        factory: (module, exports, require) => {
          var nativeCreate = require('./_nativeCreate');
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;
        },
        map: {"./_nativeCreate":446}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_isKeyable.js
      428: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_coreJsData.js
      429: {
        factory: (module, exports, require) => {
          var root = require('./_root');
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;
        },
        map: {"./_root":231}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_SetCache.js
      430: {
        factory: (module, exports, require) => {
          var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;
        },
        map: {"./_MapCache":312,"./_setCacheAdd":447,"./_setCacheHas":448}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_arraySome.js
      431: {
        factory: (module, exports, require) => {
          /**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_cacheHas.js
      432: {
        factory: (module, exports, require) => {
          /**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_mapToArray.js
      433: {
        factory: (module, exports, require) => {
          /**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_setToArray.js
      434: {
        factory: (module, exports, require) => {
          /**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/color-convert/index.js
      435: {
        factory: (module, exports, require) => {
          var _typeof = require("@babel/runtime/helpers/typeof");

var conversions = require('./conversions');

var route = require('./route');

var convert = {};
var models = Object.keys(conversions);

function wrapRaw(fn) {
  var wrappedFn = function wrappedFn() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    return fn(args);
  }; // Preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded(fn) {
  var wrappedFn = function wrappedFn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var arg0 = args[0];

    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }

    if (arg0.length > 1) {
      args = arg0;
    }

    var result = fn(args); // We're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (_typeof(result) === 'object') {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // Preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], 'channels', {
    value: conversions[fromModel].channels
  });
  Object.defineProperty(convert[fromModel], 'labels', {
    value: conversions[fromModel].labels
  });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
module.exports = convert;
        },
        map: {"@babel/runtime/helpers/typeof":12,"./conversions":449,"./route":450}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/picomatch/lib/picomatch.js
      436: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _typeof = require("@babel/runtime/helpers/typeof");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var path = require('path');

var scan = require('./scan');

var parse = require('./parse');

var utils = require('./utils');

var constants = require('./constants');

var isObject = function isObject(val) {
  return val && _typeof(val) === 'object' && !Array.isArray(val);
};
/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */


var picomatch = function picomatch(glob, options) {
  var returnState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (Array.isArray(glob)) {
    var fns = glob.map(function (input) {
      return picomatch(input, options, returnState);
    });

    var arrayMatcher = function arrayMatcher(str) {
      var _iterator = _createForOfIteratorHelper(fns),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var isMatch = _step.value;

          var _state = isMatch(str);

          if (_state) return _state;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return false;
    };

    return arrayMatcher;
  }

  var isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || typeof glob !== 'string' && !isState) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  var opts = options || {};
  var posix = utils.isWindows(options);
  var regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
  var state = regex.state;
  delete regex.state;

  var isIgnored = function isIgnored() {
    return false;
  };

  if (opts.ignore) {
    var ignoreOpts = _objectSpread(_objectSpread({}, options), {}, {
      ignore: null,
      onMatch: null,
      onResult: null
    });

    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  var matcher = function matcher(input) {
    var returnObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var _picomatch$test = picomatch.test(input, regex, options, {
      glob: glob,
      posix: posix
    }),
        isMatch = _picomatch$test.isMatch,
        match = _picomatch$test.match,
        output = _picomatch$test.output;

    var result = {
      glob: glob,
      state: state,
      regex: regex,
      posix: posix,
      input: input,
      output: output,
      match: match,
      isMatch: isMatch
    };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }

      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }

    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};
/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */


picomatch.test = function (input, regex, options) {
  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      glob = _ref.glob,
      posix = _ref.posix;

  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return {
      isMatch: false,
      output: ''
    };
  }

  var opts = options || {};
  var format = opts.format || (posix ? utils.toPosixSlashes : null);
  var match = input === glob;
  var output = match && format ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return {
    isMatch: Boolean(match),
    match: match,
    output: output
  };
};
/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */


picomatch.matchBase = function (input, glob, options) {
  var posix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : utils.isWindows(options);
  var regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};
/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */


picomatch.isMatch = function (str, patterns, options) {
  return picomatch(patterns, options)(str);
};
/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */


picomatch.parse = function (pattern, options) {
  if (Array.isArray(pattern)) return pattern.map(function (p) {
    return picomatch.parse(p, options);
  });
  return parse(pattern, _objectSpread(_objectSpread({}, options), {}, {
    fastpaths: false
  }));
};
/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */


picomatch.scan = function (input, options) {
  return scan(input, options);
};
/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */


picomatch.compileRe = function (state, options) {
  var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (returnOutput === true) {
    return state.output;
  }

  var opts = options || {};
  var prepend = opts.contains ? '' : '^';
  var append = opts.contains ? '' : '$';
  var source = "".concat(prepend, "(?:").concat(state.output, ")").concat(append);

  if (state && state.negated === true) {
    source = "^(?!".concat(source, ").*$");
  }

  var regex = picomatch.toRegex(source, options);

  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};
/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */


picomatch.makeRe = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  var parsed = {
    negated: false,
    fastpaths: true
  };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};
/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */


picomatch.toRegex = function (source, options) {
  try {
    var opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};
/**
 * Picomatch constants.
 * @return {Object}
 */


picomatch.constants = constants;
/**
 * Expose "picomatch"
 */

module.exports = picomatch;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/typeof":12,"path":-19260817,"./scan":451,"./parse":452,"./utils":453,"./constants":454}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/braces/lib/utils.js
      437: {
        factory: (module, exports, require) => {
          'use strict';

exports.isInteger = function (num) {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }

  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }

  return false;
};
/**
 * Find a node of the given type
 */


exports.find = function (node, type) {
  return node.nodes.find(function (node) {
    return node.type === type;
  });
};
/**
 * Find a node of the given type
 */


exports.exceedsLimit = function (min, max) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var limit = arguments.length > 3 ? arguments[3] : undefined;
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return (Number(max) - Number(min)) / Number(step) >= limit;
};
/**
 * Escape the given node with '\\' before node.value
 */


exports.escapeNode = function (block) {
  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var type = arguments.length > 2 ? arguments[2] : undefined;
  var node = block.nodes[n];
  if (!node) return;

  if (type && node.type === type || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};
/**
 * Returns true if the given brace node should be enclosed in literal braces
 */


exports.encloseBrace = function (node) {
  if (node.type !== 'brace') return false;

  if (node.commas >> 0 + node.ranges >> 0 === 0) {
    node.invalid = true;
    return true;
  }

  return false;
};
/**
 * Returns true if a brace node is invalid.
 */


exports.isInvalidBrace = function (block) {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;

  if (block.commas >> 0 + block.ranges >> 0 === 0) {
    block.invalid = true;
    return true;
  }

  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }

  return false;
};
/**
 * Returns true if a node is an open or close node
 */


exports.isOpenOrClose = function (node) {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }

  return node.open === true || node.close === true;
};
/**
 * Reduce an array of text nodes.
 */


exports.reduce = function (nodes) {
  return nodes.reduce(function (acc, node) {
    if (node.type === 'text') acc.push(node.value);
    if (node.type === 'range') node.type = 'text';
    return acc;
  }, []);
};
/**
 * Flatten an array
 */


exports.flatten = function () {
  var result = [];

  var flat = function flat(arr) {
    for (var i = 0; i < arr.length; i++) {
      var ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }

    return result;
  };

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  flat(args);
  return result;
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/fill-range/index.js
      438: {
        factory: (module, exports, require) => {
          /*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _typeof = require("@babel/runtime/helpers/typeof");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var util = require('util');

var toRegexRange = require('to-regex-range');

var isObject = function isObject(val) {
  return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
};

var transform = function transform(toNumber) {
  return function (value) {
    return toNumber === true ? Number(value) : String(value);
  };
};

var isValidValue = function isValidValue(value) {
  return typeof value === 'number' || typeof value === 'string' && value !== '';
};

var isNumber = function isNumber(num) {
  return Number.isInteger(+num);
};

var zeros = function zeros(input) {
  var value = "".concat(input);
  var index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;

  while (value[++index] === '0') {
    ;
  }

  return index > 0;
};

var stringify = function stringify(start, end, options) {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }

  return options.stringify === true;
};

var pad = function pad(input, maxLength, toNumber) {
  if (maxLength > 0) {
    var dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
  }

  if (toNumber === false) {
    return String(input);
  }

  return input;
};

var toMaxLen = function toMaxLen(input, maxLength) {
  var negative = input[0] === '-' ? '-' : '';

  if (negative) {
    input = input.slice(1);
    maxLength--;
  }

  while (input.length < maxLength) {
    input = '0' + input;
  }

  return negative ? '-' + input : input;
};

var toSequence = function toSequence(parts, options) {
  parts.negatives.sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  });
  parts.positives.sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  });
  var prefix = options.capture ? '' : '?:';
  var positives = '';
  var negatives = '';
  var result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = "-(".concat(prefix).concat(parts.negatives.join('|'), ")");
  }

  if (positives && negatives) {
    result = "".concat(positives, "|").concat(negatives);
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return "(".concat(prefix).concat(result, ")");
  }

  return result;
};

var toRange = function toRange(a, b, isNumbers, options) {
  if (isNumbers) {
    return toRegexRange(a, b, _objectSpread({
      wrap: false
    }, options));
  }

  var start = String.fromCharCode(a);
  if (a === b) return start;
  var stop = String.fromCharCode(b);
  return "[".concat(start, "-").concat(stop, "]");
};

var toRegex = function toRegex(start, end, options) {
  if (Array.isArray(start)) {
    var wrap = options.wrap === true;
    var prefix = options.capture ? '' : '?:';
    return wrap ? "(".concat(prefix).concat(start.join('|'), ")") : start.join('|');
  }

  return toRegexRange(start, end, options);
};

var rangeError = function rangeError() {
  return new RangeError('Invalid range arguments: ' + util.inspect.apply(util, arguments));
};

var invalidRange = function invalidRange(start, end, options) {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

var invalidStep = function invalidStep(step, options) {
  if (options.strictRanges === true) {
    throw new TypeError("Expected step \"".concat(step, "\" to be a number"));
  }

  return [];
};

var fillNumbers = function fillNumbers(start, end) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var a = Number(start);
  var b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  } // fix negative zero


  if (a === 0) a = 0;
  if (b === 0) b = 0;
  var descending = a > b;
  var startString = String(start);
  var endString = String(end);
  var stepString = String(step);
  step = Math.max(Math.abs(step), 1);
  var padded = zeros(startString) || zeros(endString) || zeros(stepString);
  var maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  var toNumber = padded === false && stringify(start, end, options) === false;
  var format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  var parts = {
    negatives: [],
    positives: []
  };

  var push = function push(num) {
    return parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  };

  var range = [];
  var index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }

    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1 ? toSequence(parts, options) : toRegex(range, null, _objectSpread({
      wrap: false
    }, options));
  }

  return range;
};

var fillLetters = function fillLetters(start, end) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
    return invalidRange(start, end, options);
  }

  var format = options.transform || function (val) {
    return String.fromCharCode(val);
  };

  var a = "".concat(start).charCodeAt(0);
  var b = "".concat(end).charCodeAt(0);
  var descending = a > b;
  var min = Math.min(a, b);
  var max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  var range = [];
  var index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, {
      wrap: false,
      options: options
    });
  }

  return range;
};

var fill = function fill(start, end, step) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, {
      transform: step
    });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  var opts = _objectSpread({}, options);

  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/typeof":12,"util":-19260817,"to-regex-range":455}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/braces/lib/constants.js
      439: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = {
  MAX_LENGTH: 1024 * 64,
  // Digits
  CHAR_0: '0',

  /* 0 */
  CHAR_9: '9',

  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A',

  /* A */
  CHAR_LOWERCASE_A: 'a',

  /* a */
  CHAR_UPPERCASE_Z: 'Z',

  /* Z */
  CHAR_LOWERCASE_Z: 'z',

  /* z */
  CHAR_LEFT_PARENTHESES: '(',

  /* ( */
  CHAR_RIGHT_PARENTHESES: ')',

  /* ) */
  CHAR_ASTERISK: '*',

  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&',

  /* & */
  CHAR_AT: '@',

  /* @ */
  CHAR_BACKSLASH: '\\',

  /* \ */
  CHAR_BACKTICK: '`',

  /* ` */
  CHAR_CARRIAGE_RETURN: '\r',

  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^',

  /* ^ */
  CHAR_COLON: ':',

  /* : */
  CHAR_COMMA: ',',

  /* , */
  CHAR_DOLLAR: '$',

  /* . */
  CHAR_DOT: '.',

  /* . */
  CHAR_DOUBLE_QUOTE: '"',

  /* " */
  CHAR_EQUAL: '=',

  /* = */
  CHAR_EXCLAMATION_MARK: '!',

  /* ! */
  CHAR_FORM_FEED: '\f',

  /* \f */
  CHAR_FORWARD_SLASH: '/',

  /* / */
  CHAR_HASH: '#',

  /* # */
  CHAR_HYPHEN_MINUS: '-',

  /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<',

  /* < */
  CHAR_LEFT_CURLY_BRACE: '{',

  /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[',

  /* [ */
  CHAR_LINE_FEED: '\n',

  /* \n */
  CHAR_NO_BREAK_SPACE: "\xA0",

  /* \u00A0 */
  CHAR_PERCENT: '%',

  /* % */
  CHAR_PLUS: '+',

  /* + */
  CHAR_QUESTION_MARK: '?',

  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>',

  /* > */
  CHAR_RIGHT_CURLY_BRACE: '}',

  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']',

  /* ] */
  CHAR_SEMICOLON: ';',

  /* ; */
  CHAR_SINGLE_QUOTE: '\'',

  /* ' */
  CHAR_SPACE: ' ',

  /*   */
  CHAR_TAB: '\t',

  /* \t */
  CHAR_UNDERSCORE: '_',

  /* _ */
  CHAR_VERTICAL_LINE: '|',

  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  /* \uFEFF */

};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/binary-extensions/index.js
      440: {
        factory: (module, exports, require) => {
          module.exports = require('./binary-extensions.json');
        },
        map: {"./binary-extensions.json":456}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-to-primitive/es5.js
      441: {
        factory: (module, exports, require) => {
          'use strict';

var toStr = Object.prototype.toString;

var isPrimitive = require('./helpers/isPrimitive');

var isCallable = require('is-callable'); // http://ecma-international.org/ecma-262/5.1/#sec-8.12.8


var ES5internalSlots = {
  '[[DefaultValue]]': function DefaultValue(O) {
    var actualHint;

    if (arguments.length > 1) {
      actualHint = arguments[1];
    } else {
      actualHint = toStr.call(O) === '[object Date]' ? String : Number;
    }

    if (actualHint === String || actualHint === Number) {
      var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
      var value, i;

      for (i = 0; i < methods.length; ++i) {
        if (isCallable(O[methods[i]])) {
          value = O[methods[i]]();

          if (isPrimitive(value)) {
            return value;
          }
        }
      }

      throw new TypeError('No default value');
    }

    throw new TypeError('invalid [[DefaultValue]] hint supplied');
  }
}; // http://ecma-international.org/ecma-262/5.1/#sec-9.1

module.exports = function ToPrimitive(input) {
  if (isPrimitive(input)) {
    return input;
  }

  if (arguments.length > 1) {
    return ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);
  }

  return ES5internalSlots['[[DefaultValue]]'](input);
};
        },
        map: {"./helpers/isPrimitive":442,"is-callable":443}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/es-to-primitive/helpers/isPrimitive.js
      442: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

module.exports = function isPrimitive(value) {
  return value === null || typeof value !== 'function' && _typeof(value) !== 'object';
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-callable/index.js
      443: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var fnToStr = Function.prototype.toString;
var reflectApply = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;

if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
  try {
    badArrayLike = Object.defineProperty({}, 'length', {
      get: function get() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {}; // eslint-disable-next-line no-throw-literal

    reflectApply(function () {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}

var constructorRegex = /^\s*class\b/;

var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false; // not a function
  }
};

var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }

    fnToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};

var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

/* globals document: false */

var documentDotAll = (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && typeof document.all === 'undefined' && document.all !== undefined ? document.all : {};
module.exports = reflectApply ? function isCallable(value) {
  if (value === documentDotAll) {
    return true;
  }

  if (!value) {
    return false;
  }

  if (typeof value !== 'function' && _typeof(value) !== 'object') {
    return false;
  }

  if (typeof value === 'function' && !value.prototype) {
    return true;
  }

  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }

  return !isES6ClassFn(value);
} : function isCallable(value) {
  if (value === documentDotAll) {
    return true;
  }

  if (!value) {
    return false;
  }

  if (typeof value !== 'function' && _typeof(value) !== 'object') {
    return false;
  }

  if (typeof value === 'function' && !value.prototype) {
    return true;
  }

  if (hasToStringTag) {
    return tryFunctionObject(value);
  }

  if (isES6ClassFn(value)) {
    return false;
  }

  var strClass = toStr.call(value);
  return strClass === fnClass || strClass === genClass;
};
        },
        map: {"@babel/runtime/helpers/typeof":12}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-date-object/index.js
      444: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var getDay = Date.prototype.getDay;

var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';

var hasToStringTag = require('has-tostringtag/shams')();

module.exports = function isDateObject(value) {
  if (_typeof(value) !== 'object' || value === null) {
    return false;
  }

  return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"has-tostringtag/shams":393}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-symbol/index.js
      445: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var toStr = Object.prototype.toString;

var hasSymbols = require('has-symbols')();

if (hasSymbols) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;

  var isSymbolObject = function isRealSymbolObject(value) {
    if (_typeof(value.valueOf()) !== 'symbol') {
      return false;
    }

    return symStringRegex.test(symToStr.call(value));
  };

  module.exports = function isSymbol(value) {
    if (_typeof(value) === 'symbol') {
      return true;
    }

    if (toStr.call(value) !== '[object Symbol]') {
      return false;
    }

    try {
      return isSymbolObject(value);
    } catch (e) {
      return false;
    }
  };
} else {
  module.exports = function isSymbol(value) {
    // this environment does not support Symbols.
    return false && value;
  };
}
        },
        map: {"@babel/runtime/helpers/typeof":12,"has-symbols":328}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_nativeCreate.js
      446: {
        factory: (module, exports, require) => {
          var getNative = require('./_getNative');
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;
        },
        map: {"./_getNative":315}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_setCacheAdd.js
      447: {
        factory: (module, exports, require) => {
          /** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/lodash/_setCacheHas.js
      448: {
        factory: (module, exports, require) => {
          /**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/color-convert/conversions.js
      449: {
        factory: (module, exports, require) => {
          var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

/* MIT license */

/* eslint-disable no-mixed-operators */
var cssKeywords = require('color-name'); // NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)


var reverseKeywords = {};

for (var _i = 0, _Object$keys = Object.keys(cssKeywords); _i < _Object$keys.length; _i++) {
  var key = _Object$keys[_i];
  reverseKeywords[cssKeywords[key]] = key;
}

var convert = {
  rgb: {
    channels: 3,
    labels: 'rgb'
  },
  hsl: {
    channels: 3,
    labels: 'hsl'
  },
  hsv: {
    channels: 3,
    labels: 'hsv'
  },
  hwb: {
    channels: 3,
    labels: 'hwb'
  },
  cmyk: {
    channels: 4,
    labels: 'cmyk'
  },
  xyz: {
    channels: 3,
    labels: 'xyz'
  },
  lab: {
    channels: 3,
    labels: 'lab'
  },
  lch: {
    channels: 3,
    labels: 'lch'
  },
  hex: {
    channels: 1,
    labels: ['hex']
  },
  keyword: {
    channels: 1,
    labels: ['keyword']
  },
  ansi16: {
    channels: 1,
    labels: ['ansi16']
  },
  ansi256: {
    channels: 1,
    labels: ['ansi256']
  },
  hcg: {
    channels: 3,
    labels: ['h', 'c', 'g']
  },
  apple: {
    channels: 3,
    labels: ['r16', 'g16', 'b16']
  },
  gray: {
    channels: 1,
    labels: ['gray']
  }
};
module.exports = convert; // Hide .channels and .labels properties

for (var _i2 = 0, _Object$keys2 = Object.keys(convert); _i2 < _Object$keys2.length; _i2++) {
  var model = _Object$keys2[_i2];

  if (!('channels' in convert[model])) {
    throw new Error('missing channels property: ' + model);
  }

  if (!('labels' in convert[model])) {
    throw new Error('missing channel labels property: ' + model);
  }

  if (convert[model].labels.length !== convert[model].channels) {
    throw new Error('channel and label counts mismatch: ' + model);
  }

  var _convert$model = convert[model],
      channels = _convert$model.channels,
      labels = _convert$model.labels;
  delete convert[model].channels;
  delete convert[model].labels;
  Object.defineProperty(convert[model], 'channels', {
    value: channels
  });
  Object.defineProperty(convert[model], 'labels', {
    value: labels
  });
}

convert.rgb.hsl = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min = Math.min(r, g, b);
  var max = Math.max(r, g, b);
  var delta = max - min;
  var h;
  var s;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  var l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h;
  var s;
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v = Math.max(r, g, b);
  var diff = v - Math.min(r, g, b);

  var diffc = function diffc(c) {
    return (v - c) / 6 / diff + 1 / 2;
  };

  if (diff === 0) {
    h = 0;
    s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);

    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }

    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }

  return [h * 360, s * 100, v * 100];
};

convert.rgb.hwb = function (rgb) {
  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h = convert.rgb.hsl(rgb)[0];
  var w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var k = Math.min(1 - r, 1 - g, 1 - b);
  var c = (1 - r - k) / (1 - k) || 0;
  var m = (1 - g - k) / (1 - k) || 0;
  var y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
  /*
  	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
  */
  return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
}

convert.rgb.keyword = function (rgb) {
  var reversed = reverseKeywords[rgb];

  if (reversed) {
    return reversed;
  }

  var currentClosestDistance = Infinity;
  var currentClosestKeyword;

  for (var _i3 = 0, _Object$keys3 = Object.keys(cssKeywords); _i3 < _Object$keys3.length; _i3++) {
    var keyword = _Object$keys3[_i3];
    var value = cssKeywords[keyword]; // Compute comparative distance

    var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }

  return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
  return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255; // Assume sRGB

  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
  var xyz = convert.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  var l = 116 * y - 16;
  var a = 500 * (x - y);
  var b = 200 * (y - z);
  return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
  var h = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t2;
  var t3;
  var val;

  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }

  var t1 = 2 * l - t2;
  var rgb = [0, 0, 0];

  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);

    if (t3 < 0) {
      t3++;
    }

    if (t3 > 1) {
      t3--;
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }

    rgb[i] = val * 255;
  }

  return rgb;
};

convert.hsl.hsv = function (hsl) {
  var h = hsl[0];
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var smin = s;
  var lmin = Math.max(l, 0.01);
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  var v = (l + s) / 2;
  var sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
  var h = hsv[0] / 60;
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var hi = Math.floor(h) % 6;
  var f = h - Math.floor(h);
  var p = 255 * v * (1 - s);
  var q = 255 * v * (1 - s * f);
  var t = 255 * v * (1 - s * (1 - f));
  v *= 255;

  switch (hi) {
    case 0:
      return [v, t, p];

    case 1:
      return [q, v, p];

    case 2:
      return [p, v, t];

    case 3:
      return [p, q, v];

    case 4:
      return [t, p, v];

    case 5:
      return [v, p, q];
  }
};

convert.hsv.hsl = function (hsv) {
  var h = hsv[0];
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var vmin = Math.max(v, 0.01);
  var sl;
  var l;
  l = (2 - s) * v;
  var lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


convert.hwb.rgb = function (hwb) {
  var h = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var f; // Wh + bl cant be > 1

  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  var i = Math.floor(6 * h);
  var v = 1 - bl;
  f = 6 * h - i;

  if ((i & 0x01) !== 0) {
    f = 1 - f;
  }

  var n = wh + f * (v - wh); // Linear interpolation

  var r;
  var g;
  var b;
  /* eslint-disable max-statements-per-line,no-multi-spaces */

  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;

    case 1:
      r = n;
      g = v;
      b = wh;
      break;

    case 2:
      r = wh;
      g = v;
      b = n;
      break;

    case 3:
      r = wh;
      g = n;
      b = v;
      break;

    case 4:
      r = n;
      g = wh;
      b = v;
      break;

    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  /* eslint-enable max-statements-per-line,no-multi-spaces */


  return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
  var c = cmyk[0] / 100;
  var m = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r = 1 - Math.min(1, c * (1 - k) + k);
  var g = 1 - Math.min(1, m * (1 - k) + k);
  var b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z = xyz[2] / 100;
  var r;
  var g;
  var b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570; // Assume sRGB

  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  var l = 116 * y - 16;
  var a = 500 * (x - y);
  var b = 200 * (y - z);
  return [l, a, b];
};

convert.lab.xyz = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z2 = Math.pow(z, 3);
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};

convert.lab.lch = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var h;
  var hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;

  if (h < 0) {
    h += 360;
  }

  var c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};

convert.lch.lab = function (lch) {
  var l = lch[0];
  var c = lch[1];
  var h = lch[2];
  var hr = h / 360 * 2 * Math.PI;
  var a = c * Math.cos(hr);
  var b = c * Math.sin(hr);
  return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
  var saturation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _args = _slicedToArray(args, 3),
      r = _args[0],
      g = _args[1],
      b = _args[2];

  var value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

  value = Math.round(value / 50);

  if (value === 0) {
    return 30;
  }

  var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

  if (value === 2) {
    ansi += 60;
  }

  return ansi;
};

convert.hsv.ansi16 = function (args) {
  // Optimization here; we already know the value and don't need to get
  // it converted for us.
  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2]; // We use the extended greyscale palette here, with the exception of
  // black and white. normal palette only has 4 greyscale shades.

  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }

    if (r > 248) {
      return 231;
    }

    return Math.round((r - 8) / 247 * 24) + 232;
  }

  var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};

convert.ansi16.rgb = function (args) {
  var color = args % 10; // Handle greyscale

  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }

    color = color / 10.5 * 255;
    return [color, color, color];
  }

  var mult = (~~(args > 50) + 1) * 0.5;
  var r = (color & 1) * mult * 255;
  var g = (color >> 1 & 1) * mult * 255;
  var b = (color >> 2 & 1) * mult * 255;
  return [r, g, b];
};

convert.ansi256.rgb = function (args) {
  // Handle greyscale
  if (args >= 232) {
    var c = (args - 232) * 10 + 8;
    return [c, c, c];
  }

  args -= 16;
  var rem;
  var r = Math.floor(args / 36) / 5 * 255;
  var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  var b = rem % 6 / 5 * 255;
  return [r, g, b];
};

convert.rgb.hex = function (args) {
  var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
  var string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

  if (!match) {
    return [0, 0, 0];
  }

  var colorString = match[0];

  if (match[0].length === 3) {
    colorString = colorString.split('').map(function (_char) {
      return _char + _char;
    }).join('');
  }

  var integer = parseInt(colorString, 16);
  var r = integer >> 16 & 0xFF;
  var g = integer >> 8 & 0xFF;
  var b = integer & 0xFF;
  return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max = Math.max(Math.max(r, g), b);
  var min = Math.min(Math.min(r, g), b);
  var chroma = max - min;
  var grayscale;
  var hue;

  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }

  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g - b) / chroma % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma;
  }

  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
  var f = 0;

  if (c < 1.0) {
    f = (l - 0.5 * c) / (1.0 - c);
  }

  return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var c = s * v;
  var f = 0;

  if (c < 1.0) {
    f = (v - c) / (1 - c);
  }

  return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
  var h = hcg[0] / 360;
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;

  if (c === 0.0) {
    return [g * 255, g * 255, g * 255];
  }

  var pure = [0, 0, 0];
  var hi = h % 1 * 6;
  var v = hi % 1;
  var w = 1 - v;
  var mg = 0;
  /* eslint-disable max-statements-per-line */

  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;

    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;

    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;

    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;

    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;

    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  /* eslint-enable max-statements-per-line */


  mg = (1.0 - c) * g;
  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
};

convert.hcg.hsv = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1.0 - c);
  var f = 0;

  if (v > 0.0) {
    f = c / v;
  }

  return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l = g * (1.0 - c) + 0.5 * c;
  var s = 0;

  if (l > 0.0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1.0) {
    s = c / (2 * (1 - l));
  }

  return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1.0 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
  var w = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v = 1 - b;
  var c = v - w;
  var g = 0;

  if (c < 1) {
    g = (v - c) / (1 - c);
  }

  return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};

convert.rgb.apple = function (rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};

convert.gray.rgb = function (args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
  return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
  var val = Math.round(gray[0] / 100 * 255) & 0xFF;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
        },
        map: {"@babel/runtime/helpers/slicedToArray":120,"color-name":457}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/color-convert/route.js
      450: {
        factory: (module, exports, require) => {
          var conversions = require('./conversions');
/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/


function buildGraph() {
  var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  var models = Object.keys(conversions);

  for (var len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel]; // Unshift -> queue -> pop

  graph[fromModel].distance = 0;

  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions[current]);

    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

module.exports = function (fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models = Object.keys(graph);

  for (var len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];
    var node = graph[toModel];

    if (node.parent === null) {
      // No possible conversion, or this node is the source model.
      continue;
    }

    conversion[toModel] = wrapConversion(toModel, graph);
  }

  return conversion;
};
        },
        map: {"./conversions":449}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/picomatch/lib/scan.js
      451: {
        factory: (module, exports, require) => {
          'use strict';

var utils = require('./utils');

var _require = require('./constants'),
    CHAR_ASTERISK = _require.CHAR_ASTERISK,
    CHAR_AT = _require.CHAR_AT,
    CHAR_BACKWARD_SLASH = _require.CHAR_BACKWARD_SLASH,
    CHAR_COMMA = _require.CHAR_COMMA,
    CHAR_DOT = _require.CHAR_DOT,
    CHAR_EXCLAMATION_MARK = _require.CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH = _require.CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE = _require.CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES = _require.CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET = _require.CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS = _require.CHAR_PLUS,
    CHAR_QUESTION_MARK = _require.CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE = _require.CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES = _require.CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET = _require.CHAR_RIGHT_SQUARE_BRACKET;

var isPathSeparator = function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

var depth = function depth(token) {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */


var scan = function scan(input, options) {
  var opts = options || {};
  var length = input.length - 1;
  var scanToEnd = opts.parts === true || opts.scanToEnd === true;
  var slashes = [];
  var tokens = [];
  var parts = [];
  var str = input;
  var index = -1;
  var start = 0;
  var lastIndex = 0;
  var isBrace = false;
  var isBracket = false;
  var isGlob = false;
  var isExtglob = false;
  var isGlobstar = false;
  var braceEscaped = false;
  var backslashes = false;
  var negated = false;
  var negatedExtglob = false;
  var finished = false;
  var braces = 0;
  var prev;
  var code;
  var token = {
    value: '',
    depth: 0,
    isGlob: false
  };

  var eos = function eos() {
    return index >= length;
  };

  var peek = function peek() {
    return str.charCodeAt(index + 1);
  };

  var advance = function advance() {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    var next = void 0;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }

      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = {
        value: '',
        depth: 0,
        isGlob: false
      };
      if (finished === true) continue;

      if (prev === CHAR_DOT && index === start + 1) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      var isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;

        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }

          continue;
        }

        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }

        continue;
      }

      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  var base = str;
  var prefix = '';
  var glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  var state = {
    prefix: prefix,
    input: input,
    start: start,
    base: base,
    glob: glob,
    isBrace: isBrace,
    isBracket: isBracket,
    isGlob: isGlob,
    isExtglob: isExtglob,
    isGlobstar: isGlobstar,
    negated: negated,
    negatedExtglob: negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;

    if (!isPathSeparator(code)) {
      tokens.push(token);
    }

    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    var prevIndex;

    for (var idx = 0; idx < slashes.length; idx++) {
      var n = prevIndex ? prevIndex + 1 : start;
      var i = slashes[idx];
      var value = input.slice(n, i);

      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }

        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }

      if (idx !== 0 || value !== '') {
        parts.push(value);
      }

      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      var _value = input.slice(prevIndex + 1);

      parts.push(_value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = _value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;
        },
        map: {"./utils":453,"./constants":454}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/picomatch/lib/parse.js
      452: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var constants = require('./constants');

var utils = require('./utils');
/**
 * Constants
 */


var MAX_LENGTH = constants.MAX_LENGTH,
    POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS = constants.REPLACEMENTS;
/**
 * Helpers
 */

var expandRange = function expandRange(args, options) {
  if (typeof options.expandRange === 'function') {
    return options.expandRange.apply(options, _toConsumableArray(args).concat([options]));
  }

  args.sort();
  var value = "[".concat(args.join('-'), "]");

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(function (v) {
      return utils.escapeRegex(v);
    }).join('..');
  }

  return value;
};
/**
 * Create the message for a syntax error
 */


var syntaxError = function syntaxError(type, _char) {
  return "Missing ".concat(type, ": \"").concat(_char, "\" - use \"\\\\").concat(_char, "\" to match literal characters");
};
/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */


var parse = function parse(input, options) {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  var opts = _objectSpread({}, options);

  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  var len = input.length;

  if (len > max) {
    throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
  }

  var bos = {
    type: 'bos',
    value: '',
    output: opts.prepend || ''
  };
  var tokens = [bos];
  var capture = opts.capture ? '' : '?:';
  var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix

  var PLATFORM_CHARS = constants.globChars(win32);
  var EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
  var DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL,
      PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL,
      SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL,
      ONE_CHAR = PLATFORM_CHARS.ONE_CHAR,
      DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH,
      NO_DOT = PLATFORM_CHARS.NO_DOT,
      NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH,
      NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH,
      QMARK = PLATFORM_CHARS.QMARK,
      QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT,
      STAR = PLATFORM_CHARS.STAR,
      START_ANCHOR = PLATFORM_CHARS.START_ANCHOR;

  var globstar = function globstar(opts) {
    return "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
  };

  var nodot = opts.dot ? '' : NO_DOT;
  var qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  var star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = "(".concat(star, ")");
  } // minimatch options support


  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  var state = {
    input: input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens: tokens
  };
  input = utils.removePrefix(input, state);
  len = input.length;
  var extglobs = [];
  var braces = [];
  var stack = [];
  var prev = bos;
  var value;
  /**
   * Tokenizing helpers
   */

  var eos = function eos() {
    return state.index === len - 1;
  };

  var peek = state.peek = function () {
    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return input[state.index + n];
  };

  var advance = state.advance = function () {
    return input[++state.index] || '';
  };

  var remaining = function remaining() {
    return input.slice(state.index + 1);
  };

  var consume = function consume() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var num = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    state.consumed += value;
    state.index += num;
  };

  var append = function append(token) {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  var negate = function negate() {
    var count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  var increment = function increment(type) {
    state[type]++;
    stack.push(type);
  };

  var decrement = function decrement(type) {
    state[type]--;
    stack.pop();
  };
  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */


  var push = function push(tok) {
    if (prev.type === 'globstar') {
      var isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      var isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);

    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  var extglobOpen = function extglobOpen(type, value) {
    var token = _objectSpread(_objectSpread({}, EXTGLOB_CHARS[value]), {}, {
      conditions: 1,
      inner: ''
    });

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    var output = (opts.capture ? '(' : '') + token.open;
    increment('parens');
    push({
      type: type,
      value: value,
      output: state.output ? '' : ONE_CHAR
    });
    push({
      type: 'paren',
      extglob: true,
      value: advance(),
      output: output
    });
    extglobs.push(token);
  };

  var extglobClose = function extglobClose(token) {
    var output = token.close + (opts.capture ? ')' : '');
    var rest;

    if (token.type === 'negate') {
      var extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = ")$))".concat(extglobStar);
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        var expression = parse(rest, _objectSpread(_objectSpread({}, options), {}, {
          fastpaths: false
        })).output;
        output = token.close = ")".concat(expression, ")").concat(extglobStar, ")");
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({
      type: 'paren',
      extglob: true,
      value: value,
      output: output
    });
    decrement('parens');
  };
  /**
   * Fast paths
   */


  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    var backslashes = false;
    var output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function (m, esc, chars, first, rest, index) {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }

        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }

        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }

        return star;
      }

      return esc ? m : "\\".concat(m);
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, function (m) {
          return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }
  /**
   * Tokenize input until we reach end-of-string
   */


  while (!eos()) {
    value = advance();

    if (value === "\0") {
      continue;
    }
    /**
     * Escaped characters
     */


    if (value === '\\') {
      var next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({
          type: 'text',
          value: value
        });
        continue;
      } // collapse slashes to reduce potential for exploits


      var match = /^\\+/.exec(remaining());
      var slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;

        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({
          type: 'text',
          value: value
        });
        continue;
      }
    }
    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */


    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        var inner = prev.value.slice(1);

        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            var idx = prev.value.lastIndexOf('[');
            var pre = prev.value.slice(0, idx);

            var _rest = prev.value.slice(idx + 2);

            var posix = POSIX_REGEX_SOURCE[_rest];

            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }

              continue;
            }
          }
        }
      }

      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
        value = "\\".concat(value);
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = "\\".concat(value);
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({
        value: value
      });
      continue;
    }
    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */


    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({
        value: value
      });
      continue;
    }
    /**
     * Double quotes
     */


    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;

      if (opts.keepQuotes === true) {
        push({
          type: 'text',
          value: value
        });
      }

      continue;
    }
    /**
     * Parentheses
     */


    if (value === '(') {
      increment('parens');
      push({
        type: 'paren',
        value: value
      });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      var extglob = extglobs[extglobs.length - 1];

      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({
        type: 'paren',
        value: value,
        output: state.parens ? ')' : '\\)'
      });
      decrement('parens');
      continue;
    }
    /**
     * Square brackets
     */


    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = "\\".concat(value);
      } else {
        increment('brackets');
      }

      push({
        type: 'bracket',
        value: value
      });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
        push({
          type: 'text',
          value: value,
          output: "\\".concat(value)
        });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({
          type: 'text',
          value: value,
          output: "\\".concat(value)
        });
        continue;
      }

      decrement('brackets');
      var prevValue = prev.value.slice(1);

      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = "/".concat(value);
      }

      prev.value += value;
      append({
        value: value
      }); // when literal brackets are explicitly disabled
      // assume we should match with a regex character class

      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      var escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters

      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      } // when the user specifies nothing, try to match both


      prev.value = "(".concat(capture).concat(escaped, "|").concat(prev.value, ")");
      state.output += prev.value;
      continue;
    }
    /**
     * Braces
     */


    if (value === '{' && opts.nobrace !== true) {
      increment('braces');
      var open = {
        type: 'brace',
        value: value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };
      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      var brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({
          type: 'text',
          value: value,
          output: value
        });
        continue;
      }

      var _output = ')';

      if (brace.dots === true) {
        var arr = tokens.slice();
        var range = [];

        for (var i = arr.length - 1; i >= 0; i--) {
          tokens.pop();

          if (arr[i].type === 'brace') {
            break;
          }

          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        _output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        var out = state.output.slice(0, brace.outputIndex);
        var toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = _output = '\\}';
        state.output = out;

        var _iterator = _createForOfIteratorHelper(toks),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var t = _step.value;
            state.output += t.output || t.value;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      push({
        type: 'brace',
        value: value,
        output: _output
      });
      decrement('braces');
      braces.pop();
      continue;
    }
    /**
     * Pipes
     */


    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }

      push({
        type: 'text',
        value: value
      });
      continue;
    }
    /**
     * Commas
     */


    if (value === ',') {
      var _output2 = value;
      var _brace = braces[braces.length - 1];

      if (_brace && stack[stack.length - 1] === 'braces') {
        _brace.comma = true;
        _output2 = '|';
      }

      push({
        type: 'comma',
        value: value,
        output: _output2
      });
      continue;
    }
    /**
     * Slashes
     */


    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token

        continue;
      }

      push({
        type: 'slash',
        value: value,
        output: SLASH_LITERAL
      });
      continue;
    }
    /**
     * Dots
     */


    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        var _brace2 = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        _brace2.dots = true;
        continue;
      }

      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({
          type: 'text',
          value: value,
          output: DOT_LITERAL
        });
        continue;
      }

      push({
        type: 'dot',
        value: value,
        output: DOT_LITERAL
      });
      continue;
    }
    /**
     * Question marks
     */


    if (value === '?') {
      var isGroup = prev && prev.value === '(';

      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        var _next = peek();

        var _output3 = value;

        if (_next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if (prev.value === '(' && !/[!=<:]/.test(_next) || _next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
          _output3 = "\\".concat(value);
        }

        push({
          type: 'text',
          value: value,
          output: _output3
        });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({
          type: 'qmark',
          value: value,
          output: QMARK_NO_DOT
        });
        continue;
      }

      push({
        type: 'qmark',
        value: value,
        output: QMARK
      });
      continue;
    }
    /**
     * Exclamation
     */


    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }
    /**
     * Plus
     */


    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if (prev && prev.value === '(' || opts.regex === false) {
        push({
          type: 'plus',
          value: value,
          output: PLUS_LITERAL
        });
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
        push({
          type: 'plus',
          value: value
        });
        continue;
      }

      push({
        type: 'plus',
        value: PLUS_LITERAL
      });
      continue;
    }
    /**
     * Plain text
     */


    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({
          type: 'at',
          extglob: true,
          value: value,
          output: ''
        });
        continue;
      }

      push({
        type: 'text',
        value: value
      });
      continue;
    }
    /**
     * Plain text
     */


    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = "\\".concat(value);
      }

      var _match = REGEX_NON_SPECIAL_CHARS.exec(remaining());

      if (_match) {
        value += _match[0];
        state.index += _match[0].length;
      }

      push({
        type: 'text',
        value: value
      });
      continue;
    }
    /**
     * Stars
     */


    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    var rest = remaining();

    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      var prior = prev.prev;
      var before = prior.prev;
      var isStart = prior.type === 'slash' || prior.type === 'bos';
      var afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
        push({
          type: 'star',
          value: value,
          output: ''
        });
        continue;
      }

      var isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      var isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');

      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({
          type: 'star',
          value: value,
          output: ''
        });
        continue;
      } // strip consecutive `/**/`


      while (rest.slice(0, 3) === '/**') {
        var after = input[state.index + 4];

        if (after && after !== '/') {
          break;
        }

        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = "(?:".concat(prior.output);
        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        var end = rest[1] !== void 0 ? '|$' : '';
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = "(?:".concat(prior.output);
        prev.type = 'globstar';
        prev.output = "".concat(globstar(opts)).concat(SLASH_LITERAL, "|").concat(SLASH_LITERAL).concat(end, ")");
        prev.value += value;
        state.output += prior.output + prev.output;
        state.globstar = true;
        consume(value + advance());
        push({
          type: 'slash',
          value: '/',
          output: ''
        });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = "(?:^|".concat(SLASH_LITERAL, "|").concat(globstar(opts)).concat(SLASH_LITERAL, ")");
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({
          type: 'slash',
          value: '/',
          output: ''
        });
        continue;
      } // remove single star from output


      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar

      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value; // reset output with globstar

      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    var token = {
      type: 'star',
      value: value,
      output: star
    };

    if (opts.bash === true) {
      token.output = '.*?';

      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }

      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;
      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;
      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({
      type: 'maybe_slash',
      value: '',
      output: "".concat(SLASH_LITERAL, "?")
    });
  } // rebuild the output if we had to backtrack at any point


  if (state.backtrack === true) {
    state.output = '';

    var _iterator2 = _createForOfIteratorHelper(state.tokens),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _token = _step2.value;
        state.output += _token.output != null ? _token.output : _token.value;

        if (_token.suffix) {
          state.output += _token.suffix;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return state;
};
/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */


parse.fastpaths = function (input, options) {
  var opts = _objectSpread({}, options);

  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  var len = input.length;

  if (len > max) {
    throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
  }

  input = REPLACEMENTS[input] || input;
  var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix

  var _constants$globChars = constants.globChars(win32),
      DOT_LITERAL = _constants$globChars.DOT_LITERAL,
      SLASH_LITERAL = _constants$globChars.SLASH_LITERAL,
      ONE_CHAR = _constants$globChars.ONE_CHAR,
      DOTS_SLASH = _constants$globChars.DOTS_SLASH,
      NO_DOT = _constants$globChars.NO_DOT,
      NO_DOTS = _constants$globChars.NO_DOTS,
      NO_DOTS_SLASH = _constants$globChars.NO_DOTS_SLASH,
      STAR = _constants$globChars.STAR,
      START_ANCHOR = _constants$globChars.START_ANCHOR;

  var nodot = opts.dot ? NO_DOTS : NO_DOT;
  var slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  var capture = opts.capture ? '' : '?:';
  var state = {
    negated: false,
    prefix: ''
  };
  var star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = "(".concat(star, ")");
  }

  var globstar = function globstar(opts) {
    if (opts.noglobstar === true) return star;
    return "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
  };

  var create = function create(str) {
    switch (str) {
      case '*':
        return "".concat(nodot).concat(ONE_CHAR).concat(star);

      case '.*':
        return "".concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

      case '*.*':
        return "".concat(nodot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

      case '*/*':
        return "".concat(nodot).concat(star).concat(SLASH_LITERAL).concat(ONE_CHAR).concat(slashDot).concat(star);

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(ONE_CHAR).concat(star);

      case '**/*.*':
        return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

      case '**/.*':
        return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

      default:
        {
          var match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match) return;

          var _source = create(match[1]);

          if (!_source) return;
          return _source + DOT_LITERAL + match[2];
        }
    }
  };

  var output = utils.removePrefix(input, state);
  var source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += "".concat(SLASH_LITERAL, "?");
  }

  return source;
};

module.exports = parse;
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"@babel/runtime/helpers/toConsumableArray":35,"./constants":454,"./utils":453}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/picomatch/lib/utils.js
      453: {
        factory: (module, exports, require) => {
          'use strict';

var _typeof = require("@babel/runtime/helpers/typeof");

var path = require('path');

var win32 = process.platform === 'win32';

var _require = require('./constants'),
    REGEX_BACKSLASH = _require.REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH = _require.REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS = _require.REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL = _require.REGEX_SPECIAL_CHARS_GLOBAL;

exports.isObject = function (val) {
  return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
};

exports.hasRegexChars = function (str) {
  return REGEX_SPECIAL_CHARS.test(str);
};

exports.isRegexChar = function (str) {
  return str.length === 1 && exports.hasRegexChars(str);
};

exports.escapeRegex = function (str) {
  return str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
};

exports.toPosixSlashes = function (str) {
  return str.replace(REGEX_BACKSLASH, '/');
};

exports.removeBackslashes = function (str) {
  return str.replace(REGEX_REMOVE_BACKSLASH, function (match) {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = function () {
  var segs = process.version.slice(1).split('.').map(Number);

  if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
    return true;
  }

  return false;
};

exports.isWindows = function (options) {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }

  return win32 === true || path.sep === '\\';
};

exports.escapeLast = function (input, _char, lastIdx) {
  var idx = input.lastIndexOf(_char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, _char, idx - 1);
  return "".concat(input.slice(0, idx), "\\").concat(input.slice(idx));
};

exports.removePrefix = function (input) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var output = input;

  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }

  return output;
};

exports.wrapOutput = function (input) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var prepend = options.contains ? '' : '^';
  var append = options.contains ? '' : '$';
  var output = "".concat(prepend, "(?:").concat(input, ")").concat(append);

  if (state.negated === true) {
    output = "(?:^(?!".concat(output, ").*$)");
  }

  return output;
};
        },
        map: {"@babel/runtime/helpers/typeof":12,"path":-19260817,"./constants":454}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/picomatch/lib/constants.js
      454: {
        factory: (module, exports, require) => {
          'use strict';

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var path = require('path');

var WIN_SLASH = '\\\\/';
var WIN_NO_SLASH = "[^".concat(WIN_SLASH, "]");
/**
 * Posix glob regex
 */

var DOT_LITERAL = '\\.';
var PLUS_LITERAL = '\\+';
var QMARK_LITERAL = '\\?';
var SLASH_LITERAL = '\\/';
var ONE_CHAR = '(?=.)';
var QMARK = '[^/]';
var END_ANCHOR = "(?:".concat(SLASH_LITERAL, "|$)");
var START_ANCHOR = "(?:^|".concat(SLASH_LITERAL, ")");
var DOTS_SLASH = "".concat(DOT_LITERAL, "{1,2}").concat(END_ANCHOR);
var NO_DOT = "(?!".concat(DOT_LITERAL, ")");
var NO_DOTS = "(?!".concat(START_ANCHOR).concat(DOTS_SLASH, ")");
var NO_DOT_SLASH = "(?!".concat(DOT_LITERAL, "{0,1}").concat(END_ANCHOR, ")");
var NO_DOTS_SLASH = "(?!".concat(DOTS_SLASH, ")");
var QMARK_NO_DOT = "[^.".concat(SLASH_LITERAL, "]");
var STAR = "".concat(QMARK, "*?");
var POSIX_CHARS = {
  DOT_LITERAL: DOT_LITERAL,
  PLUS_LITERAL: PLUS_LITERAL,
  QMARK_LITERAL: QMARK_LITERAL,
  SLASH_LITERAL: SLASH_LITERAL,
  ONE_CHAR: ONE_CHAR,
  QMARK: QMARK,
  END_ANCHOR: END_ANCHOR,
  DOTS_SLASH: DOTS_SLASH,
  NO_DOT: NO_DOT,
  NO_DOTS: NO_DOTS,
  NO_DOT_SLASH: NO_DOT_SLASH,
  NO_DOTS_SLASH: NO_DOTS_SLASH,
  QMARK_NO_DOT: QMARK_NO_DOT,
  STAR: STAR,
  START_ANCHOR: START_ANCHOR
};
/**
 * Windows glob regex
 */

var WINDOWS_CHARS = _objectSpread(_objectSpread({}, POSIX_CHARS), {}, {
  SLASH_LITERAL: "[".concat(WIN_SLASH, "]"),
  QMARK: WIN_NO_SLASH,
  STAR: "".concat(WIN_NO_SLASH, "*?"),
  DOTS_SLASH: "".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$)"),
  NO_DOT: "(?!".concat(DOT_LITERAL, ")"),
  NO_DOTS: "(?!(?:^|[".concat(WIN_SLASH, "])").concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
  NO_DOT_SLASH: "(?!".concat(DOT_LITERAL, "{0,1}(?:[").concat(WIN_SLASH, "]|$))"),
  NO_DOTS_SLASH: "(?!".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
  QMARK_NO_DOT: "[^.".concat(WIN_SLASH, "]"),
  START_ANCHOR: "(?:^|[".concat(WIN_SLASH, "])"),
  END_ANCHOR: "(?:[".concat(WIN_SLASH, "]|$)")
});
/**
 * POSIX Bracket Regex
 */


var POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};
module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },
  // Digits
  CHAR_0: 48,

  /* 0 */
  CHAR_9: 57,

  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,

  /* A */
  CHAR_LOWERCASE_A: 97,

  /* a */
  CHAR_UPPERCASE_Z: 90,

  /* Z */
  CHAR_LOWERCASE_Z: 122,

  /* z */
  CHAR_LEFT_PARENTHESES: 40,

  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,

  /* ) */
  CHAR_ASTERISK: 42,

  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,

  /* & */
  CHAR_AT: 64,

  /* @ */
  CHAR_BACKWARD_SLASH: 92,

  /* \ */
  CHAR_CARRIAGE_RETURN: 13,

  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,

  /* ^ */
  CHAR_COLON: 58,

  /* : */
  CHAR_COMMA: 44,

  /* , */
  CHAR_DOT: 46,

  /* . */
  CHAR_DOUBLE_QUOTE: 34,

  /* " */
  CHAR_EQUAL: 61,

  /* = */
  CHAR_EXCLAMATION_MARK: 33,

  /* ! */
  CHAR_FORM_FEED: 12,

  /* \f */
  CHAR_FORWARD_SLASH: 47,

  /* / */
  CHAR_GRAVE_ACCENT: 96,

  /* ` */
  CHAR_HASH: 35,

  /* # */
  CHAR_HYPHEN_MINUS: 45,

  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,

  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,

  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,

  /* [ */
  CHAR_LINE_FEED: 10,

  /* \n */
  CHAR_NO_BREAK_SPACE: 160,

  /* \u00A0 */
  CHAR_PERCENT: 37,

  /* % */
  CHAR_PLUS: 43,

  /* + */
  CHAR_QUESTION_MARK: 63,

  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,

  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,

  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,

  /* ] */
  CHAR_SEMICOLON: 59,

  /* ; */
  CHAR_SINGLE_QUOTE: 39,

  /* ' */
  CHAR_SPACE: 32,

  /*   */
  CHAR_TAB: 9,

  /* \t */
  CHAR_UNDERSCORE: 95,

  /* _ */
  CHAR_VERTICAL_LINE: 124,

  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

  /* \uFEFF */
  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars: function extglobChars(chars) {
    return {
      '!': {
        type: 'negate',
        open: '(?:(?!(?:',
        close: "))".concat(chars.STAR, ")")
      },
      '?': {
        type: 'qmark',
        open: '(?:',
        close: ')?'
      },
      '+': {
        type: 'plus',
        open: '(?:',
        close: ')+'
      },
      '*': {
        type: 'star',
        open: '(?:',
        close: ')*'
      },
      '@': {
        type: 'at',
        open: '(?:',
        close: ')'
      }
    };
  },

  /**
   * Create GLOB_CHARS
   */
  globChars: function globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};
        },
        map: {"@babel/runtime/helpers/defineProperty":13,"path":-19260817}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/to-regex-range/index.js
      455: {
        factory: (module, exports, require) => {
          /*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
'use strict';

var _slicedToArray = require("@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("@babel/runtime/helpers/toConsumableArray");

var _defineProperty = require("@babel/runtime/helpers/defineProperty");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var isNumber = require('is-number');

var toRegexRange = function toRegexRange(min, max, options) {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  var opts = _objectSpread({
    relaxZeros: true
  }, options);

  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  var relax = String(opts.relaxZeros);
  var shorthand = String(opts.shorthand);
  var capture = String(opts.capture);
  var wrap = String(opts.wrap);
  var cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  var a = Math.min(min, max);
  var b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    var result = min + '|' + max;

    if (opts.capture) {
      return "(".concat(result, ")");
    }

    if (opts.wrap === false) {
      return result;
    }

    return "(?:".concat(result, ")");
  }

  var isPadded = hasPadding(min) || hasPadding(max);
  var state = {
    min: min,
    max: max,
    a: a,
    b: b
  };
  var positives = [];
  var negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    var newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = "(".concat(state.result, ")");
  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
    state.result = "(?:".concat(state.result, ")");
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  var nines = 1;
  var zeros = 1;
  var stop = countNines(min, nines);
  var stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = _toConsumableArray(stops);
  stops.sort(compare);
  return stops;
}
/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */


function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return {
      pattern: start,
      count: [],
      digits: 0
    };
  }

  var zipped = zip(start, stop);
  var digits = zipped.length;
  var pattern = '';
  var count = 0;

  for (var i = 0; i < digits; i++) {
    var _zipped$i = _slicedToArray(zipped[i], 2),
        startDigit = _zipped$i[0],
        stopDigit = _zipped$i[1];

    if (startDigit === stopDigit) {
      pattern += startDigit;
    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);
    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return {
    pattern: pattern,
    count: [count],
    digits: digits
  };
}

function splitToPatterns(min, max, tok, options) {
  var ranges = splitToRanges(min, max);
  var tokens = [];
  var start = min;
  var prev;

  for (var i = 0; i < ranges.length; i++) {
    var _max = ranges[i];
    var obj = rangeToPattern(String(start), String(_max), options);
    var zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = _max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(_max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = _max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  var result = [];

  var _iterator = _createForOfIteratorHelper(arr),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var ele = _step.value;
      var string = ele.string; // only push if _both_ are negative...

      if (!intersection && !contains(comparison, 'string', string)) {
        result.push(prefix + string);
      } // or _both_ are positive


      if (intersection && contains(comparison, 'string', string)) {
        result.push(prefix + string);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result;
}
/**
 * Zip strings
 */


function zip(a, b) {
  var arr = [];

  for (var i = 0; i < a.length; i++) {
    arr.push([a[i], b[i]]);
  }

  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(function (ele) {
    return ele[key] === val;
  });
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - integer % Math.pow(10, zeros);
}

function toQuantifier(digits) {
  var _digits = _slicedToArray(digits, 2),
      _digits$ = _digits[0],
      start = _digits$ === void 0 ? 0 : _digits$,
      _digits$2 = _digits[1],
      stop = _digits$2 === void 0 ? '' : _digits$2;

  if (stop || start > 1) {
    return "{".concat(start + (stop ? ',' + stop : ''), "}");
  }

  return '';
}

function toCharacterClass(a, b, options) {
  return "[".concat(a).concat(b - a === 1 ? '' : '-').concat(b, "]");
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  var diff = Math.abs(tok.maxLen - String(value).length);
  var relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';

    case 1:
      return relax ? '0?' : '0';

    case 2:
      return relax ? '0{0,2}' : '00';

    default:
      {
        return relax ? "0{0,".concat(diff, "}") : "0{".concat(diff, "}");
      }
  }
}
/**
 * Cache
 */


toRegexRange.cache = {};

toRegexRange.clearCache = function () {
  return toRegexRange.cache = {};
};
/**
 * Expose `toRegexRange`
 */


module.exports = toRegexRange;
        },
        map: {"@babel/runtime/helpers/slicedToArray":120,"@babel/runtime/helpers/toConsumableArray":35,"@babel/runtime/helpers/defineProperty":13,"is-number":458}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/binary-extensions/binary-extensions.json
      456: {
        factory: (module, exports, require) => {
          ["3dm", "3ds", "3g2", "3gp", "7z", "a", "aac", "adp", "ai", "aif", "aiff", "alz", "ape", "apk", "appimage", "ar", "arj", "asf", "au", "avi", "bak", "baml", "bh", "bin", "bk", "bmp", "btif", "bz2", "bzip2", "cab", "caf", "cgm", "class", "cmx", "cpio", "cr2", "cur", "dat", "dcm", "deb", "dex", "djvu", "dll", "dmg", "dng", "doc", "docm", "docx", "dot", "dotm", "dra", "DS_Store", "dsk", "dts", "dtshd", "dvb", "dwg", "dxf", "ecelp4800", "ecelp7470", "ecelp9600", "egg", "eol", "eot", "epub", "exe", "f4v", "fbs", "fh", "fla", "flac", "flatpak", "fli", "flv", "fpx", "fst", "fvt", "g3", "gh", "gif", "graffle", "gz", "gzip", "h261", "h263", "h264", "icns", "ico", "ief", "img", "ipa", "iso", "jar", "jpeg", "jpg", "jpgv", "jpm", "jxr", "key", "ktx", "lha", "lib", "lvp", "lz", "lzh", "lzma", "lzo", "m3u", "m4a", "m4v", "mar", "mdi", "mht", "mid", "midi", "mj2", "mka", "mkv", "mmr", "mng", "mobi", "mov", "movie", "mp3", "mp4", "mp4a", "mpeg", "mpg", "mpga", "mxu", "nef", "npx", "numbers", "nupkg", "o", "odp", "ods", "odt", "oga", "ogg", "ogv", "otf", "ott", "pages", "pbm", "pcx", "pdb", "pdf", "pea", "pgm", "pic", "png", "pnm", "pot", "potm", "potx", "ppa", "ppam", "ppm", "pps", "ppsm", "ppsx", "ppt", "pptm", "pptx", "psd", "pya", "pyc", "pyo", "pyv", "qt", "rar", "ras", "raw", "resources", "rgb", "rip", "rlc", "rmf", "rmvb", "rpm", "rtf", "rz", "s3m", "s7z", "scpt", "sgi", "shar", "snap", "sil", "sketch", "slk", "smv", "snk", "so", "stl", "suo", "sub", "swf", "tar", "tbz", "tbz2", "tga", "tgz", "thmx", "tif", "tiff", "tlz", "ttc", "ttf", "txz", "udf", "uvh", "uvi", "uvm", "uvp", "uvs", "uvu", "viv", "vob", "war", "wav", "wax", "wbmp", "wdp", "weba", "webm", "webp", "whl", "wim", "wm", "wma", "wmv", "wmx", "woff", "woff2", "wrm", "wvx", "xbm", "xif", "xla", "xlam", "xls", "xlsb", "xlsm", "xlsx", "xlt", "xltm", "xltx", "xm", "xmind", "xpi", "xpm", "xwd", "xz", "z", "zip", "zipx"];
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/color-name/index.js
      457: {
        factory: (module, exports, require) => {
          'use strict';

module.exports = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
        },
        map: {}
      }
    ,
      // /Users/admin/Codes/prefetch_gen/node_modules/is-number/index.js
      458: {
        factory: (module, exports, require) => {
          /*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
'use strict';

module.exports = function (num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }

  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }

  return false;
};
        },
        map: {}
      }
    
      }
    );

